<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库-总结</title>
    <link href="/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="第一章-数据库概论"><a href="#第一章-数据库概论" class="headerlink" title="第一章 数据库概论"></a>第一章 数据库概论</h2><p>数据库是一种依照特定数据模型组织、存储和管理数据的文件集合。这些文件一般存放在外部存储器中，以便长久保存数据，并可快速访问</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型是指描述事物对象的数据结构组成、数据语义联系、数据约束的抽象结构及其说明</p><ul><li>数据结构：用于描述事物对象的静态特征，包括事务对象的数据组成、数据类型、数据性质等</li><li>数据操作：用于描述事务对象的动态特征，包括数据的插入、修改、删除和查询等操作</li><li>数据约束：用于描述数据结构中数据之间的语义联系、数据之间的制约和依存关系，以及数据动态变化的规则等。</li></ul><p>包括层次、网状、关系、其他（对象、键值对、列式、文档、图形）数据模型。</p><h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>数据库系统是一类基于数据库进行数据管理与信息服务的软件系统,由用户，数据库应用程序、数据库管理系统和数据库四个部分组成。</p><ul><li>数据库应用程序是一种在DBMS下对数据库中数据进行访问处理的应用程序</li><li>数据库管理系统是一种专门用来创建数据库、管理数据库、维护数据库，并提供外部对数据库进行访问的系统软件</li></ul><h3 id="数据管理技术发展阶段"><a href="#数据管理技术发展阶段" class="headerlink" title="数据管理技术发展阶段"></a>数据管理技术发展阶段</h3><ul><li><p>人工管理阶段（1940-1950）</p><p>• 程序员组织与管理数据</p><p>• 应用程序依赖数据集</p><p>• 应用之间无数据共享、数据冗余度大</p><p>• 数据集无结构</p></li><li><p>文件管理阶段（1950末-60中）</p><p>•由文件组织与存储数据</p><p>•数据文件的数据记录具有简单的字段结构，但文件整体无结构</p><p>•应用程序依赖于数据文件，需自己维护数据文件</p><p>•数据独立性差，难以实现应用程序之间的数据共享访问</p></li><li><p>数据库系统管理节段（1960末-现在）</p><p>•数据集结构化，易于查询与统计处理</p><p>•不同应用程序可以实现数据共享访问</p><p>•数据独立性高，应用可扩展</p><p>•数据由DBMS统一管理和操作访问</p></li></ul><h3 id="数据库应用系统类型"><a href="#数据库应用系统类型" class="headerlink" title="数据库应用系统类型"></a>数据库应用系统类型</h3><ul><li><p>业务处理系统（商业终端销售系统、航空机票订票系统、酒店系统等）</p><p>是运用数据库应用程序对机构业务活动信息进行记录、计算、检索、汇总、统计等数据处理，为机构操作层面提供基本业务服务，提高业务处理效率的信息系统</p></li><li><p>管理信息系统（人力资源管理信息系统、办公管理信息系统等）</p><p>是一种以机构职能管理为主导，以及计算机软硬件、网络通信、数据库等IT技术，实现机构职能信息化管理，以达到规范化管理和提高机构工作效率，并支持机构职能服务的信息系统。</p></li><li><p>决策支持系统（电信营销大数据决策系统、证券分析与辅助决策信息系统等）</p><p>是以管理科学、运筹学、控制论和行为科学为基础，以计算机技术、数据库技术、人工智能技术为手段，针对特定领域问题解决，为管理者提供辅助决策服务与方案的信息系统。</p></li></ul><h3 id="数据库系统应用结构"><a href="#数据库系统应用结构" class="headerlink" title="数据库系统应用结构"></a>数据库系统应用结构</h3><ul><li><p>单机用户结构</p></li><li><p>集中式结构</p><p>特点: 数据库系统的应用程序、DBMS、数据，都部署在同一服务器上运行，多个用户使用自己的计算机终端网络连接服务器，并可实现共享访问数据库。<br>优缺点: 结构简单，易于维护，但是当终端用户增加到一定数量后，服务器及网络将成为数据存取访问的瓶颈，使系统的性能大大地降低。</p></li><li><p>客户&#x2F;服务器结构</p><p>特点:数据库应用系统的数据集中在数据库服务器管理、应用分布客户机处理。客户端应用程序通过网络并发访问数据库服务器中的数据库。<br>优缺点:在客户&#x2F;服务器结构系统中，客户机程序与数据库服务器分工进行数据处理，提高了系统的负载分担能力，但仍会因大量客户端并发访问数据库服务器，导致系统性能瓶颈。</p></li><li><p>分布式结构</p><p>特点：分布式结构的数据库系统既实现数据分布，又实现处理分布。分布式数据库系统的各服务器结点数据库在逻辑上是一个整体，但物理分布在计算机网络的不同服务器结点上运行。每个数据库服务器可通过网络既支持多个本地客户机访问，也支持远程客户机访问。网络中的每一个数据库服务器都可以独立地存取与处理数据，并执行全局应用<br>优缺点:分布式结构数据库系统适合跨地区的大型机构及企业等组织对数据库应用的需求，其处理性能强，但数据库的分布处理与维护有一定的开销与技术难度。</p></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>需求分析、系统设计、系统实现、系统测试、系统运行与维护</p><h2 id="第二章-关系模型"><a href="#第二章-关系模型" class="headerlink" title="第二章 关系模型"></a>第二章 关系模型</h2><p>由埃德加 科隆提出<br>关系模型以关系代数理论为基础，将数据操作抽象为管理处理，其关系表结构简单，便于理解和访问。</p><h3 id="实体、关系的概念"><a href="#实体、关系的概念" class="headerlink" title="实体、关系的概念"></a>实体、关系的概念</h3><ul><li><p>实体</p><p>指包含由数据特征的事务对象在概念模型世界中的抽象名称</p></li><li><p>关系</p><p>在关系模型中，使用关系来存储实体中的数据。<br>关系是指具有关系特征、用于存放实体数据的二维表。关系也常被称为关系表。</p></li><li><p>关系特征</p><p>• 表中每行存储实体的一个实例数据<br>• 表中每列包含实体的一项属性数据<br>• 表中单元格只能存储单个值<br>• 不允许有重复的行<br>• 不允许有重复的列<br>• 列顺序可任意<br>• 行顺序可任意</p></li></ul><h4 id="关系键、关系模式"><a href="#关系键、关系模式" class="headerlink" title="关系键、关系模式"></a>关系键、关系模式</h4><p>在关系中，可以用来唯一标识元组的属性列，称为键，其他属性列都为非键列。</p><p>复合键：是指关系中用来唯一标识元组的多列作为键。</p><p>候选键：关系中可能由多个列均适合作为建，将其中每个都称为候选键。</p><p>主键：关系表中最有代表性的一个候选键，每个关系表只能定义一个主键。• 唯一标识关系表的每行（元组）</p><p>• 与关联表的外键建立联系，实现关系表之间连接</p><p>• 数据库文件使用主键值来组织关系表的数据存储</p><p>• 数据库使用主键索引快速检索数据</p><p>代理键：采用DBMS自动生成的数字序列作为关系表的主键。</p><ul><li>用途：由DBMS自动生成的数字序列作为主键，可替代复合主键，以便获得更高性能的数据访问操作处理。</li><li>说明：代理键是较短的数字，并且永远不变；代理键的值对用户没有任何意义，通常需要在表单或报表中隐藏它们。</li></ul><h3 id="关系模型原理"><a href="#关系模型原理" class="headerlink" title="关系模型原理"></a>关系模型原理</h3><p>关系模型是一种基于二维表结构存储数据实体及实体间联系的数据模型</p><ul><li><p>数据操作：包括选择（select）、投影（project）、连接（join）、除（Divide）、并（union）、交（intersection）、差（difference）等，也包含插入（Insert）、更新（Update）、删除（Delete）等数据操纵。</p></li><li><p>数据关系约束：包括实体完整性约束、参照完整性约束和用户自定义完整性约束。</p><p>• 属性列取值类型<br>• 属性列取值范围<br>• 属性列取值是否唯一<br>• 属性列是否允许空值<br>• 关联表的参照完整性约束</p><h4 id="关系模型数据操作"><a href="#关系模型数据操作" class="headerlink" title="关系模型数据操作"></a>关系模型数据操作</h4></li><li><p>并运算∪</p></li><li><p>差运算—</p><p>R-S由属于R，而不属于S的所有元组组成。</p></li><li><p>交运算∩</p></li><li><p>笛卡尔积x<br>R×S由所有属于R的元组与所有属于S的元组进行组合而成。</p></li></ul><p>专门的关系运算操作</p><ul><li><p>选择运算<br><img src="E:\typora-user-images\image-20220528142715579.png" alt="image-20220528142715579"></p><p><img src="E:\typora-user-images\image-20220528142731229.png" alt="image-20220528142731229"></p></li><li><p>投影运算</p><p><img src="E:\typora-user-images\image-20220528142752082.png" alt="image-20220528142752082"><br><img src="E:\typora-user-images\image-20220528142806978.png" alt="image-20220528142806978"></p></li><li><p>连接运算</p><p>θ连接：是从R和S的笛卡尔积中选择R关系在A属性组上的值与S<br>关系在B属性组上的值满足比较关系θ的元组集合，组成新的关系。<br><img src="E:\typora-user-images\image-20220528143042451.png" alt="image-20220528143042451"></p><p>自然连接</p><p><img src="E:\typora-user-images\image-20220528143152898.png" alt="image-20220528143152898"></p><p>外连接——左外连接、右外连接、全外连接</p></li><li><p>除运算<br><img src="E:\typora-user-images\image-20220528143359107.png" alt="image-20220528143359107"></p></li></ul><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束</p><ul><li><p>作用</p><p>• 消除关系表的元组重复存储</p><p>• 保持关联表的数据一致性</p><p>• 实现业务数据规则</p></li><li><p>关系模型完整性约束组成</p><ul><li><p>实体完整性约束<br>是指在关系表中试试的主键取值约束，以保证关系表中的每一个元组可以被唯一标识<br>约束规则：</p><ul><li>主键属性列都不允许为空值（NULL）</li><li>主键取值唯一，并区分关系表中的每个元组</li></ul></li><li><p>参照完整性约束<br>是指关系表之间需要遵守的数据约束，一保证关系之间关联列的数据一致性<br>约束规则：</p><ul><li>关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致</li></ul><p>参照完整性检查：</p></li></ul><p><img src="E:\typora-user-images\image-20220528144314414.png" alt="image-20220528144314414"></p><ul><li>用户自定义完整性约束<br>是指用户根据具体业务对数据处理规则要求所定义的数据约束<ul><li>定义列的数据类型与取值范围</li><li>定义列的缺省值</li><li>定义列是否允许取空值</li><li>定义列取值唯一性</li><li>定义列之间的数据依赖性</li></ul></li></ul></li></ul><h2 id="第三章-SQL语言"><a href="#第三章-SQL语言" class="headerlink" title="第三章 SQL语言"></a>第三章 SQL语言</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>SQL是一种对关系数据库进行访问的数据操作语言</p><p>语言特点：</p><ul><li>一体化</li><li>使用方式灵活</li><li>非过程化</li><li>语言语句简单</li></ul><p>主要操作功能：</p><ul><li>数据库对象创建、修改、删除</li><li>数据库表的数据插入、修改、删除、查询、统计</li><li>存储过程、触发器、函数等程序执行</li><li>数据库权限、角色、用户等管理</li></ul><p>语言语句类型</p><ul><li><p>数据定义语言</p><ul><li>CREATE DATABASE - 创建新数据库</li><li>DROP DATABASE</li><li>ALTER DATABASE</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE</li><li>DROP TABLE</li><li>CREATE INDEX-创建索引</li><li>DROP INDEX</li></ul></li><li><p>数据操纵语言</p><ul><li>INSERT</li><li>UPDATE </li><li>DELETE</li></ul></li><li><p>数据查询语言</p><ul><li>SELETE</li></ul></li><li><p>数据控制语言</p><ul><li>GRANT</li><li>DENY</li><li>REVOKE</li></ul></li><li><p>事务处理语言</p><ul><li>BEGIN TRANSACTION-开始事务</li><li>COMMIT-提交事务</li><li>ROLLBACK-回滚事务</li></ul></li><li><p>游标控制语言</p><ul><li>DECLARE CURSOR-定义游标</li><li>FETCH INTO-提交游标数据</li><li>CLOSE CURSOR-关闭游标</li></ul></li></ul><h3 id="数据库创建、修改、删除"><a href="#数据库创建、修改、删除" class="headerlink" title="数据库创建、修改、删除"></a>数据库创建、修改、删除</h3><ul><li><p>执行SQL语句创建一个选课管理数据库CourseDB<br>CREATE DATABASE CourseDB;</p></li><li><p>将选课管理数据库名称CourseDB修改为CourseManageDB<br>ALTER DATABASE CourseDB RENAME TO CourseManageDB;</p></li><li><p>删除前面创建的选课管理数据库CourseManageDB<br>DROP DATABASE CourseManageDB；</p></li></ul><h3 id="数据库表创建、修改、删除"><a href="#数据库表创建、修改、删除" class="headerlink" title="数据库表创建、修改、删除"></a>数据库表创建、修改、删除</h3><ul><li><p>创建</p><p>CREATE TABLE &lt;表名&gt;</p><p> （ &lt;列名1&gt; &lt;数据类型&gt; [列完整性约束]，</p><p>  &lt;列名2&gt; &lt;数据类型&gt;  [列完整性约束]， </p><p>  &lt;列名3&gt; &lt;数据类型&gt; [列完整性约束]，</p><p>  …</p><p>  )；</p><p><img src="E:\typora-user-images\image-20220528153017343.png" alt="image-20220528153017343"></p><ul><li><p>列完整性约束</p><ul><li><p>RPIMARY KEY-主键</p></li><li><p>NULL&#x2F;NOT NULL-空值&#x2F;非空值</p></li><li><p>UNIQUE-值唯一</p><p><img src="E:\typora-user-images\image-20220528153050135.png" alt="image-20220528153050135"></p></li><li><p>CHECK-有效性检查<br><img src="E:\typora-user-images\image-20220528153105536.png" alt="image-20220528153105536"></p></li><li><p>DEFAULT-缺省值<br><img src="E:\typora-user-images\image-20220528153119557.png" alt="image-20220528153119557"></p></li></ul></li><li><p>表约束定义主键<br>CONSTRAINT &lt;主键名&gt; RPIMARY Key（主键列）<br><img src="E:\typora-user-images\image-20220528153434343.png" alt="image-20220528153434343"></p></li><li><p>表约束定义代理键</p><p>CONSTRAINT &lt;约束名&gt; RPIMARY Key （代理键列名）</p></li><li><p>表约束定义外键<br>CONSTRAINT &lt;约束名&gt; FOREIGN Key （主键列）<br><img src="E:\typora-user-images\image-20220528153827740.png" alt="image-20220528153827740"></p></li></ul></li><li><p>修改</p><ul><li><p>ADD修改方式，用于增加新列或列完整性约束<br>ALTER TABLE &lt;表名&gt; ADD &lt;新列名称&gt;&lt;数据类型&gt;|[完整性约束]；</p></li><li><p>DROP修改方式，用于删除指定列或列的完整性约束条件<br>ALTER TABLE&lt;表名&gt; DROP COLUMN &lt;列名&gt;；<br>ALTER TABLE&lt;表名&gt; DROP CONSTRAINT&lt;完整性约束名&gt;；</p></li><li><p>RENAME修改方式，用于修改表名称，列名称<br>ALTER TABLE &lt;表名&gt; RENAME TO &lt;新表名&gt;；<br>ALTER TABLE &lt;表名&gt; RENAME &lt;原列名&gt; TO &lt;新列名&gt;；</p></li><li><p>ALTER修改方式，用于修改列的数据类型</p><p>ALTER TABLE &lt;表名&gt; ALTER COLUMN &lt;列名&gt; TYPE&lt;新的数据类型&gt;；</p></li></ul></li><li><p>删除<br>DROP TABLE &lt;表名&gt;；</p></li></ul><h3 id="数据库索引创建、修改、删除"><a href="#数据库索引创建、修改、删除" class="headerlink" title="数据库索引创建、修改、删除"></a>数据库索引创建、修改、删除</h3><p>索引是一种按照关系表中指定列的取值顺序存储的数据结构，使用它可以加快表中数据的查询访问。</p><p>作用：支持对数据库表中数据快速查找，其机理类似图书目录可以快速定位章节内容</p><ul><li><p>创建<br>CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt;&lt;（列名）&gt;；</p><ul><li><p>在学生信息表Student中，为出生日期Birthday列创建索引，以便支持按出生日期快速查询学生信息。</p><p>CREATE INDEX Birthday_Idx ON STUDENT （Birthday）；</p></li></ul></li><li><p>修改<br>ALTER INDEX &lt;索引名&gt; &lt;修改项&gt;；<br>ALTER INDEX &lt;索引名&gt; RENAME TO &lt;新索引名&gt;；</p><ul><li><p>在学生信息表Student中，将原索引Birthday_Idx更名为Bday_Idx，其索引修改SQL语句如下：</p><p>ALTER INDEX Birthday_Idx RENAME TO Bday_Idx；</p></li></ul></li><li><p>删除<br>DROP INDEX &lt;索引名&gt; ；</p><ul><li><p>在学生信息表Student中，删除bday_idx索引，其索引删除SQL语句如下：</p><p>DROP INDEX bday_idx；</p></li></ul></li></ul><h3 id="数据操纵语句"><a href="#数据操纵语句" class="headerlink" title="数据操纵语句"></a>数据操纵语句</h3><h4 id="数据插入语句"><a href="#数据插入语句" class="headerlink" title="数据插入语句"></a>数据插入语句</h4><p>INSERT INTO &lt;表名|视图名&gt;[&lt;列名表&gt;] VALUES （列值表）;</p><ul><li><p>在学生信息表Student中，插入一个新的学生数据，如“2017220101105”，“柳因”，“女”，“1999-04-23”，“软件工程”，“<a href="mailto:&#x6c;&#x69;&#x75;&#x79;&#105;&#x6e;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;">&#x6c;&#x69;&#x75;&#x79;&#105;&#x6e;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;</a>”。</p><p>INSERT INTO Student VALUES(‘2017220101105’,’柳因’,’女’,’1999-04-23’,’软件工程’, ‘<a href="mailto:&#x6c;&#x69;&#117;&#121;&#x69;&#110;&#64;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;">&#x6c;&#x69;&#117;&#121;&#x69;&#110;&#64;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;</a>‘);</p></li></ul><h4 id="数据更新语句"><a href="#数据更新语句" class="headerlink" title="数据更新语句"></a>数据更新语句</h4><p>UPDATE &lt;表名|视图名&gt;<br>SET &lt;列名1&gt;&#x3D;&lt;表达式1&gt; [，&lt;列名2&gt;&#x3D;&lt;表达式2&gt;…]<br>[WHERE &lt;条件表达式&gt;]；</p><ul><li><p>在学生信息表Student中，学生“赵东”的原有Email数据为空，现需要修改为“<a href="mailto:&#122;&#x68;&#x61;&#111;&#x64;&#111;&#x6e;&#x67;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;">&#122;&#x68;&#x61;&#111;&#x64;&#111;&#x6e;&#x67;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a>”。</p><p>UPDATE Student<br>SET  Email&#x3D;‘<a href="mailto:&#122;&#x68;&#97;&#111;&#x64;&#x6f;&#x6e;&#x67;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;">&#122;&#x68;&#97;&#111;&#x64;&#x6f;&#x6e;&#x67;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;</a>‘<br>WHERE  StudentName&#x3D;’赵东’;</p></li></ul><h4 id="数据删除语句"><a href="#数据删除语句" class="headerlink" title="数据删除语句"></a>数据删除语句</h4><p>DELETE<br>FROM &lt;表名|视图名&gt;<br>[WHERE  &lt;条件表达式&gt;]；</p><ul><li><p>在学生信息表STUDENT中，删除姓名为 “张亮”的学生数据，其数据删除的SQL语句如下</p><p>DELETE<br>FROM STUDENT<br>WHERE  StudentName&#x3D;’张亮’;</p></li></ul><h3 id="数据查询语句"><a href="#数据查询语句" class="headerlink" title="数据查询语句"></a>数据查询语句</h3><h4 id="单表数据查询"><a href="#单表数据查询" class="headerlink" title="单表数据查询"></a>单表数据查询</h4><p>SELECT ColumnNames<br>FROM  TableName<br>WHERE SomeConditionExits;</p><ul><li><p>使用BETWEEN..AND关键词来限定列值范围，还可以使用关键词LIKE与通配符来限定查询条件。<br><img src="E:\typora-user-images\image-20220528161913181.png" alt="image-20220528161913181"></p></li><li><p>使用通配符来限定字符串数据范围。下划线（_）通配符用于代表一个未指定的字符。百分号（%）通配符用于代表一个或多个未指定的字符。<br><img src="E:\typora-user-images\image-20220528161927311.png" alt="image-20220528161927311"></p></li><li><p>可以使用多个条件表达式，并通过逻辑运算符（AND、OR、NOT）连接操作，以及使用IN、NOT IN、IS NULL、IS NOT NULL关键词，进一步限定结果集的数据范围。<br><img src="E:\typora-user-images\image-20220528161956634.png" alt="image-20220528161956634"></p></li></ul><p>​<img src="E:\typora-user-images\image-20220528162040964.png" alt="image-20220528162040964"></p><p>对结果集进行排序</p><ul><li><p>在SELECT查询语句返回的结果集中,行的顺序是任意的。如果需要结果集排序，可以在SELECT语句中加入ORDER BY关键字。<br><img src="E:\typora-user-images\image-20220528162125039.png" alt="image-20220528162125039"></p></li><li><p>ASC和DESC选定排序是升序或降序</p></li></ul><h4 id="内置函数、分组统计"><a href="#内置函数、分组统计" class="headerlink" title="内置函数、分组统计"></a>内置函数、分组统计</h4><p>典型SQL内置函数包括：聚合、算术、字符串、日期时间、数据类型转换函数</p><ul><li><p>聚合函数</p><table><thead><tr><th>聚合函数</th><th>功能</th></tr></thead><tbody><tr><td>AVG（）</td><td>计算结果集指定列数据的平均值</td></tr><tr><td>COUNT（）</td><td>计算结果集行数</td></tr><tr><td>MIN（）</td><td>找出结果集指定列数据的最小值</td></tr><tr><td>MAX（）</td><td>找出结果集指定列数据的最小值</td></tr><tr><td>SUM（）</td><td>计算结果集指定列数据的总和</td></tr></tbody></table><ul><li><p>统计Student表中的学生人数，在SELECT语句中可以使用COUNT（）函数来计算，其查询SQL语句如下：</p><p>SELECT COUNT（*） AS 学生人数<br>FROM Student;</p></li></ul></li><li><p>分组统计<br>通过在SELECT语句中加入Group By子语句来实现</p><p>SELECT  统计函数（目标列）<br>FROM &lt;表名&gt;<br>[WHERE 条件]<br>GROUP BY &lt;目标列&gt;<br>[Having 条件];</p><ul><li><p>分专业统计Student表中的学生人数。在SELECT语句中可以使用GROUP BY分组子句完成统计，其查询SQL语句如下：</p><p>SELECT Major AS 专业, COUNT（StudentID） AS 学生人数FROM Student<br>GROUP BY Major;</p></li><li><p>若要分专业统计STUDENT表中男生人数，但限定只显示人数大于2的人数，其查询SQL语句如下：</p><p>SELECT Major AS 专业, COUNT（StudentID） AS 学生人数FROM Student<br>WHERE StudentGender&#x3D;’男’<br>GROUP BY Major<br>HAVING COUNT(*)&gt;2;</p></li></ul></li></ul><h4 id="多表关联查询"><a href="#多表关联查询" class="headerlink" title="多表关联查询"></a>多表关联查询</h4><ul><li><p>子查询与多表关联</p><p>SELECT  &lt;目标列&gt;[，&lt;目标列&gt;…]<br>FROM &lt;表名&gt;<br>WHERE &lt;条件中嵌套另一关系表的SELECT 查询结果集&gt;</p><ul><li><p>在选课管理系统数据库中，希望能检索出“计算机学院”的教师名单。该操作需要关联教师信息表Teacher和学院信息表College，才能获得这些数据。这里可采用子查询方法实现两表关联查询，其查询SQL语句如下：</p><p>SELECT TeacherID, TeacherName, TeacherTitle<br>FROM Teacher<br>WHERE CollegeID IN<br>(SELECT CollegeID<br>FROM College<br>   WHERE CollegeName&#x3D;’计算机学院’);</p></li></ul></li><li><p>使用连接关联多表查询</p><p>SELECT  &lt;目标列&gt;[，&lt;目标列&gt;…]<br>FROM &lt;表名1&gt;，&lt;表名2&gt;，…, &lt;表名n&gt;，<br>WHERE &lt;关系表之间的连接关联条件&gt;</p><ul><li><p>在选课管理系统数据库中，希望获得各个学院的教师信息列表，包括学院名称、教师编号、教师姓名、教师性别、职称等信息。要求按学院名称、教师编号分别排序输出，其查询SQL语句如下：</p><p>SELECT B.CollegeName AS 学院名称, A.TeacherID AS 编号, A.TeacherName AS 姓名, A.TeacherGender AS 性别, A. TeacherTitle AS 职称<br>FROM Teacher AS A，College AS B<br>WHERE A.CollegeID&#x3D;B.CollegeID<br>ORDER BY B.CollegeName, A.TeacherID;</p></li></ul></li><li><p>JOIN……on连接查询语句</p><p>SELECT &lt;目标列&gt;[，&lt;目标列&gt;…]<br>FROM &lt;表名1&gt; JOIN &lt;表名2&gt; ON &lt;连接条件&gt;;</p><ul><li><p>在选课管理系统数据库中，希望获得各个学院的教师信息，包括学院名称、教师编号、教师姓名、教师性别、职称等信息。要求按学院名称、教师编号分别排序输出，其查询SQL语句如下：</p><p>SELECT B.CollegeName AS 学院名称, A.TeacherID AS 编号, A.TeacherName AS 姓名, A.TeacherGender AS 性别, A. TeacherTitle AS 职称<br>FROM TEACHER AS A JOIN COLLEGE AS B<br>ON A.CollegeID&#x3D;B.CollegeID<br>ORDER BY B.CollegeName, A.TeacherID;</p></li></ul></li><li><p>外部连接</p><p>LEFT JOIN: 左外连接，即使没有与右表关联列值匹配，也从左表返回所有的行。<br>RIGHT JOIN: 右外连接，即使没有与左表关联列值匹配，也从右表返回所有的行。<br>FULL JOIN: 全外连接，同时进行左连接和右连接，就返回所有行。</p><ul><li><p>在选课管理系统数据库中，希望能查询所有开设课程的学生选课情况，包括课程名称、任课教师、选课学生人数。这需要关联课程信息表COURSE、开课计划表PLAN、教师信息表TEACHER、选课注册信息表REGISTER。若使用左外连接查询，该JOIN…ON连接查询的SQL语句如下：</p><p>SELECT C.CourseName AS 课程名称, T.TeacherName AS 教师, COUNT (R.CoursePlanID) AS 选课人数<br>FROM COURSE AS C JOIN PLAN AS P<br>ON C.CourseID&#x3D;P.CourseID<br>JOIN TEACHER AS T ON P.TeacherID&#x3D;T.TeacherID<br>LEFT JOIN REGISTER AS R ON<br>P.CoursePlanID&#x3D;R.CoursePlanID<br>GROUP BY C.CourseName, T.TeacherName;</p></li></ul></li></ul><h3 id="数据控制语句"><a href="#数据控制语句" class="headerlink" title="数据控制语句"></a>数据控制语句</h3><p>数据控制语句是一种可对用户数据访问全进行控制的操作语句，它可以控制特定用户或角色对数据表、视图、存储过程、触发器等数据库对象的访问权限。</p><ul><li><p>GRANT授权语句</p><p>GRANT &lt;权限列表&gt; ON &lt;数据库对象&gt; TO &lt;用户或角色&gt; [ WITH GRANT OPTION ]；</p><ul><li><p>在选课管理系统数据库中，将课程注册表REGISTER的数据插入、数据修改、数据删除、数据查询访问权限赋予学生角色RoleS。</p><p>GRANT SELECT, INSERT, UPDATE, DELETE ON REGISTER TO RoleS;</p></li></ul></li><li><p>REVOKE授权语句</p><p>REVOKE &lt;权限列表&gt; ON &lt;数据库对象&gt; FROM &lt;用户或角色&gt; ;</p><ul><li><p>在选课管理系统数据库中，收回学生角色RoleS在课程注册表REGISTER的数据删除访问权限。</p><p>REVOKE DELETE ON REGISTER FROM RoleS;</p></li></ul></li><li><p>DENY授权语句</p><p>DENY &lt;权限列表&gt; ON &lt;数据库对象&gt; TO &lt;用户或角色&gt; ;</p><ul><li><p>在选课管理系统数据库中，若拒绝教师角色RoleT对教师表TEACHER的数据删除访问权限</p><p>DENY DELETE ON TEACHER TO RoleT;</p></li></ul></li></ul><h3 id="视图SQL语句"><a href="#视图SQL语句" class="headerlink" title="视图SQL语句"></a>视图SQL语句</h3><p>视图是一种通过基础表或其它视图构建的虚拟表。它本身没有自己的数据，而是使用了存储在基础表中的数据。</p><ul><li><p>创建<br>CREATE VIEW &lt;视图名&gt;[(列名1)，(列名2)，…] AS &lt;SELECT查询&gt;；</p><ul><li><p>在选课管理系统数据库中，若需要建立一个查看基础课数据的视图BasicCourseView，其创建SQL语句如下。</p><p>CREATE VIEW BasicCourseView AS<br>SELECT CourseName, CourseCredit, CoursePeriod, TestMethod<br>FROM  COURSE<br>WHERE CourseType&#x3D;‘基础课’;</p></li></ul></li><li><p>删除<br>DROP VIEW &lt;视图名&gt;；</p></li></ul><p>视图应用</p><ul><li><p>使用视图简化复杂SQL查询操作</p><ul><li><p>在选课管理系统数据库中，查询选修“数据库系统原理与开发”课程的学生名单。这需要关联课程信息表COURSE、开课计划表PLAN、选课注册信息表REGISTER、学生信息表STUDENT，其查询SQL语句如下：</p><p>SELECT C.CourseName AS 课程名称, S.StudentID AS 学号, S.StudentName AS 姓名<br>FROM COURSE AS C, PLAN AS P, REGISTER AS R, STUDENT AS S<br>WHERE C.CourseID&#x3D;P.CourseID AND C.CourseName&#x3D;‘数据库系统原理与开发’AND P.CoursePlanID&#x3D;R.CoursePlanID AND R.StudentID&#x3D;S.StudentID;</p></li><li><p>上面这个SQL语句是较复杂和冗长，为了让外部程序简单地实现该信息查询，可以先定义一个名称为DatabaseCourseView视图，其创建SQL语句如下：</p><p>CREATE VIEW DatabaseCourseView AS<br>  SELECT C.CourseName AS 课程名称, S.StudentID AS 学号, S.StudentName AS 姓名<br>FROM COURSE AS C，PLAN AS P, REGISTER AS R, STUDENT AS S<br>WHERE C.CourseID&#x3D;P.CourseID AND C. CourseName&#x3D;‘数据库系统原理与开发’ AND P.CoursePlanID&#x3D;R.CoursePlanID AND R.StudentID&#x3D;S. StudentID;</p></li></ul></li><li><p>使用视图提高数据访问安全性</p></li><li><p>提供一定程度的数据逻辑独立性</p></li><li><p>集中展示用户所感兴趣的特定数据</p></li></ul><h2 id="第四章-数据库设计"><a href="#第四章-数据库设计" class="headerlink" title="第四章 数据库设计"></a>第四章 数据库设计</h2><h3 id="数据库设计方案"><a href="#数据库设计方案" class="headerlink" title="数据库设计方案"></a>数据库设计方案</h3><ul><li><p>数据库应用访问方式</p></li><li><p>数据库结构模型</p><ul><li><p>概念数据模型</p><p>是一种面向用户的系统所数据模型，用来描述显示世界的系统概念化数据结构。</p></li><li><p>逻辑数据模型</p><p>在概念数据模型基础上，从系统设计角度描述系统的数据对象组成及其关联结构，并考虑这些数据对象符合数据库对象的逻辑表示。</p></li><li><p>物理数据模型</p><p>在逻辑数据模型基础上，针对具体DBMS所设计的数据模型。</p></li></ul></li><li><p>数据库应用结构</p></li></ul><h3 id="数据库开发过程及设计策略"><a href="#数据库开发过程及设计策略" class="headerlink" title="数据库开发过程及设计策略"></a>数据库开发过程及设计策略</h3><p>数据库开发过程</p><ul><li><p>数据需求分析</p><ul><li>从现实业务获取数据表单、报表、查询、业务规则、数据更新的说明</li><li>分析系统的数据特征、数据类型、数据取值约束</li><li>描述系统的数据关系、数据处理要求</li><li>建立系统的数据字典</li></ul></li><li><p>数据库设计阶段</p><ul><li>数据库模型结构设计（系统概念数据建模、系统逻辑数据建模、系统物理数据建模）</li><li>数据库索引、视图、查询设计</li><li>数据库表约束设计</li><li>数据库触发器、存储过程设计</li></ul></li><li><p>数据库实现</p><ul><li>数据库创建</li><li>数据模型物理实现</li></ul></li><li><p>数据库测试</p><p>数据库数据上线</p><p>数据库系统测试</p></li></ul><p>设计策略</p><ul><li>自底向上设计</li><li>自顶向下设计</li><li>子内向外设计</li><li>混合策略设计</li></ul><h3 id="E-R模型方法"><a href="#E-R模型方法" class="headerlink" title="E-R模型方法"></a>E-R模型方法</h3><h4 id="基本建模"><a href="#基本建模" class="headerlink" title="基本建模"></a>基本建模</h4><p>E-R模型：实体-联系模型，基本元素包括实体、属性、标识符和联系</p><ul><li><p>实体</p><p>是指问题域中存在的人、事、物、地点等客观事务在逻辑层面的数据抽象。</p></li><li><p>属性</p><p>是指描述实体特征的数据项。</p></li><li><p>标识符</p><p>是指标识不同实体实例的属性。</p><p>标识符与主键的区别是标识符是一个逻辑概念，主键是物理概念。</p></li><li><p>联系</p><p>是指实体之间的关联关系</p><p>实体之间的关联的数目被称为元</p><ul><li><p>二元实体联系类型</p><ul><li>1对1</li><li>1对多</li><li>多对多</li></ul><p><img src="E:\typora-user-images\image-20220529112740146.png" alt="image-20220529112740146"></p><ul><li><pre><code class="hljs">    可选</code></pre></li><li><pre><code class="hljs">    强制</code></pre></li></ul><p><img src="E:\typora-user-images\image-20220529113003762.png" alt="image-20220529113003762"></p></li></ul></li></ul><h4 id="扩展建模"><a href="#扩展建模" class="headerlink" title="扩展建模"></a>扩展建模</h4><p>实体继承联系：</p><p>父实体：具有公共属性的实体；子实体：与父实体具有相似属性，同时也具有特殊性的一个或多个实体</p><ul><li><p>互斥性继承联系</p></li><li><p>非互斥性继承联系<br><img src="E:\typora-user-images\image-20220529145948199.png" alt="image-20220529145948199"></p></li><li><p>完整继承</p></li><li><p>非完整继承<br><img src="E:\typora-user-images\image-20220529150024453.png" alt="image-20220529150024453"></p></li></ul><p>强弱实体联系：</p><p>弱实体：指那些对于另外实体有依赖关系的实体，一个实体的存在必须以另一实体的存在为前提<br>强实体：被依赖的实体<br>标识符依赖弱实体：即弱实体的标识符中含有所依赖实体的标识符，即该弱实体称为标识符依赖弱实体<br><img src="E:\typora-user-images\image-20220529151200063.png" alt="image-20220529151200063"></p><p>非标识符依赖弱实体</p><h3 id="数据库规范化设计"><a href="#数据库规范化设计" class="headerlink" title="数据库规范化设计"></a>数据库规范化设计</h3><p>为什么需要规范化数据库设计？</p><ul><li>减少数据库中的冗余数据，尽量使同一数据在数据库中仅保存一份，有效降低维护数据一致性的工作量</li><li>设计合理的表间依赖关系和约束关系，便于实现数据完整性和一致性</li><li>设计合理的数据库结构，便于系统对数据高效访问处理</li></ul><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p>定义：设有一关系模式R（U）， U 为关系R的属性集合，X和Y为属性U的子集。设t，s是关系R中的任意两个元组，如果t[X] &#x3D; s[X]，则t[Y] &#x3D; s[Y]。那么称Y函数依赖于X，表示为X→Y。<br>函数依赖的左部称为决定因子，右部称为依赖函数。决定因子和依赖函数都是属性的集合</p><p>说明：<br>函数依赖反映属性或属性组之间相互依存、互相制约的关系，即关系表中属性之间的依赖关系。</p><ul><li>完全函数依赖<br>设X、Y是某关系的不同属性集，如X→Y，且不存在X’ÌX ，使X’→Y，则Y称完全函数依赖，否则称Y部分函数依赖。</li><li>部分函数依赖</li><li>属性传递依赖<br>设X、Y、Z是某关系的不同属性集，有X→Y，Y→X  ， Y→Z，若X→Z，称Z对X存在函数传递依赖</li><li>多值函数依赖<br>设U是关系模式R的属性集，X和Y是U的子集，Z&#x3D;U-X-Y，xyz表示属性集XYZ的值。对于R的关系r，在r中存在元组（x, y1, z1）和（x, y2, z2）时，也存在元组（x, y1, z2）和（x, y2, z1），那么在模式R上存在多值函数依赖。</li></ul><h4 id="关系规范化范式"><a href="#关系规范化范式" class="headerlink" title="关系规范化范式"></a>关系规范化范式</h4><p>关系规范化：是把一个有访问异常的关系分解成结构良好的关系的过程，使得这些关系又最小的冗余或没有冗余</p><p>规范化范式：是指关系表符合特定规范化程度的模式</p><ul><li><p>第一范式（1NF）<br>关系表中的属性不可再细分</p></li><li><p>第二范式（2NF）</p><p>关系满足第一范式，并消除了关系中的属性部分函数依赖</p><p>例 有一个关系（A,B,N,O,P）,其复合主键为（A,B）,那么N,O,P这三个非键属性都不存在只依赖A或只依赖B情况，则该关系满足第2范式,反之,不满足第2范式。</p></li><li><p>第三范式（3NF）</p><p>关系满足第2范式，并切断了关系中的属性传递函数依赖</p><p>例 若有一个关系（A,N,O,P）,主键为（A）,那么非键属性N,O或P都不能由单个的N,O或P或它们的组合所确定。该关系满足第3范式。</p></li><li><p>巴斯-科德范式（BCNF）</p><p>在关系中，所有函数依赖都是候选键</p><p>例 关系STUDENT(StudentNum, Name, Email)中，决定因子StudentNum也是候选键，该关系满足BCNF范式。</p></li><li><p>第四范式（4NF）</p><p>关系满足BCNF范式，并消除了多值依赖函数依赖</p><p>设学校中某一门课程由多个教师讲授，每个教师可有自己的参考书。用关系模式Teaching（Course，Teacher，Book）来表示课程、教师和参考书之间的关系。<br>该关系Teaching（Course，Teacher，Book），属于BCNF范式；但是存在多值函数依赖，即不满足4NF。</p></li></ul><p>关系的规范化程度依次提升：1NF→ 2NF → 3NF→ BNCF → 4NF</p><p>逆规范化处理</p><p>逆规范化：适当降低规范化范式约束，不再要求一个关系表必须达到很高的规范化程度，而是允许适当的数据冗余性，以获取数据访问性能。</p><p>基本方法:</p><p>增加冗余列或派生列<br>多个关系表合并为一个关系表</p><h2 id="第五章-数据库管理"><a href="#第五章-数据库管理" class="headerlink" title="第五章 数据库管理"></a>第五章 数据库管理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>数据库管理是指为保证数据库系统的正常运行和服务质量必须进行的系统管理工作</p><p>为什么需要数据库管理</p><ul><li>数据库系统随规模增大，系统会变得异常复杂</li><li>多用户数据库应用带来数据库访问复杂性</li><li>数据安全和数据隐私对机构和用户都非常重要</li><li>数据库系统随数据量增加和使用时间增长其性能降低</li><li>系统遭遇意外，数据库损坏或数据丢失</li></ul><p>管理目标</p><ul><li>保障数据库系统正常运行</li><li>充分发挥数据库系统的软硬件处理能力</li><li>确保数据库系统安全和用户数据隐私性</li><li>有效管理数据库用户及其角色权限</li><li>解决数据库系统性能优化、系统故障与数据损坏等问题</li><li>最大程度地发挥数据库对其所属机构的作用</li></ul><p>管理内容</p><ul><li>DBMS系统运行管理</li><li>数据库性能监控</li><li>数据库索引管理</li><li>数据库查询优化</li><li>数据库事务并发控制</li><li>数据库角色管理</li><li>数据库用户管理</li><li>数据库对象权限管理</li><li>数据安全管理</li><li>数据库备份</li><li>数据库恢复等</li></ul><p>管理员DBA职责</p><ul><li>负责数据库系统开发与运维</li><li>负责数据库用户与权限管理</li><li>负责数据库备份与数据库恢复管理</li><li>负责数据库性能调优管理等</li></ul><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>事务是指由单个业务处理单元的一组数据库访问操作，要求它们要么都成功执行，要么都不执行。</p><p>事务是DBMS执行的最小任务单元。同时，事务也是DBMS最小的故障恢复单元和并发控制任务单元。<br><img src="E:\typora-user-images\image-20220529204032657.png" alt="image-20220529204032657"></p><p>事务特性</p><ul><li>原子性：事务所有操作在数据库中要么全部执行，要么全部不执行</li><li>一致性：事务多次执行，其结果应一致</li><li>隔离性：事物与事物之间隔离，并发执行透明</li><li>持续性：事务完成后，数据改变必须是永久的</li></ul><p>事务并发执行</p><p>事务并发执行是指多个事务程序在数据库系统中同一时段运行</p><ul><li>改善系统的资源利用率</li><li>减少事务运行的平均等待时间</li></ul><p>事务SQL语句</p><ul><li>BEGIN或START TRANSACTION事务开始语句</li><li>ROLLBACK事务回滚语句</li><li>COMMIT       事务提交语句</li><li>SAVEPOINT   事务保存语句</li></ul><p>基本框架</p><p><img src="E:\typora-user-images\image-20220529230344578.png" alt="image-20220529230344578"></p><p>注意事项</p><p><img src="E:\typora-user-images\image-20220529230456852.png" alt="image-20220529230456852"></p><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="事务调度"><a href="#事务调度" class="headerlink" title="事务调度"></a>事务调度</h4><p>目的</p><ul><li>支持并发事务处理，使更多用户并行操作，提高系统的并发访问能力</li><li>保证一个事务工作不会对另一个事务工作产生不合理的影响</li></ul><p>问题</p><ul><li><p>丢失更新数据<br><img src="E:\typora-user-images\image-20220529230832075.png" alt="image-20220529230832075"></p></li><li><p>脏数据读取<br><img src="E:\typora-user-images\image-20220529230909364.png" alt="image-20220529230909364"></p></li><li><p>不可重复读取<br><img src="E:\typora-user-images\image-20220529230928790.png" alt="image-20220529230928790"></p></li></ul><p>并发事务调度原理与策略</p><p>并发事务调度：控制多个事务的数据操作语句按照恰当的顺序访问共享数据，使这些事务执行之后，避免造成数据的不一致性，即解决“丢失更新数据”等问题</p><p>目标：使并发事务调度实现的处理结果与串行化调度处理结果一致</p><h4 id="锁机制、控制协议、死锁、事务隔离"><a href="#锁机制、控制协议、死锁、事务隔离" class="headerlink" title="锁机制、控制协议、死锁、事务隔离"></a>锁机制、控制协议、死锁、事务隔离</h4><p>资源锁定访问</p><ul><li>排它锁定（Lock-X）-又称写锁，若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再加锁读取和修改A。</li><li>共享锁定（Lock-S）-又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li></ul><p>资源锁定粒度</p><ul><li>数据库-粒度最大</li><li>表</li><li>页面</li><li>行</li></ul><p>资源锁定实施方式</p><ul><li>隐式锁定-DBMS缺省执行</li><li>显示锁定-加锁命令显示执行</li></ul><p>基于锁机制的并发控制协议</p><ul><li><p>锁操作的相容性</p><p><img src="E:\typora-user-images\image-20220529231838610.png" alt="image-20220529231838610"></p></li><li><p>加锁协议</p><ul><li><p>一级加锁协议<br>任何事务在修改共享数据对象之前，必须对该数据执行排它锁定指令，直到该事务处理完成，才进行解锁指令执行</p><p>可避免更新丢失问题，其他不可解决</p></li><li><p>二级加锁协议<br>在一级加锁协议基础上，针对并发事务的共享数据读操作，必须对该数据执行共享锁定指令，读完数据后即可释放共享锁定</p><p>可能会出现“不可重复读取”的数据不一致问题</p></li><li><p>三级加锁协议<br>在一级加锁协议基础上，针对并发事务对共享数据进行读操作，必须对该数据执行共享锁定指令，直到该事务处理结束才释放共享锁定。</p></li></ul></li><li><p>不同级别锁协议比较</p><p><img src="E:\typora-user-images\image-20220529232418408.png" alt="image-20220529232418408"></p></li></ul><p>两阶段加锁协议</p><p>并发事务的正确调度准则：一个给定的并发事务调度，当且仅当它是可串行化时，才能保证正确调度。<br>保证可串行化的一个协议是：二阶2段锁定协议</p><p>二阶段锁定协议规定每个事务必须分两个阶段提出加锁和解锁申请</p><ul><li>增长阶段，事务只能获得锁，但不能释放锁</li><li>缩减阶段，事务只能释放锁，但不能获得新锁</li></ul><p>死锁问题解决</p><ul><li><p>事务死锁<br>在基于锁机制的并发事务执行中，如果这些事务同时锁定两个以及以上资源时，可能会出现彼此都不能继续执行的状态，即事物死锁状态</p></li><li><p>死锁出现的必要条件</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ul></li><li><p>防范死锁的策略</p><ul><li>允许用户一次发出当前所需全部资源的锁定，使用完成后，再释放给其它用户访问</li><li>规定所有应用程序锁定资源的顺序必须完全相同</li></ul></li><li><p>解决方法</p><p>当发生死锁时，回滚其中的一个事务，并取消它对数据库所做的改动</p></li></ul><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><h4 id="存取安全模型"><a href="#存取安全模型" class="headerlink" title="存取安全模型"></a>存取安全模型</h4><p>数据库系统面临的安全风险</p><ul><li><p>黑客利用系统漏洞，攻击系统运行、窃取和篡改系统数据。</p></li><li><p>内部人员非法地泄露、篡改、删除系统的用户数据。</p></li><li><p>系统运维人员操作失误导致数据被删除或数据库服务器系统宕机。</p></li><li><p>系统故障导致数据库的数据损坏、数据丢失、数据库实例无法启动。</p></li><li><p>意外灾害事件（火灾、水灾、地震等自然灾害）导致系统被破坏。</p></li></ul><p>数据库系统安全模型</p><ul><li>身份验证：从应用系统层面确认登录用户是否合法使用者</li><li>权限控制：从DBMS系统层面通过存取权限机制控制用户对数据的访问</li><li>系统防护：从操作系统层面提供的安全机制非法系统访问</li><li>加密存储：从数据存储层面通过加密算法对数据库中数据进行加密存储</li></ul><h3 id="用户、角色、权限管理"><a href="#用户、角色、权限管理" class="headerlink" title="用户、角色、权限管理"></a>用户、角色、权限管理</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><ul><li><p>用户创建<br>CREATE USER &lt;用户账号名&gt; [ [WITH] option […]];</p><ul><li>创建一个新用户，其账号名字为“userA”，密码为“123456”。该用户具有登录权限（Login）和角色继承权限（Inherit）系统权限，但它不是超级用户（SuperUser），不具有创建数据库权限（CreateDB）、创建角色权限（CreateRole）、数据库复制权限（Replication），此外数据库连接数（Connection Limit）不受限。<br>CREATE USER “userA” WITH<br> LOGIN<br> NOSUPERUSER<br> NOCREATEDB<br> NOCREATEROLE<br> INHERIT<br> NOREPLICATION<br> CONNECTION LIMIT -1<br> PASSWORD ‘123456’;</li></ul></li><li><p>用户修改</p><p>ALTER USER &lt;用户名&gt; [ [ WITH ] option [ … ] ];  –修改用户的属性ALTER USER &lt;用户名&gt; RENAME TO &lt;新用户名&gt;;  –修改用户的名称ALTER USER &lt;用户名&gt; SET &lt;参数项&gt; { TO | &#x3D; } { value | DEFAULT }; –修改用户的参数值<br>ALTER USER &lt;用户名&gt; RESET &lt;参数项&gt;; –重置用户参数值</p><ul><li><p>修改用户“userA”的账号密码为“gres123”。同时也限制该用户的数据库连接数为10。</p><p>ALTER USER “userA”<br> CONNECTION LIMIT 10<br> PASSWORD ‘gres123’;</p></li></ul></li><li><p>用户删除<br>DROP USER &lt;用户名&gt;；</p></li></ul><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>SQL语句：<br>GRANT &lt;权限名&gt; ON &lt;对象名&gt; TO {数据库用户名|用户角色名}；REVOKE &lt;权限名&gt; ON &lt;对象名&gt; FROM {数据库用户名|用户角色名}；DENY &lt;权限名&gt; ON &lt;对象名&gt; TO {数据库用户名|用户角色名}；</p><ul><li><p>在3.7.1节的工程项目管理系统中，DBA管理员赋予员工用户（userA）对部门表（Department）、员工表（Employee）、项目表（Project）和任务表（Assignment）的读取数据权限。</p><p>GRANT SELECT ON Department TO “userA”;<br>GRANT SELECT ON Employee  TO “userA”;<br>GRANT SELECT ON Project   TO “userA”;<br>GRANT SELECT ON Assignment TO “userA”;</p></li></ul><h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h4><p>CREATE ROLE &lt;角色名&gt; [ [ WITH ] option [ … ] ];   –创建角色<br>ALTER ROLE &lt;角色名&gt; [ [ WITH ] option [ … ] ];   –修改角色属性<br>ALTER ROLE &lt;角色名&gt; RENAME TO &lt;新角色名&gt;;   –修改角色名称<br>ALTER ROLE &lt;角色名&gt; SET &lt;参数项&gt; { TO | &#x3D; } { value | DEFAULT };<br>  –修改角色参数值<br>ALTER ROLE &lt;角色名&gt; RESET &lt;参数项&gt;;  –复位角色参数值<br>DROP ROLE &lt;角色名&gt;;  –删除指定角色</p><ul><li><p>例 在工程项目管理系统中，假定需要在ProjectDB数据库内创建经理角色Role_Manager。该角色具有登录权限（Login）和角色继承权限（Inherit）系统权限，但它不是超级用户（SuperUser），不具有创建数据库权限（CreateDB）、创建角色权限（CreateRole）、数据库复制权限（Replication），此外数据库连接数（Connection Limit）不受限。</p><p>GRANT SELECT,INSERT,UPDATE,DELETE ON Department TO “Role_Manager”;<br>GRANT SELECT,INSERT,UPDATE,DELETE ON Employee TO “Role_Manager”;<br>GRANT SELECT,INSERT,UPDATE,DELETE ON Project TO “Role_Manager”;<br>GRANT SELECT,INSERT,UPDATE,DELETE ON Assignment TO “Role_Manager”;</p></li></ul><h3 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h3><p>数据库备份：是指将数据库当前数据和状态进行副本复制，以便当数据库受到破坏或丢失数据时可以进行修复</p><p>数据库恢复：是指数据库中数据丢失或被破坏时，从备份副本将数据库从错误状态恢复到某一正确状态</p><p>恢复时机</p><ul><li>事务故障的数据恢复</li><li>系统崩溃的数据恢复</li><li>存储介质损坏的数据恢复</li></ul>]]></content>
    
    
    <categories>
      
      <category>ji&#39;suan&#39;ji</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-总结</title>
    <link href="/2023/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1><h2 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h2><ul><li>操作系统是一组控制和管理计算机软硬件资源、合理对各类作业进行调度以及方便用户使用的程序集合。</li><li>操作系统是位于硬件层之上，所有其它系统软件层之下的一个系统软件，使得管理系统中的各种软件和硬件资源得以充分利用，方便用户使用计算机系统</li></ul><h3 id="操作系统的的目标"><a href="#操作系统的的目标" class="headerlink" title="操作系统的的目标"></a>操作系统的的目标</h3><p>方便性、有效性、可扩展性、开放性</p><p>OS的作用</p><ul><li>作为用户与计算机硬件系统之间的接口<ul><li>操作系统应隐藏复杂的、困难的、丑陋的、特殊的的硬件细节，呈现给程序良好、清晰、优雅、一致的抽象</li><li>操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象</li></ul></li><li>作为资源管理者的操作系统<ul><li>处理机管理，用于分配和控制处理机</li><li>存储器管理，主要负责内存的分配与回收</li><li>I&#x2F;O设备管理，负责I&#x2F;O设备的分配与操纵</li><li>文件管理，负责文件的存取，共享和保护</li></ul></li><li>作为扩展机器的操作系统</li></ul><h3 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h3><p>无操作系统</p><ul><li>人工操作方式：穿孔卡片</li><li>脱机输入输出方式</li></ul><p>单道批处理操作系统</p><ul><li>系统对作业的处理都是成批进行的，且在内存中始终仅存一道作业运行，运行结束或出错，才自动调另一道作业运行，故称为单道批处理系统</li><li>自动行、顺序性、单道性</li><li>减少人工操作，解决了作业的自动接续</li><li>平均周转时间长，没有交互能力</li></ul><p>多道批处理操作系统</p><ul><li>在内存中存放多道作业运行，运行结束或出错，自动调度内存中的另一道作业运行</li><li>提高cpu的利用率、提高内存和I&#x2F;O设备利用率、增加系统吞吐率</li><li>多道性、无序性、调度性</li><li>平均周转时间长、没有交互能力</li></ul><p>分时操作系统</p><ul><li>多路性、独立性、及时性、交互性</li></ul><p>实时操作系统</p><ul><li>是计算机及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致的运行</li><li>响应及时，可靠性高</li><li>多路性、独立性、交互性、可靠性、及时性</li></ul><h3 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h3><p>并发性（最重要的特征）、共享性、虚拟性、异步性</p><ul><li><p>并发-并行性和并发性，并发执行的过程。</p><p>进程：系统中能独立运行并作为资源分配的基本单位，由一组机器指令、数据和堆栈等组成的独立运行的活动实体</p><p>进程作为资源分配的基本单位</p><p>线程作为独立运行和调度的基本单位</p></li><li><p>共享</p><p>是指系统中的资源可供内存多个并发执行的进程共同使用<br>包括：互斥共享和同时访问两种方式</p></li><li><p>虚拟</p><p>是指通过某种技术把一个物理实体变为（映射为）若干个逻辑上的对应物<br>包括：时分复用技术，空分复用技术</p></li><li><p>异步</p><p>执行结果不确定，程序不再现</p></li></ul><h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><p>主要任务：为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程度地提高系统中各种资源的利用率和方便用户的使用</p><p>功能包括：处理机管理，文件管理，设备管理，存储器管理，方便用户使用的用户接口</p><h3 id="OS结构设计"><a href="#OS结构设计" class="headerlink" title="OS结构设计"></a>OS结构设计</h3><ul><li>无结构的OS</li><li>模块式结构OS</li><li>层次式结构OS</li><li>微内核结构OS<ul><li>足够小的内核</li><li>基于客户&#x2F;服务器模式</li><li>应用”机制与策略分离“原理</li><li>采用面向对象技术</li></ul></li></ul><h2 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h2><h3 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a>前趋图和程序执行</h3><p>前趋图：有向无循环图，用于描述进程之间执行的前后关系</p><p>相关名称：直接前趋，直接后继，初始结点，终止结点</p><p>程序顺序执行的的特征：</p><ul><li>顺序性：处理机的操作严格按照程序所规定的顺序执行</li><li>封闭性：程序运行时独占全机资源，程序一旦开始执行，其执行结果不受外界因素影响</li><li>可再现性：只要程序执行时的环境和初始条件相同，都将获得相同的结果</li></ul><p>程序并发执行的特征：</p><p>间断性，失去封闭性，不可再现性</p><h3 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h3><p>进程的定义：</p><ul><li>进程是程序的一次执行</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ul><p>进程的特征</p><ul><li><p>结构特征</p><p>进程实体：由程序段、相关的数据段和PCB（程序控制块）构成</p><p>创建进程：实质上是创建进程实体中的PCB<br>撤销进程：实质上是撤销进程的PCB</p></li><li><p>动态性</p><p>进程的实质是进程实体的一次执行过程</p><p>程序是一组有序指令的集合，其本身并不具有运动的含义，因而使静态的</p></li><li><p>并发性，独立性，异步性等</p></li></ul><h4 id="进程的基本状态机转换"><a href="#进程的基本状态机转换" class="headerlink" title="进程的基本状态机转换"></a>进程的基本状态机转换</h4><p>三种基本状态：就绪、阻塞，执行<br><img src="E:\typora-user-images\image-20220604193920752-16976793458911.png" alt="image-20220604193920752"></p><ul><li><p>就绪状态<br>进程分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行</p></li><li><p>执行状态</p><p>进程已获得CPU，其程序正在执行</p></li><li><p>阻塞状态</p><p>正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态</p></li></ul><p>五种状态及转换模型</p><p>五种状态：创建，就绪，执行，阻塞，终止</p><ul><li><p>创建状态</p><p>进程已经创建，但未被OS接纳为可执行进程，并且程序还在辅存</p></li><li><p>终止状态</p><p>因停止或取消，被OS从执行状态释放</p></li></ul><p><img src="E:\typora-user-images\image-20220604200057737-16976793458939.png" alt="image-20220604200057737"></p><p>进程挂起操作和进程状态的转换</p><p>挂起转态：使执行的进程暂停执行、静止下来。</p><p>引起挂起状态的原因：</p><ul><li>终端用户的请求</li><li>父进程请求</li><li>负荷调节的需要</li><li>操作系统的需要</li></ul><p>被挂起进程的特征</p><ul><li>不能立即执行</li><li>可能是等待某事件发生</li><li>使之挂起的进程为：自身，其父进程，OS</li><li>只有挂起它的进程才能使之由挂起状态转换为其他状态</li></ul><p>挂起与阻塞：</p><ul><li>就绪：进程在内存，准备执行</li><li>阻塞：进程在内存，等待事件</li><li>就绪&#x2F;挂起：进程在外存，只要调入内存即可执行</li><li>阻塞&#x2F;挂起：进程在外存，等待事件</li></ul><p><img src="E:\typora-user-images\image-20220604202831054-16976793458922.png" alt="image-20220604202831054"></p><h4 id="进程管理中的数据结构"><a href="#进程管理中的数据结构" class="headerlink" title="进程管理中的数据结构"></a>进程管理中的数据结构</h4><p>进程控制块的作用</p><ul><li>作为独立运行基本单位的标志</li><li>能实现间断性运行方式</li><li>提供进程管理所需要的信息</li><li>提供进程调度所需要的信息</li><li>实现与其他进程的同步与通信</li></ul><p>PCB常驻内存，是进程存在的唯一标志</p><p>进程控制块中的信息</p><ul><li>进程标识符</li><li>处理机状态</li><li>进程调度信息</li><li>进程控制信息</li></ul><p>PCB的组织方式</p><ul><li>线性方式</li><li>连接方式</li><li>索引方式</li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>功能：进程的创建，进程的撤销，进程的阻塞与唤醒等</p><p>处理机由核心态和用户态两种执行状态</p><p>OS内核包含两大功能</p><ul><li>支撑功能<ul><li>中断处理</li><li>时钟管理</li><li>原语操作<ul><li>原语是由若干条指令组成的，是用于完成一定功能的一个过程</li><li>原语是原子操作</li><li>原子操作在系统态下执行，常驻内存</li><li>原语的作用是为了实现进程的通信和控制</li></ul></li></ul></li><li>资源管理功能<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul><p>引起创建进程的事件</p><ul><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ul><p>调用进程创建原语<code>Create（）</code>，创建一个新进程</p><p>引起进程终止的事件<br>正常结束：批处理中用Holt指令，分时中用Logs off指令</p><p>引起进程阻塞的事件</p><ul><li>请求系统服务</li><li>启动某种操作</li><li>新数据尚为到达</li><li>无新工作可做</li></ul><p>进程通过调用<code>block</code>阻塞原语把自己阻塞</p><p>当被阻塞进程所期待事件出现时，则由有关进程调用唤醒原语<code>wakeup（）</code>，将等待该事件的进程唤醒。</p><p>进程的挂起<br>当出现了引起进程挂起的事件时，系统将利用挂起原语<code>suspend（）</code>将指定进程挂起</p><p>进程的激活<br>当发生激活进程的事件时，则可将外存上处于静止就绪状态的进程换入内存，系统利用激活原语active（）将指定进程激活</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>主要任务：是使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性</p><p>临界资源：一次今允许一个进程访问的资源为临界资源</p><ul><li>生成者-消费者问题</li></ul><p><img src="E:\typora-user-images\image-20220604210820554-16976793458923.png" alt="image-20220604210820554"></p><p><img src="E:\typora-user-images\image-20220604210914411-16976793458924.png" alt="image-20220604210914411"></p><p>同步机制用遵循的规则</p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><p>解决临界区（互斥）问题的几类方法</p><p>硬件同步机制</p><p>信号量机制</p><ul><li><p>整型信号量</p><p><img src="E:\typora-user-images\image-20220604214040108-16976793458935.png" alt="image-20220604214040108"></p><p><img src="E:\typora-user-images\image-20220604214133166-16976793458936.png" alt="image-20220604214133166"></p></li><li><p>记录型信号量</p><p><img src="E:\typora-user-images\image-20220604214220502-16976793458937.png" alt="image-20220604214220502"></p><p><img src="E:\typora-user-images\image-20220604214316871-16976793458938.png" alt="image-20220604214316871"></p><p><img src="E:\typora-user-images\image-20220604214336553-169767934589310.png" alt="image-20220604214336553"></p></li><li><p>AND型信号量</p><p><img src="E:\typora-user-images\image-20220604214604141-169767934589311.png" alt="image-20220604214604141"></p><p><img src="E:\typora-user-images\image-20220604214750628-169767934589312.png" alt="image-20220604214750628"></p><p><img src="E:\typora-user-images\image-20220604214759220-169767934589313.png" alt="image-20220604214759220"></p></li><li><p>信号量集</p><p><img src="E:\typora-user-images\image-20220604215059656-169767934589314.png" alt="image-20220604215059656"></p><p><img src="E:\typora-user-images\image-20220604215113034-169767934589415.png" alt="image-20220604215113034"></p><p><img src="E:\typora-user-images\image-20220604215124505-169767934589416.png" alt="image-20220604215124505"></p></li></ul><p>管程机制</p><p>当共享资源用共享数据结构表示时，资源管理程序可用对该数据结构进行操作的一组过程来表示，我们把这样一组相关的数据结构和过程一并称为管程</p><p>管程由四部分组成：</p><ul><li>管程的名字</li><li>局部于管程的共享变量说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的数据设置初始值的语句</li></ul><h3 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>生产者和消费者进程共享一个大小固定的缓冲区，其中，一个或多个生产者生产数据，并将生产的数据存入缓冲区，并有一个消费者从缓冲区中取数据。</p><p><img src="E:\typora-user-images\image-20220605130326424-169767934589417.png" alt="image-20220605130326424"></p><ul><li><p>记录型信号量</p><p><img src="E:\typora-user-images\image-20220605130439953-169767934589418.png" alt="image-20220605130439953"></p><p><img src="E:\typora-user-images\image-20220605130513646-169767934589419.png" alt="image-20220605130513646"></p></li><li><p>AND信号量</p><p><img src="E:\typora-user-images\image-20220605130621721-169767934589420.png" alt="image-20220605130621721"></p><p><img src="E:\typora-user-images\image-20220605130642919-169767934589421.png" alt="image-20220605130642919"></p></li></ul><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>5个哲学家围绕一张圆桌而坐，每个哲学家前面有一碟空心面，由于面很滑，所以要两把叉子才能夹住。相邻两个碟子之间有一把叉子。<br>哲学家只有两种活动，在感觉到饿时，分两次取左边和右边的叉子（不分次序），如果成功的得到两把叉子，就吃饭，吃完后继续思考。</p><ul><li><p>记录型信号量</p><p><img src="E:\typora-user-images\image-20220605130929794-169767934589422.png" alt="image-20220605130929794"></p></li><li><p>AND信号量</p><p><img src="E:\typora-user-images\image-20220605131003389-169767934589423.png" alt="image-20220605131003389"></p></li></ul><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>所谓读者－写者问题，是指保证一个write进程必须与其它进程互斥地访问共享对象的同步问题。</p><p>semaphore rmutex&#x3D;1, wmutex &#x3D; 1;<br>int readcount &#x3D; 0;</p><ul><li><p>记录型信号量</p><p><img src="E:\typora-user-images\image-20220605131236331-169767934589424.png" alt="image-20220605131236331"></p></li><li><p>信号量集</p><p><img src="E:\typora-user-images\image-20220605131332304-169767934589425.png" alt="image-20220605131332304"></p></li></ul><h4 id="理发师-顾客问题"><a href="#理发师-顾客问题" class="headerlink" title="理发师-顾客问题"></a>理发师-顾客问题</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs routeros">semaphore <span class="hljs-attribute">customers</span>=0；／*等候的顾客数*／<br>semaphore <span class="hljs-attribute">barbers</span>=0， ／*等候顾客的理发师数*／<br>semaphore <span class="hljs-attribute">mutex</span>=1；<br>int <span class="hljs-attribute">count</span>=0；<br>／*等候的顾客数（还没理发）*／<br>main（）<br>&#123;<br>cobegin<br>barbers（）；<br>customers（）；<br>coend<br>&#125;<br>barber（）<br>&#123;<br><span class="hljs-keyword">while</span>（<span class="hljs-literal">true</span>）<br>&#123;<br>p（customers）；／*是否有等候的顾客*／<br>p（mutex）；<br><span class="hljs-attribute">count</span>=count-1；／*顾客数减1*／<br>v（barbers）； ／*理发师开始理发*／<br>v（mutex）；<br>理发；<br>&#125;<br>&#125;<br>customer（）<br>&#123;<br>p（mutex）；<br><span class="hljs-keyword">if</span>（count&lt;n）<br>&#123;<br><span class="hljs-attribute">count</span>=count+1；／*若有空椅子则等候的顾客数加1*／<br>v（customers）；<br>v（mutex）；<br>p（barbers）；<br>理发；<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>v（mutex）；／*无空椅子则离开*／<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>分为两类</p><ul><li><p>低级通信：信号量机制</p><p>缺点：</p><ul><li>效率低</li><li>通信对用户不透明</li></ul></li><li><p>高级通信：共享内存、管道、消息队列、套接字Socket</p><p>直接利用操作系统所提供的一组通信命令，高效地传送大量数据的一种通信方式</p><p>优点：</p><ul><li>效率高</li><li>通信实现细节对用户透明</li></ul></li></ul><h4 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h4><ul><li><p>共享存储器系统</p><ul><li>基于共享数据结构的通信方式</li><li>基于共享存储区的通信方式</li></ul></li><li><p>消息传递系统</p><ul><li><p>直接通信方式</p><p>Send （Receiver， message）；<br>Receive（Sender， message）；</p></li><li><p>间接通信方式</p><p>指进程之间利用信箱的通信方式。</p><p>Send (mailbox, message)<br>Receive (mailbox, message)</p></li></ul></li><li><p>管道通信</p><p>管道：连接一个读进程和一个写进程之间通信的共享文件</p></li></ul><h2 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h2><p>调度的目的：处理机调度的工作是对CPU资源进行合理的分配使用，以提高处理机利用率，并使各用户公平地得到处理机资源</p><p>需考虑的因素：公平，周转时间，高效，吞吐量，响应时间</p><h3 id="处理机调度的三种层次与目标"><a href="#处理机调度的三种层次与目标" class="headerlink" title="处理机调度的三种层次与目标"></a>处理机调度的三种层次与目标</h3><ul><li><p>高级调度（作业调度，长程调度）</p><p><img src="E:\typora-user-images\image-20220605134927089-169767934589426.png" alt="image-20220605134927089"></p></li><li><p>低级调度（进程调度，短程调度）</p><p><img src="E:\typora-user-images\image-20220605134952788-169767934589427.png" alt="image-20220605134952788"></p><p><img src="E:\typora-user-images\image-20220605135034052-169767934589428.png" alt="image-20220605135034052"></p></li><li><p>中级调度（交换调度，中程调度）</p><p><img src="E:\typora-user-images\image-20220605135054789-169767934589429.png" alt="image-20220605135054789"></p></li></ul><p>资源利用率：CPU利用率&#x3D;CPU的有效工作时间&#x2F;（CPU有效工作时间+CPU空闲等待时间）</p><p>公平性，平衡性</p><p>平均周转时间<br><img src="E:\typora-user-images\image-20220605135430779-169767934589430.png" alt="image-20220605135430779"></p><p>带权周转时间：作业的周转时间T与系统为他提供服务的时间Ts之比。W&#x3D;T&#x2F;Ts</p><p>平均带权周转时间：<br><img src="E:\typora-user-images\image-20220605135547052-169767934589432.png" alt="image-20220605135547052"></p><p>吞吐量：指在单位时间内系统所完成的作业数，因而它与批处理作业的平均作业的平均长度具有密切关系</p><h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><p>作业：用户提交给系统的一项相对独立的工作。程序+数据+作业说明书</p><p><img src="E:\typora-user-images\image-20220605135947482-169767934589431.png" alt="image-20220605135947482"></p><p>作业调度的主要任务：根据JCB信息，检查系统中的资源能否满足作业对资源的需求，按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为他们创建进程、分配必要资源，安排在就绪队列</p><h4 id="先来先服务-FCFS-算法"><a href="#先来先服务-FCFS-算法" class="headerlink" title="先来先服务(FCFS)算法"></a>先来先服务(FCFS)算法</h4><p>按照作业提交或进程变为就绪状态的先后次序，分派CPU；当前作业或进程占用CPU，直到执行完或阻塞，才主动地出让CPU。<br>FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。<br>FCFS调度算法有利于CPU繁忙型的作业，而不利于I&#x2F;O繁忙型的作业<br><img src="E:\typora-user-images\image-20220605142358345-169767934589433.png" alt="image-20220605142358345"></p><h4 id="短作业-x2F-进程优先调度-SJF-x2F-SPF-算法"><a href="#短作业-x2F-进程优先调度-SJF-x2F-SPF-算法" class="headerlink" title="短作业&#x2F;进程优先调度(SJF&#x2F;SPF)算法"></a>短作业&#x2F;进程优先调度(SJF&#x2F;SPF)算法</h4><p>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。z</p><p><img src="E:\typora-user-images\image-20220605142809766-169767934589434.png" alt="image-20220605142809766"></p><h4 id="优先级调度算法-PSA-算法"><a href="#优先级调度算法-PSA-算法" class="headerlink" title="优先级调度算法(PSA)算法"></a>优先级调度算法(PSA)算法</h4><p>外部赋予作业（进程）相应的优先级，例如以作业的紧迫程度作为优先级。<br>选择优先级高的进程投入运行。<br>即可用于作业调度算法，也可用于进程调度。</p><h4 id="高响应比优先-HRRN-调度算法"><a href="#高响应比优先-HRRN-调度算法" class="headerlink" title="高响应比优先(HRRN)调度算法"></a>高响应比优先(HRRN)调度算法</h4><p>HRRN是介于FCFS和SJF之间的折衷算法，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改进了调度性能。</p><p>赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加。</p><p><img src="E:\typora-user-images\image-20220605143255269-169767934589537.png" alt="image-20220605143255269"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>任务：</p><ul><li>保存处理机现场</li><li>按照某种算法选取进程</li><li>把处理机分配给进程</li></ul><h4 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h4><p>原理：FCFS策略+时钟中断+时间片原则</p><p>进程切换时机：<br>时间片内进程结束，进程结束事件激活进程调度，新进程可运行一个时间片；<br>时间片用完，时钟中断激活调度，旧进程到就绪队列尾，队头进程投入运行一个时间片</p><p><img src="E:\typora-user-images\image-20220605143740757-169767934589535.png" alt="image-20220605143740757"></p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><ul><li>非抢占式优先级调度算法</li><li>抢占式优先级调度算法</li></ul><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p>基本思想：多级反馈队列调度算法是时间片轮转算法和优先级调度算法的综合和发展，通过动态调整进程优先级和时间片大小，不必事先估计进程的执行时间，多级反馈队列可兼顾多方面的系统目标，是目前公认的一种较好的进程调度算法。</p><p>实施过程：</p><ul><li>设置多个优先级队列，并为各个队列赋予不同的优先级。第一个最高，以后一次降低</li><li>每个队列中进程执行时间片的大小也各不相同，进程所在队列的优先级越高，其相应的时间片就越短。</li><li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……。</li><li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行。</li></ul><p><img src="E:\typora-user-images\image-20220605145257711-169767934589536.png" alt="image-20220605145257711"></p><h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><p>实时任务是指具有及时性要求的、经常被重复执行的特定进程。</p><p>实现实时调度的基本条件</p><ul><li>提供必要的信息</li><li>系统处理能力强</li><li>采用抢占式调度机制</li><li>具有快速切换机制</li></ul><h4 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="非抢占式调度算法"></a>非抢占式调度算法</h4><p>非抢占式轮转调度算法: 调度程序每次选择队列中的第一个任务投入运行。当该任务完成后，便把它挂在轮转队列的末尾，等待下次调度运行。</p><p>非抢占式优先调度算法: 如果在系统中存在着实时要求较为严格的任务，则可采用非抢占式优先调度算法，为这些任务赋予较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，才能被调度执行。</p><h4 id="抢占式调度算法"><a href="#抢占式调度算法" class="headerlink" title="抢占式调度算法"></a>抢占式调度算法</h4><ul><li><p>基于时钟中断的抢占式优先权调度算法</p><p>某实时任务到达后，如果该任务的优先级高于当前任务的优先级，这<br>时并不立即抢占当前任务的处理机，而是等到时钟中断到来时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先权任务。</p></li><li><p>立即抢占的优先权调度算法</p><p>一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。</p></li></ul><h4 id="最早截止时间优先算法-EDF"><a href="#最早截止时间优先算法-EDF" class="headerlink" title="最早截止时间优先算法(EDF)"></a>最早截止时间优先算法(EDF)</h4><p>该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面。调度程序总是选择就绪队列中的第一个任务，未知分配处理机，使之投入运行。<br><img src="E:\typora-user-images\image-20220605150339387-169767934589538.png" alt="image-20220605150339387"></p><h4 id="最低松弛度优先算法-LLF"><a href="#最低松弛度优先算法-LLF" class="headerlink" title="最低松弛度优先算法(LLF)"></a>最低松弛度优先算法(LLF)</h4><p>松弛度&#x3D;完成截止时间-剩余运行时间-当前时间<br>该算法按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行。（当等待任务的松弛度值为0时才进行抢占）</p><p><img src="E:\typora-user-images\image-20220605150939558-169767934589540.png" alt="image-20220605150939558"></p><p><img src="E:\typora-user-images\image-20220605150953092-169767934589539.png" alt="image-20220605150953092"></p><p>当等待任务的松弛度值为0时才进行抢占（如20ms时虽然A2的松弛度比B1的松弛度小，但A2并没有抢占B1）。</p><ul><li><p>当有任务执行时，只有等待任务的松弛度值为0才会<br>发生任务的调度，其他情况不发生调度。</p></li><li><p>任务执行结束后或无任务执行时，再比较等待任务的<br>松弛度值，较小的先执行。</p></li></ul><h3 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h3><p>死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局<br>死锁的进程都不能运行、释放资源、被唤醒</p><p>产生死锁的原因：</p><ul><li>竞争资源<ul><li>可重用资源的竞争</li><li>可消耗资源的竞争</li></ul></li><li>进程间推进顺序非法</li></ul><p>如果一组进程中的每一个进程都在等待仅有该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</p><p>死锁发生的四个必要条件</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ul><p>解决死锁的方法</p><ul><li>预防死锁</li><li>避免死锁</li><li>检测死锁</li><li>解除死锁</li></ul><p>系统安全状态</p><ul><li><p>所谓安全状态，是指系统能按某种进程顺序，如&lt;P1，P2，…，Pn&gt;，依次为n个进程分配其所需资源，直至其最大需求，使每个进程都可顺利地完成，称系统处于安全状态。</p></li><li><p>称〈P1，P2，…，Pn〉序列为安全序列。否则，如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p></li></ul><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。</p><p>n个进程（P1，P2，…，Pn）<br> m类资源（R1，R2，…，Rm）<br> 可利用资源向量：available[j]&#x3D;k, 资源Rj类有k个可用<br> 最大需求矩阵：Max[i,j]&#x3D;k,进程Pi最大请求k个Rj类资源<br> 分配矩阵：Allocation[i,j]&#x3D;k,进程Pi分配到k个Rj类资源<br> 需求矩阵：Need[i,j]&#x3D;k,进程Pi还需要k个Rj类资源<br>三个矩阵的关系：<br>Need [i, j] &#x3D; Max[i, j] – Allocation [i, j].</p><p>算法步骤</p><ul><li>如果Requesti[j]≤Need[i,j],便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所声明的最大值。</li><li>如果Requesti[j]≤Available[j]，便转向步（3），否则，表示尚无足够资源，Pi须阻塞等待。</li><li>系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：<br>Available[ j ] &#x3D; Available[ j ] - Requesti[ j ]；<br>Allocation[ i,j ] &#x3D; Allocation[ i,j ] + Requesti[ j ];<br>Need[ i, j ] &#x3D; Need[ i, j ] - Requesti[ j ]；(假分配)</li><li>系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。</li></ul><p>安全性算法</p><ul><li>设置两个向量：<br>①工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，Work &#x3D; Available<br>②Finish：开始时先做Finish[i] &#x3D; false；当有足够资源分配给进程时，再令Finish[i] &#x3D; true</li><li>从进程集合中找到一个能满足下述条件的进程：<br>①Finish[i] &#x3D; false；<br>②Need[i,j] ≤ work[j]；<br>若找到，执行步骤（3)；否则，执行步骤（4）。</li><li>当进程只获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br>Work[ j ] &#x3D; Work[ i ] + Allocation[ i,j ]；<br>Finish[ i ] &#x3D; true;<br>go to step 2；</li><li>如果所有进程的Finish[i] ＝ true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</li></ul><p><img src="E:\typora-user-images\image-20220605161924472-169767934589541.png" alt="image-20220605161924472"></p><h2 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p>三级存储器：</p><ul><li>CPU寄存器：寄存器<br>寄存器访问速度最快，与CPU协调工作</li><li>主存：高速缓存Cache、主存、磁盘缓存<br>用于保存进程运行时的程序和数据。CPU的控制部件只能从主存中取得指令和数据到CPU寄存器，同样，CPU寄存器中的数据可存入主存。</li><li>辅存：磁盘、可移动存储介质</li></ul><p>存储器管理的目的和功能</p><ul><li>主存储器的分配和管理：按用户要求把适当的存储空间分配给相应的作业。<br>一个有效的存储分配机制的功能：<ul><li>记住每个存储区域的状态</li><li>实施分配</li><li>接收系统或用户释放的存储区域</li></ul></li><li>提高主存储器的利用率</li><li>”扩充“主存容量</li><li>存储保护</li></ul><p>存储分配的三种方式</p><ul><li>直接指定方式</li><li>静态分配方式</li><li>动态分配方式</li></ul><p>基本概念</p><ul><li>逻辑地址(相对地址，虚地址)<br>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余指令中的地址都相对于首地址而编址</li><li>物理地址(绝对地址，实地址)<br>内存中存储单元的地址，可直接寻址</li><li>名空间<br>一个用高级语言编制的源程序，我们说它存在于由程序员建立的符号名字空间</li><li>地址空间<br>程序用来访问信息所用地址单元的集合，是逻辑(相对)地址的集合，由编译程序生成</li><li>存储空间<br>主存中物理单元的集合。这些单元的编号称物理地址或绝对地址。存储空间的大小是由主存的实际容量决定的</li></ul><p><img src="E:\typora-user-images\image-20220605170126277-169767934589542.png" alt="image-20220605170126277"></p><p>地址空间是逻辑地址的集合；存储空间是物理地址的集合。一个是“虚”的概念，一个是“实”的物体。<br> 一个编译好的目标程序存在于它自己的地址空间中，当要它在计算机上运行时，才把它装入存储空间。<br> 一个作业在编译、装入前后存在于不同的空间</p><h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3><p>再多道程序环境下，程序要运行必须为之创建进程，而创建进程需要把用户编写的源程序和数据装入内存。</p><p>步骤：编译、链接、装入<br><img src="E:\typora-user-images\image-20220605175116624-169767934589543.png" alt="image-20220605175116624"></p><p>装入方式：</p><ul><li><p>绝对装入方式<br>在编译时，如果知道程序将驻留在内存的具体位置，那么编译程序将产生实际存储地址（绝对地址）的目标代码。</p></li><li><p>可重定位装入方式</p><ul><li><p>重定位</p><p>经编译得到的目标模块中为相对地址（通常从0开始），即地址都是相对于0开始的。<br> 装入模块中的逻辑地址与实际装入内存的物理地址不同。<br>装入内存时，相对地址（数据、指令地址）要作出相应的修改以得到正确的物理地址，这个修改的过程称为重定位。</p></li><li><p>静态重定位<br>地址变换是在装入内存时一次完成的，且以后不能移动。<br> 一般情况下,物理地址&#x3D;相对地址+内存中的起始地址</p></li><li><p>动态重定位<br>装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时进行。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为动态重定位</p><ul><li>最简单的办法是利用一个重定位寄存器(RR)。该寄存器的值是由进程调度程序根据作业分配到的存储空间起始地址来设定的。</li><li>在具有这种地址变换机构的计算机系统中，当执行作业时，不是根据CPU给出的有效地址去访问主存，而是将有效地址与重定位寄存器中的内容相加后得到的地址作为访问主存的地址。</li></ul></li></ul></li></ul><p>程序的链接</p><ul><li>静态链接<br>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。</li><li>装入时动态链接<br>用户源程序经编译后所得到的目标模块，是在装入内存时，边装入边链接的。即在装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将其装入内存。</li><li>运行时动态链接<br>采用运行时动态链接可将某些目标模块的链接推迟到执行时才进行，即在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并链接到调用模块上。</li></ul><h3 id="连续的分配方式"><a href="#连续的分配方式" class="headerlink" title="连续的分配方式"></a>连续的分配方式</h3><p>连续分配指为用户程序分配一个连续的内存空间</p><p>分配方式：</p><ul><li><p>单一连续分配方式<br>内存中仅驻留一道用户程序，整个用户区为一个用户独占。<br>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。</p></li><li><p>分区式分配方式<br>将内存用户空间划分为若干个固定大小的区域，每个区域称为一个分区（region），在每个分区中只装入一道作业 ，从而支持多道程序并发设计。（分区是在系统启动时划定的，其大小和边界不能改变）</p><p>为了实现这种固定分区的分配，系统需要建立一张分区说明表。这个分区说明表指出可用于分配的分区数以及每个区的大小、起始地址及状态。</p><p>分配过程：当有作业要装入内存时，内存分配程序检索分区说明表，从中找出一个尚未使用的满足大小要求的分区分配给该作业，然后修改分区的状态；如果找不到合适的分区就拒绝为该作业分配内存。</p><ul><li><p>固定分区</p><ul><li>分区大小相等</li><li>分区大小不等</li></ul></li><li><p>动态可变分区<br>分区的数目固定大小可变&#x2F;分区的数目和大小都是可变的</p></li></ul></li><li><p>可重定位分区分配</p></li></ul><p>分区分配中数据结构：空闲分区表和空闲分区链</p><p>内零头(Internal Fragment ):<br>▪分配给用户但用户没有使用的空间<br>▪ “多分配的空间”<br>外零头(External Fragment )：<br>▪ 没有分配但无法分配的空间<br>▪ 太小而无法分配，“分不出去的空间”</p><p>分区分配算法:</p><h4 id="基于顺序搜索："><a href="#基于顺序搜索：" class="headerlink" title="基于顺序搜索："></a>基于顺序搜索：</h4><ul><li><p>最佳适应算法(BF)<br>就是为一作业选择分区时总是寻找其大小最接近作业所要求的存储区域。即：把作业放<br>入这样的分区后剩下的零头最小。</p><p>如果不存在这样的空白区，也只对比要求稍大的空白区进行划分，而绝不会去划分一个更大的空白区。</p><p>为了加快查找速度，应将存储空间中所有的空白区按其大小递增的顺序链接起来，组成一空白区链(Free List)。</p></li><li><p>最坏适应算法(WF)<br>与最佳适应算法相反，它在为作业选择存储区域时，总是寻找最大的空白区。</p><p>为了支持这个算法的实现，空白块应以大小递减的顺序链接起来。</p></li><li><p>首次适应算法(FF)<br>每个空白区按其在存储空间中<strong>地址递增</strong>的顺序链在一起，即每个后继空白区的起始地址总是比前者的大。在为作业分配存储区域时，从这个空白区链的始端开始查找，选择第一个足以满足请求的空白块，而不管它究竟有多大。</p></li><li><p>循环首次(下次)适应算法(NF)<br>把存储空间中空白区构成一个循环链。每次为存储请求查找合适的分区时，总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将它划分后分配出去。</p></li></ul><h4 id="基于索引搜索："><a href="#基于索引搜索：" class="headerlink" title="基于索引搜索："></a>基于索引搜索：</h4><ul><li><p>快速适应算法(QF)<br>将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。</p><p>同时，在内存中设立一张管理分区类型，并记录了该类型空闲分区链表表头的索引表，该表的每一个表项记录了对应类型空闲分区链表表头的指针。</p><p>分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可</p></li><li><p>伙伴系统<br>在伙伴系统中可用内存块的大小为2^R(1≤R≤m)</p><p>2^1表示分配的最小块的尺寸；<br>2^m表示分配的最大块的尺寸，通常是可供分配的整个内存<br>空间的大小。<br>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成 k（0 ≤k≤m ）个链表。</p><ul><li><p>进程请求大小为n的存储空间时，<br>首先计算一个 i 值，使 2i－1 &lt; n ≤ 2i；<br>在空闲分区大小为 2i 的空闲分区链表中查找。<br>if 找到，即把该空闲分区分配给进程。<br>else 在分区大小为2i＋1的空闲分区链表中寻找;<br>    &#x2F;&#x2F;表明长度为2i的空闲分区已经耗尽<br>if 找到大小为2i＋1 的空闲分区<br>把该空闲分区分为相等的两个分区（一对伙伴），其中一个用于分配，另一个加入分区大小为 2i 的空闲分区链表中。<br>else 查找大小为2i＋2 的空闲分区……</p><p><img src="E:\typora-user-images\image-20220605224821133-169767934589544.png" alt="image-20220605224821133"></p></li></ul></li></ul><p>分区分配操作</p><ul><li><p>分配内存<br>向操作系统提出一特定存储量的请求。通常，它并不要求这个分配的存储区域限于特定的位置，但是，这个区域必须是连续的。<br>系统利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。<br>•请求的分区大小为u.size<br>•表中每个空闲分区的大小为m.size<br>•size是事先规定的不再切割的剩余分区的大小<br><img src="E:\typora-user-images\image-20220605205011466-169767934589545.png" alt="image-20220605205011466"></p></li><li><p>回收内存<br>进程用于归还一个不再需用的存储区域。<br>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点。</p></li><li><p>回收区于插入点的前一个空闲分区F1相邻接<br>此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区F1的大小。<br><img src="E:\typora-user-images\image-20220605205238838-169767934589546.png" alt="image-20220605205238838"></p></li><li><p>回收区仅与下面的空白区邻接，合并后仍为空白分区F2，但其起始地址和大小需改变<br>用回收区的首址作为新空闲区的首址，大小为两者之和<br><img src="E:\typora-user-images\image-20220605205429687-169767934589547.png" alt="image-20220605205429687"></p></li><li><p>回收区与上、下面的空白区邻接<br>此时将三个分区合并，使用F1的表项和F1的首址，取消F2的表项，大小为三者之和。<br><img src="E:\typora-user-images\image-20220605205609675-169767934589548.png" alt="image-20220605205609675"></p></li><li><p>回收区与上、下面的空白区均不邻接，<br>在这种情况下，应为回收区单独建立一新表项，填写回收区的首址和大小，并根据首地址插入到空闲链中的适当位置。</p></li></ul><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一<br>张哈希表，以空闲分区大小为关键字，每一个表项记录了一个对应的空闲分区链表表头指针。</p><p>当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p><h4 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h4><p>可变式分区分配策略是在装入作业时根据其要求量为其划定相应的区域。这种分配策略，消除了固定式分区分配造成的“内零头”，但不可避免地在存储空间中造成“外零头”，为了进一步提高存储器的利用率，必须设法减少由于外零头造成的浪费。</p><p>实现方法将内存中的所有作业进行移动，使它们全都相邻接，这样，可把原来分散的多个小分区合成一个大分区。这种技术称为存储器的“紧凑”。</p><ul><li><p>动态重定位</p><p>在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。<br>程序在执行时，真正访问的内存地址是相对地址与重定位<br>寄存器中的地址相加而形成的。<br><img src="E:\typora-user-images\image-20220605225559680-169767934589549.png" alt="image-20220605225559680"></p><p><img src="E:\typora-user-images\image-20220605225629393-169767934589550.png" alt="image-20220605225629393"></p></li></ul><h3 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h3><p>离散分配方式——允许将作业&#x2F;进程离散放到多个不相邻接的分区中，从而避免拼接</p><p>空间划分：</p><ul><li><p>页：</p><p>将一个用户进程的地址空间（逻辑）划分成若干个大小相等的区域，称为页或页面(Page),并为各页从0开始编号</p></li><li><p>块：</p><p>内存空间也分成若干个与页大小相等的区域，称为（存储、物理）块或页框（Frame），同样从0开始编号。<br><img src="E:\typora-user-images\image-20220605230113193-169767934589551.png" alt="image-20220605230113193"></p></li></ul><p><strong>数据结构：</strong></p><ul><li><p>页表(一般存放在内存中)</p><p>每个进程对应1个页表，描述该进程的各页面在内存中对应的物理块号</p><ul><li>页表中包括页号，物理块号（还可有存取控制字段，对存储块中的内容进行保护）</li><li>注意：全部页表集中存放在主存的系统专用区中，只有系统有权访问页表，保证安全</li></ul><p>作用：实现从页号到物理块号的地址映射</p></li><li><p>作业表</p><p>整个系统1张，记录作业的页表情况，保护进程号，页表长度，页表始址</p></li><li><p>空闲块表</p><p>整个系统1张，记录主存当前空闲块</p></li></ul><p><strong>地址结构：</strong></p><p>在分页存储管理方式中，任何一个逻辑地址都可转变为：页号+页内位移量。</p><p>页号：P&#x3D;INT[A&#x2F;L]<br>页内位移量：W&#x3D;A MOD L<br>例：如有逻辑地址为：2170，页面大小为1KB，则P&#x3D;INT[2170&#x2F;1024]&#x3D;2；W&#x3D;2170 MOD 1024&#x3D;122</p><p><strong>地址变换机构</strong></p><p>功能：将用户的逻辑地址转变为内存中的物理地址<br>页的大小和内存物理块的大小是相同的，所以页内位移量即为物理块内位移量。</p><p>变换过程：</p><ul><li>根据逻辑地址,计算出页号和页内偏移量；</li><li>从PTR(页表寄存器)中得到页表首址，然后检索页表，查找<br>指定页面对应的页框号；</li><li>用页框号乘以页面大小获得其对应的起始地址，<br>并将其送入物理地址的高端。</li><li>将页内偏移量送入物理地址低端，形成完整的<br>物理地址。</li></ul><p><strong>具有快表的地址变换机构</strong></p><p>快表：一个专用的高速缓冲存储器，专门保存当前进程最近访问过的一组页表项</p><ul><li>根据逻辑地址中的页号，查找快表中是否存在对应的页表项。</li><li>若快表中存在该表项，称为命中（hit），取出其中的页框号，加上页内偏移量，计算出物理地<br>址。</li><li>若快表中不存在该页表项，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中。并计算物理地址.</li></ul><p>访问内存的有效时间 EAT：从进程发出指定逻辑地址的访问请求，经过地址变换，再到内存中找到对应的物理单元并取出数据，所花费的总时间</p><p><strong>两级和多级页表</strong></p><p>二级页表：将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入</p><p>可将页表进行分页，并离散地将各个页面分别存放在不同的物理块中，<br>同样也要为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table)，在每个页表项中记录了页表分页的物理块号。</p><p><img src="E:\typora-user-images\image-20220606220430490-169767934589552.png" alt="image-20220606220430490"></p><p><img src="E:\typora-user-images\image-20220606220559885-169767934589553.png" alt="image-20220606220559885"></p><p><strong>反置页表</strong></p><p>（1）IPT是为主存中的每一个物理块建立一个页表项并按照块号排序；<br>（2）该表每个表项包含正在访问该物理块的进程标识、页号及特征位,用来完成主存物理块到访问进程的页号的转换</p><p><strong>对换</strong></p><p>指把内存中暂不能运行的进程或暂时不用和程序和数据，换到外存上，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的程序和数据，换入内存</p><ul><li><p>整体对换（进程对换）</p><p>对换以整个进程为单位，用于分时系统，以解决内存紧张的问题；</p></li><li><p>页面对换&#x2F;分段对换</p><p>对换以“页”或“段”为单位进行“部分对换”，该方法是实现请求分页及请求分段存储器的基础，支持虚存系统。</p></li></ul><p>外存被分为两部分：文件区（存放文件）和对换区（存放从内存换出的进程）</p><p>数据结构：</p><ul><li>空闲分区表或空闲分区链。在空闲分区表中的每个表目应包含两项，即对换分区首址和对换<br>区长度，它们的基本单位都是盘块。</li></ul><p>换出（swap out）</p><ul><li>选择：首先选择阻塞或睡眠状态的进程，若有多个，按优先级由低到高进行选择。若没有此状态进程，则选择就绪状态的，仍然按优先级由低到高进行选择。为避免某进程被频繁的换入换出，还应考虑进程在内存中的驻留时间，优先选择驻留时间长的进程。对换（续）</li></ul><p>换入（swap in）</p><ul><li>①从 PCB集合中查找“就绪且换出”的进程，有多个，则选择换出时间最长的。<br>根据进程大小申请内存，成功则读入，否则要先执行换出，再换入。<br>若还有可换入进程，则转向①。直至无“就绪且换出”进程或无法获得足够内存空间为止。</li></ul><h3 id="分段式存储管理"><a href="#分段式存储管理" class="headerlink" title="分段式存储管理"></a>分段式存储管理</h3><h4 id="分段式存储管理方式的引入"><a href="#分段式存储管理方式的引入" class="headerlink" title="分段式存储管理方式的引入"></a>分段式存储管理方式的引入</h4><p>优势：方便编程、分段共享、分段保护、动态链接、动态增长</p><p><strong>分段</strong></p><ul><li>作业地址空间按逻辑信息的完整性被划分为若干个段；</li><li>每段有段名（或段号），每段从0开始编址；</li><li>段内的地址空间是连续的</li><li>许多编译程序支持分段方式，自动根据源程序的情况<br>产生若干个段。</li></ul><p><img src="E:\typora-user-images\image-20220606222517343-169767934589554.png" alt="image-20220606222517343"></p><p>分段管理，就是管理由若干分段组成的作业，且按分段来进行存储分配。</p><p>段表：</p><ul><li>为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区中。</li><li>应像分页系统那样，在系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址(又称为“基址”)和段的长度</li><li>通常将段表放在内存中，执行中的进程可通过查找段表找到每个段所对应的内存区。</li></ul><p>地址表换机构：</p><p><img src="E:\typora-user-images\image-20220607170757252-169767934589555.png" alt="image-20220607170757252"></p><p><strong>信息共享</strong></p><p><img src="E:\typora-user-images\image-20220607170937568-169767934589556.png" alt="image-20220607170937568"></p><h4 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h4><p>先将用户程序分段，每段内再划分成若干页，每段有段名（段号），每段内部的页有一连续的页号。</p><p>逻辑地址：由于段页式系统给作业地址空间增加了另一级结构，现在地址空间是由段号S、段内页号P 和页内相对地址(位移量)W构成。</p><p>地址变换：</p><ul><li>首先，从段表寄存器从获得进程段表的起始地址，根据该地址，查找进程的段表。</li><li>然后，根据逻辑地址指定的段号检索段表，找到对应段的页表起始地址。</li><li>再根据逻辑地址中指定的页号检索该页表，找到对应页所在的物理块号。</li><li>最后，用物理块号加上逻辑地址中指定的页内偏移量，形成物理地址</li></ul><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>内存的扩充方法：</p><ul><li>物理扩充：<br>增加硬件投入，受机器自身和成本的限制。</li><li>逻辑扩充<ul><li>覆盖（overlay）<br>应用程序手动把需要的指令和数据保存在内存中</li><li>对换（swapping）<br>操作系统自动把暂时不能执行的程序保存到外存中</li><li>虚拟存储<br>在有限容量的内存中，自动装入更多更大的程序</li></ul></li></ul><p>局部性原理：序的执行总是呈现局部性。即，在一个较短的时间段内，程序的执行仅限于某个部分；相应的，它所访问的存储空间也局限于某个区域。因此，只要保证进程执行所需的部分程序和数据驻留在内存，一段时间内进程都能顺利执行。</p><p>虚拟存储器：当进程运行时，先将当前要运行的部分程序装入内存，其他部分暂留外存；<br> 当要执行的指令不在内存时，处理器发生中断，通知操作系统将所缺部分从外存调入内存，保证程序继续执行；<br> 当内存不足时，允许程序部分换入、换出</p><p>特征：多次性、对换性、虚拟性</p><p>实现方法：</p><ul><li><p>请求分页系统</p><p>请求分页的页表机制。缺页中断机构。地址变换机构</p><p>请求调页、页面置换</p></li><li><p>请求分段系统</p></li><li><p>段页式虚拟系统</p></li></ul><h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><p>页表机制：</p><p><img src="E:\typora-user-images\image-20220607183209907-169767934589557.png" alt="image-20220607183209907"></p><p>缺页中断处理：</p><ul><li>操作系统接收到进程产生的缺页中断信号，启动中断处<br>理例程，保留处理机现场；</li><li>操作系统通知处理机从外存读取指定的页面；</li><li>处理机激活I&#x2F;O设备；</li><li>检查内存有无足够的空闲空间装入该页面？若有，转<br>（6），否则，执行（5）；</li><li>（5） 利用页面置换算法，选择内存中的某个页面，换出内存；</li><li>（6） 将指定页面从外存装入内存；</li><li>更新该进程的页表；</li><li>更新快表；</li><li>计算物理地址。</li></ul><h4 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h4><p>最小物理块数：是指能保证进程正常运行所需的最少物理块数。若系统为某进程所分配的物理块数少于此值时，进程将无法运行。</p><p>物理块的分配策略：</p><ul><li>固定分配局部置换<br>（Fixed Allocation，Local Replacement）</li><li>可变分配全局置换<br>（Variable Allocation，Global Replacement）</li><li>可变分配局部置换<br>（Variable Allocation， Local Replacement ）</li></ul><p>物理块的分配算法：</p><ul><li><p>平均分配算法</p></li><li><p>按比例分配算法</p><p><img src="E:\typora-user-images\image-20220607185436904-169767934589558.png" alt="image-20220607185436904"></p></li><li><p>考虑优先权的分配算法</p></li></ul><h4 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h4><p>调页时机：预调页，请求调页</p><p>调入位置：用于存放文件的文件区；用于存放对换页面的对换区。</p><ul><li><p>系统拥有足够的对换区空间</p></li><li><p>系统缺少足够的对换区空间</p><p>这时凡是不会被修改的文件，都直接从文件区调入；</p><ul><li>而当换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从文件区直接调入。</li><li>但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。</li></ul></li><li><p>unix方式</p><p>由于与进程有关的文件都放在文件区，应从文件区调入。故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。</p></li></ul><p>页面调入过程：</p><ul><li>每当程序所要访问的页面未在内存时，便向CPU发出一缺页中断。</li><li>中断处理程序首先保留CPU环境，分析中断原因后，转入缺页中断处理程序。</li><li>如果内存已满，则须先按照某种置换算法从内存中选出一页准备换出；如果此页已被修改，则必须将它写回磁盘。</li><li>然后再把所缺的页调入内存，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表中。</li><li>形成所要访问数据的物理地址，再去访问内存数据。</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li><p>最佳置换算法(OPT)</p><p>从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时<br>间不需要访问的页面。</p></li><li><p>先进先出页面置换算法(FIFO)</p><p>总是选择作业中驻留时间最长(即最老)的一页淘汰。即：先进入主存的页面先退出主存</p></li><li><p>最近最久未使用置换算法(LRU)</p><p><img src="E:\typora-user-images\image-20220607191115105-169767934589560.png" alt="image-20220607191115105"></p><ul><li><p>移位寄存器。用于记录某进程在内存中各页使用情况。</p><p>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器可表示为：R&#x3D;Rn-1Rn-2Rn-3···R2R1RO<br>当进程访问某物理块时，要将相应寄存器的最高位Rn-1位置成1。系统每隔一定时间（例如100 ms）将寄存器右移一位。<br>如果我们把n位寄存器的数看作是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。</p></li><li><p>栈。用于保存当前进程使用的各个页面的页面号。</p><p>每当进程访问时某页面时，便将该页面号从栈中移出，压入栈顶。这样栈底则是最近最久未使用页面的页面号。 例如:假定一进程访问某页面的时页面号如下(5个存储块）：</p></li></ul></li><li><p>最少使用置换算法(LFU)</p><p><img src="E:\typora-user-images\image-20220607191539097-169767934589559.png" alt="image-20220607191539097"></p></li><li><p>Clock置换算法</p><p><img src="E:\typora-user-images\image-20220607191620995-169767934589561.png" alt="image-20220607191620995"></p></li><li><p>改进型Clock置换算法</p><p><img src="E:\typora-user-images\image-20220607191646194-169767934589562.png" alt="image-20220607191646194"></p></li><li><p>其他置换算法</p></li></ul><h3 id="缺页率对有效访问时间的影响"><a href="#缺页率对有效访问时间的影响" class="headerlink" title="缺页率对有效访问时间的影响"></a>缺页率对有效访问时间的影响</h3><p><img src="E:\typora-user-images\image-20220607191755507-169767934589663.png" alt="image-20220607191755507"></p><p><img src="E:\typora-user-images\image-20220607191956397-169767934589665.png" alt="image-20220607191956397"></p><h3 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h3><p><img src="E:\typora-user-images\image-20220607192026905-169767934589664.png" alt="image-20220607192026905"></p><h2 id="第七章-UNIX-x2F-Linux系统入门"><a href="#第七章-UNIX-x2F-Linux系统入门" class="headerlink" title="第七章 UNIX&#x2F;Linux系统入门"></a>第七章 UNIX&#x2F;Linux系统入门</h2><p>一个基于多用户、多任务、支持多线程和多CPU的操作系统</p><p>由Linux内核，LinuxShell，Linux文件系统，Linux应用程序组成，分为内核层和外核层，<br>内核层 是UNIX操作系统的核心，它实现存储管理、文件管理、设备管理、进程管理等功能并为外壳层提供系统调用。外壳层 为用户提供各种操作命令（UNIX把它们称为shell命令）和程序设计环境。外壳层由shell解释程序、支持程序设计的各种语言（如C、PASCAL和BASIC等）、编译程序和解释程序、实用程序和系统库等组成。</p><p>内核：</p><p><img src="E:\typora-user-images\image-20220607141812672-169767934589666.png" alt="image-20220607141812672"></p><h4 id="功能特征："><a href="#功能特征：" class="headerlink" title="功能特征："></a>功能特征：</h4><ul><li>开放性</li><li>多用户，多任务</li><li>良好的用户界面</li><li>设备独立性</li><li>提供了丰富的网络功能</li><li>可靠的安全系统</li><li>良好的可移植性</li></ul><h2 id="第八章-Shell的交互功能和程序设计"><a href="#第八章-Shell的交互功能和程序设计" class="headerlink" title="第八章 Shell的交互功能和程序设计"></a>第八章 Shell的交互功能和程序设计</h2><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><ul><li>command &gt; filename 进程输出覆盖文件 filename</li><li>command &gt;&gt; filename 进程输出追加到文件filename后面,不覆盖filename</li></ul><p><strong>输入重定向：</strong></p><ul><li>command &lt; filename，进程的输入来自文件filename,</li></ul><p>特殊例子：cat &lt; file1 &gt; file2：file1的内容写入file2中</p><p><strong>标准错误输出重定向：</strong></p><ul><li>command 2&gt; filename ( 2和&gt;之间没有空格 )：进程运行中的错误信息重定向到文件filename,</li></ul><p>特殊例子：$ grep string6 data_sav &gt; count_log 2&gt; &amp;1<br>把进程的出错信息存放到标准输出(已重定向到count_log)中, 即把标准输出和标准错误输出都定向到一个文件中.</p><p><strong>管道</strong></p><p>管道用于连接两个命令, 它把前一个命令的标准输出重定向给后一个命令作为标准输入, 其格式为:<br>command1 | command2<br>对command1来说标准输出被重新定向到管道, 对command2来说标准输入也被重新定向为管道.</p><p>例：</p><p><img src="E:\typora-user-images\image-20220607144244381-169767934589667.png" alt="image-20220607144244381"></p><p><img src="E:\typora-user-images\image-20220607144253812-169767934589668.png" alt="image-20220607144253812"></p><p><strong>多条命令</strong></p><p>$ pwd; who; date</p><p><strong>复合命令</strong></p><p><img src="E:\typora-user-images\image-20220607144404262-169767934589669.png" alt="image-20220607144404262"></p><p><strong>后台命令</strong></p><p><img src="E:\typora-user-images\image-20220607144447461-169767934589670.png" alt="image-20220607144447461"></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p><img src="E:\typora-user-images\image-20220607144556354-169767934589672.png" alt="image-20220607144556354"></p><p><strong>系统变量</strong></p><p><img src="E:\typora-user-images\image-20220607144645258-169767934589671.png" alt="image-20220607144645258"></p><p><strong>Shell变量和应用符</strong></p><p><img src="E:\typora-user-images\image-20220607144931020-169767934589673.png" alt="image-20220607144931020"></p><p><img src="E:\typora-user-images\image-20220607144952211-169767934589674.png" alt="image-20220607144952211"></p><p><img src="E:\typora-user-images\image-20220607145048987-169767934589675.png" alt="image-20220607145048987"></p><p><img src="E:\typora-user-images\image-20220607145211308-169767934589676.png" alt="image-20220607145211308"></p><p><strong>进程</strong></p><p>ps -e&#x2F;ps -a</p><p>ps -f</p><p>kill PID：正常结束进程, 自动完成所有善后工作, 作用类似于按 Del 键</p><p>kill -1 PID：先挂起该进程, 终止子进程, 完成善后工作, 再终止该进程</p><p>kill -9 PID：立即强行终止该进程, 不作任何善后工作. 可能出现资源浪费和”孤儿<br>“进程.</p><h4 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h4><ul><li>expr命令：</li></ul><p><img src="E:\typora-user-images\image-20220607151005026-169767934589677.png" alt="image-20220607151005026"></p><ul><li><p>tput命令</p><p><img src="E:\typora-user-images\image-20220607151120757-169767934589678.png" alt="image-20220607151120757"></p></li><li><p>结构性语句</p><ul><li><p>test语句：test命令测试的条件成立时, 命令返回值为真(0)，否则返回值为假(非0).</p><p><img src="E:\typora-user-images\image-20220607151434880-169767934589679.png" alt="image-20220607151434880"></p></li><li><p>if 表达式<br>then 命令表<br>fi</p></li><li><p>if 表达式<br>then 命令表1<br>else 命令表2<br>fi</p></li><li><p>case…esac</p><p><img src="E:\typora-user-images\image-20220607151618917-169767934589680.png" alt="image-20220607151618917"></p></li><li><p>for…do…done</p><p>for 变量名 in 单词表<br>do<br>命令表<br>done</p><p><img src="E:\typora-user-images\image-20220607152150438-169767934589681.png" alt="image-20220607152150438"></p></li><li><p>while…do…done</p><p>while 命令或表达式<br>do<br>命令表<br>done</p><p><img src="E:\typora-user-images\image-20220607152439764-169767934589682.png" alt="image-20220607152439764"></p></li><li><p>until…do…done</p><p>until 命令或表达式<br>do<br>命令表<br>done</p><p>until循环与while循环的功能相似, 所不同的是只有当测试的命令或表达式的值是假时, 才执行循环体中的命令表, 否则退出循环。 这一点与while命令正好相反。</p></li><li><p>循环控制语句 break 和 continue</p><p>break语句从包含该语句的最近一层循环中跳出一层,break n 则跳出n层; continue语句则马上转到最近一层循环语句的下一轮循环上, continue n则转到最近n层循环语句的下一轮循环上.</p></li></ul></li></ul><h4 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h4><p><img src="E:\typora-user-images\image-20220607152813752-169767934589683.png" alt="image-20220607152813752"></p><p><img src="E:\typora-user-images\image-20220607152845568-169767934589684.png" alt="image-20220607152845568"></p><p><strong>编程工具awk</strong></p><p>awk ‘pattern {action}’ filename<br>awk扫描filename中的每一行, 对符合模式pattern的行执行操作action。</p><p><img src="E:\typora-user-images\image-20220607154317622-169767934589685.png" alt="image-20220607154317622"></p><p><img src="E:\typora-user-images\image-20220607154334956-169767934589686.png" alt="image-20220607154334956"></p><p><img src="E:\typora-user-images\image-20220607154345527-169767934589687.png" alt="image-20220607154345527"></p><p><img src="E:\typora-user-images\image-20220607154355996-169767934589688.png" alt="image-20220607154355996"></p><p><img src="E:\typora-user-images\image-20220607154404950-169767934589689.png" alt="image-20220607154404950"></p><p><img src="E:\typora-user-images\image-20220607154419553-169767934589790.png" alt="image-20220607154419553"></p><p><img src="E:\typora-user-images\image-20220607154459783-169767934589791.png" alt="image-20220607154459783"></p><p><img src="E:\typora-user-images\image-20220607154509620-169767934589792.png" alt="image-20220607154509620"></p><h3 id="第九章-文件操作与权限管理"><a href="#第九章-文件操作与权限管理" class="headerlink" title="第九章 文件操作与权限管理"></a>第九章 文件操作与权限管理</h3><p>文件系统架构：</p><p><img src="E:\typora-user-images\image-20220607155811313-169767934589793.png" alt="image-20220607155811313"></p><p>物理表现形式：</p><ul><li>超级块：用于存储文件系统的控制信息的数据结构。描述文件系统的状态、文件系统类型、大小、区块数、索引节点数等，存放于磁盘的特定扇区中。</li><li>索引节点（i节点）：用于存储文件的元数据（文件的基本信息）的一个数据结构，包含诸如文件的大小、拥有者、创建时间、数据块&#x2F;目录块位置等信息。</li><li>目录块：存放目录文件的内容<ul><li>目录文件内容：一系列目录项（dirent）的列表，每个目录项由<br>两部分组成：所包含文件的文件名；文件名对应的索引节点（inode）号</li></ul></li><li>数据块：存放非目录文件的内容</li></ul><p>文件在内核中的表现形式：</p><ul><li>每个进程在PCB中有一个文件描述符表，每个描述符表项指向一个文件表</li><li>内核为每一个被该进程使用（打开）的文件维护一张文件表</li><li>每个文件（或设备）都有一个索引节点，它包含了文件类型属性及文件数据</li></ul><h3 id="第十章-进程运行与监控"><a href="#第十章-进程运行与监控" class="headerlink" title="第十章 进程运行与监控"></a>第十章 进程运行与监控</h3><p>创建过程：</p><ul><li>在shell中执行命令或可执行文件<br>▪由shell进程调用fork函数创建子进程</li><li>在代码中（已经存在的进程中）调用fork函数创建子进程<br>fork创建的进程为子进程<br>原进程为父进程</li></ul><p>父子进程关系：</p><p>子进程是父进程的副本<br>▪子进程复制&#x2F;拷贝父进程的PCB、用户空间（数据段、<br>堆和栈）<br>▪父子进程共享正文段（只读）</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-总结</title>
    <link href="/2023/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机复习"><a href="#计算机复习" class="headerlink" title="计算机复习"></a>计算机复习</h1><h2 id="第一章-计算机网络"><a href="#第一章-计算机网络" class="headerlink" title="第一章 计算机网络"></a>第一章 计算机网络</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1-概念"></a>1.1-概念</h3><p>计算机网络： </p><ul><li>一些互相连接的、一共享资源为目的的、自治的计算机的集合</li><li>计算机网络是用通信设备和线路将分散在不同地点的有独立功能的多个计算机系统互相连接起来，并按照网络协议进行数据通信，实现资源共享的计算机集合</li></ul><p>特征：连通和共享</p><h3 id="1-2-Internet"><a href="#1-2-Internet" class="headerlink" title="1.2-Internet"></a>1.2-Internet</h3><p>Internet：由网络构成的网络</p><p>具体构成：</p><ul><li><p>公共因特网</p></li><li><p>通信链路：连接相邻两个网络节点的物理线路</p></li><li><p>分组交换机：连接端系统的中间交换设备</p><p>功能：接受、转发分组</p></li><li><p>分组交换技术</p><p>发送端将要发送的数据分成若干较小的块，添加手部形成分组，分别发送到目的端，再组装恢复数据</p><p>第一个分组交换网络：ARPA网</p></li><li><p>因特网服务提供商：ISP</p><p>一个由多个分组交换机和多段通信链路组成的网络</p></li></ul><p>服务：</p><ul><li><p>提供网络应用基础架构</p><p>允许端系统上运行分布式应用程序，并彼此交换数据</p></li><li><p>为分布式应用程序提供的通信服务接口</p><p>无连接服务</p><p>面向连接服务</p><p>不提过数据传递时间保证(发送端到接收端)的服务</p></li></ul><p>通信控制：</p><ul><li><p>控制发送和接受消息-协议</p><p>协议：控制网络中信息的发送和接受，定义了通信实体之间交换的报文的格式和传输顺序，以及在报文发送或接受或者其他事件方面所采取的行动(响应)</p><p>基本要素：语法、语义和同步</p></li></ul><h3 id="1-3网络组成部分"><a href="#1-3网络组成部分" class="headerlink" title="1.3网络组成部分"></a>1.3网络组成部分</h3><p>网络分为两大部分：</p><ul><li>网络边缘（资源子网）<ul><li>外围部件、主机</li><li>应用程序</li></ul></li><li>网络核心（通信子网）<ul><li>路由器<ul><li>接受分组，然后根据分组接受终端的地址信息，将分组转发到相应的输出链路上，最终能使分组到达接受终端</li><li>在因特网中，每个分组都会包含接受终端的IP地址，路由器根据IP地址，在自己的转发表中查找这个IP地址（和IP地址的一部分）对应的输出链路</li><li>每个路由器通过路由选择协议，自动的对自己维护的转发表进行设置。一个基本准则是：从本路由器到达目的终端的距离最短。</li></ul></li><li>通信链路</li><li>网络的网络</li></ul></li></ul><p>接入网络：</p><ul><li><p>接入网</p><p>将端系统连接到其边缘路由器的物理链路</p></li><li><p>边缘路由器</p><p>端系统到任何其他远程端系统的路径上的第一台路由器</p></li></ul><p>接入类型</p><ul><li>家庭接入网络<ul><li>点对点接入</li><li>电缆英特网接入</li><li>线缆调制解调器</li><li>光纤到户</li></ul></li><li>企业接入网络：LAN</li><li>WIFI无线接入网络</li><li>广域无线接入网络</li></ul><p>物理介质：<br>将网络中不同节点互相连接起来的物理线路</p><ul><li>导引型媒体<ul><li>双绞线（屏蔽&#x2F;非屏蔽）</li><li>同轴电缆和光纤线缆</li></ul></li><li>非导引型媒体<ul><li>无线电波磁<br>利用无线电波在自由空间传播实现通信</li></ul></li></ul><p>端系统上的因特网服务</p><ul><li>面向连接的服务<br>目的：在端系统间传送数据<br>TCP：可靠、顺序、字节流传输；流量控制；拥塞控制<br>例：HTTP；FTP；SMTP</li><li>无连接服务<br>UDP：不可靠数据传输；无流量控制；无拥塞控制<br>例：流媒体；视频会议：DNS等</li></ul><h3 id="1-4-网络核心部分"><a href="#1-4-网络核心部分" class="headerlink" title="1.4-网络核心部分"></a>1.4-网络核心部分</h3><p>传输数据技术：</p><ul><li>电路交换<ul><li>预留端到端资源</li><li>恒定速率传送数据（电话网络）</li></ul></li><li>分组交换<ul><li>无需资源预留</li><li>按需使用资源，可能要排队等待（因特网）</li></ul></li></ul><h4 id="1-4-1-电路交换"><a href="#1-4-1-电路交换" class="headerlink" title="1.4.1-电路交换"></a>1.4.1-电路交换</h4><p>原理：通信双方必须先建立一个专用的连接（电路），一致维持，知道通信结束</p><p>多路复用：在一条传输链路上同时建立多条连接，分别传输数据</p><ul><li>频分多路复用（FDM）<br>链路的频谱由跨越链路创建的连接所共享<br>按频率划分若干频段，每个频段专用于一个连接<br>带宽：频段的带宽：如，8kHZ</li><li>时分多路复用（TDM）<br>时间划分为固定区间的帧，每帧在划分为固定数量的时隙，每一个时隙专用于一个连接，用于传输数据</li></ul><h4 id="1-4-2-分组交换"><a href="#1-4-2-分组交换" class="headerlink" title="1.4.2-分组交换"></a>1.4.2-分组交换</h4><p>报文：应用程序要传输的信息。包含需要的任何内容。如，控制功能和数据</p><p>过程：</p><ul><li>源端将报文划分为较小的数据块（分组）</li><li>每个分组通过一系列链路和分组交换机传送，知道目的端</li><li>目的端恢复报文</li></ul><p>传输过程中采用存储转发传输机制</p><p>存储转发传输：分组交换机将输入端的整个分组接受下来（存储），再从输出链路转发出去（转发）</p><p>排队时延和分组丢失：</p><ul><li>输出缓存：用于保存准备发往某个链路的分组</li><li>排队时延：分组在输出缓存中等待转发的时间</li><li>分组丢失：当缓存空间已满时，由分组要被丢弃</li></ul><p>转发表和路由选择协议：</p><ul><li>接受分组，然后根据分组接受终端的地址信息，将分组转发到相应的输出链路上，最终能使分组到达接受终端</li><li>在因特网中，每个分组都会包含接受终端的IP地址，路由器根据IP地址，在自己的转发表中查找这个IP地址（和IP地址的一部分）对应的输出链路</li><li>每个路由器通过路由选择协议，自动的对自己维护的转发表进行设置。一个基本准则是：从本路由器到达目的终端的距离最短。</li></ul><p>分类：</p><ul><li><p>数据报网络：TCP&#x2F;IP</p></li><li><p>虚电路网络：X.25，FR,ATM</p><p>一定是面向连接的</p></li></ul><p><strong>报文交换</strong></p><p>将要发送的整个信息作为一个报文发送。<br>采用存储转发技术： 整个报文先传送到相邻结点，全部存储下来，再转发到下一个结点。</p><h3 id="1-5-分组交换中的延迟、丢失和吞吐量"><a href="#1-5-分组交换中的延迟、丢失和吞吐量" class="headerlink" title="1.5-分组交换中的延迟、丢失和吞吐量"></a>1.5-分组交换中的延迟、丢失和吞吐量</h3><p>延迟和丢失产生原因：</p><ul><li>分组到达输出链路的速率超过输出链路的容量，产生延迟，甚至丢失</li><li>分组在缓冲队列排队，按序等待</li></ul><p>分组时延类型：</p><ul><li>节点处理时延，排队时延，传输时延和传播时延等</li></ul><p>流量强度：比特到达队列的速率于比特从队列中推出的速率之比（设置时流量强度不能大于1）</p><h4 id="1-5-1-分组丢失"><a href="#1-5-1-分组丢失" class="headerlink" title="1.5.1-分组丢失"></a>1.5.1-分组丢失</h4><ul><li>路由器输入链路和输出链路的缓冲区容量有限</li><li>当分组到达路由器输入链路发现缓冲区已满，则路由器只好丢弃分组</li><li>当分组在路由器内部要转发到输出链路时发现输出缓冲区队列已满，路由器只好丢弃分组</li><li>丢失的分组可能被前路由节点、源节点重传，或不重传</li><li>丢包率或分组丢失率（packet loss rate&#x2F;ratio）</li></ul><h4 id="1-5-2-吞吐量"><a href="#1-5-2-吞吐量" class="headerlink" title="1.5.2-吞吐量"></a>1.5.2-吞吐量</h4><p>吞吐量：接受端接收到数据的比特速率</p><ul><li>瞬时吞吐量：某一瞬间的吞吐量</li><li>平均吞吐量：一段时间内的吞吐量的</li></ul><h3 id="1-6-协议层及其服务模型"><a href="#1-6-协议层及其服务模型" class="headerlink" title="1.6-协议层及其服务模型"></a>1.6-协议层及其服务模型</h3><p>协议分层：采用分层的方式组织及实现协议的网络硬件和软件</p><ul><li>每层都有相应的一系列协议，如TCP,HTTP</li><li>每层协议通过软件、硬件或者两者结合实现</li><li>每层协议可分布在网络的不同组件中</li></ul><h4 id="1-6-1-因特网协议栈"><a href="#1-6-1-因特网协议栈" class="headerlink" title="1.6.1-因特网协议栈"></a>1.6.1-因特网协议栈</h4><p>协议层实现：以软件、硬件或两者结合的方式</p><ul><li>应用层（报文）：在端系统中用软件实现，如HTTP<br>功能：提供各种网络应用，传输应用报文（FTP、SMTP、HTTP）</li><li>运输层（报文段）：同上<br>功能：在应用程序的客户机和服务器之间提供传输应用层报文服务，传输报文段（TCP、UDP）</li><li>网络层（数据报）：硬件、软件混合<br>功能：主机和主机之间传输网络层分组（数据报）（IP协议，选路协议）</li><li>链路层（帧）：<br>功能：在邻近单元之间传输数据（帧）（PPP、以太网）</li><li>物理层（比特）：负责处理跨越特定链路的通信，通过与该链路相关的网络接口卡实现（物理层和链路层）<br>功能：在节点之间传输比特流（传输媒体）</li></ul><h4 id="1-6-2-协议分层与数据"><a href="#1-6-2-协议分层与数据" class="headerlink" title="1.6.2-协议分层与数据"></a>1.6.2-协议分层与数据</h4><p>各层发方从上层到下层，收方从下层到上层传递数据</p><ul><li>发方添加首部信息创建新的数据单元（封装），收方去掉首部（解封）</li><li>传递新的数据单元到下层&#x2F;上层</li><li>各层传送不同的协议数据单元PDU</li></ul><h4 id="1-6-3实体、协议、服务和服务访问点总结"><a href="#1-6-3实体、协议、服务和服务访问点总结" class="headerlink" title="1.6.3实体、协议、服务和服务访问点总结"></a>1.6.3实体、协议、服务和服务访问点总结</h4><ul><li>对等实体: 两台计算机上同一层所属的程序、进程或实体称为该层的对等程序、对等进程或对等实体。</li><li>协议是控制两个对等实体进行通信的规则的集合。</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</li><li>要实现本层协议，还需要使用下层所提供的服务。</li><li>本层的服务用户只能看见服务而无法看见下面的协议。</li><li>下面的协议对上面的服务用户是透明的。</li><li>协议是“水平的”，即协议是控制对等实体之间通信的规则。</li><li>服务是“垂直的”，即服务是由下层向上层通过层间接口(SAP)提供的。</li></ul><h3 id="1-7-攻击威胁下的网络"><a href="#1-7-攻击威胁下的网络" class="headerlink" title="1.7-攻击威胁下的网络"></a>1.7-攻击威胁下的网络</h3><p>攻击方式：</p><ul><li>植入恶意软件<ul><li>病毒</li><li>蠕虫</li><li>僵尸网络</li></ul></li><li>攻击服务器和网络基础设施<ul><li>拒绝服务攻击<br>弱点攻击、带宽洪泛、连接洪泛</li></ul></li><li>嗅探分组</li><li>伪装</li><li>修改或删除报文</li></ul><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><h3 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1-应用层协议原理"></a>2.1-应用层协议原理</h3><p>研发网络应用程序的核心：<br>写出能够运行在不同的端系统并通过网络彼此通信的程序</p><p>应用程序软件不应运行在网络核心设备上<br>网络核心设备不在应用层起作用</p><h4 id="2-1-1-网络应用程序体系结构"><a href="#2-1-1-网络应用程序体系结构" class="headerlink" title="2.1.1-网络应用程序体系结构"></a>2.1.1-网络应用程序体系结构</h4><ul><li><p>客服&#x2F;服务器体系结构</p><ul><li>服务器<ul><li>总是打开的主机</li><li>具有固定的、众所周知的IP地址</li><li>主机群集常被用于创建强大的虚拟服务器</li></ul></li><li>客户机<ul><li>同服务器端通信</li><li>可以间断的同服务器连接</li><li>可以拥有动态IP地址</li><li>客户机相互之间不直接通信</li></ul></li></ul></li><li><p>纯P2P体系结构</p><ul><li>没有总是打开的服务器</li><li>任意一对主机直接相互通信</li><li>对等方间歇连接并且可以改变IP地址</li><li>例如：文件分发、英特网电话</li><li>优点：自扩展性|缺点：难以管理</li></ul></li><li><p>客户机&#x2F;服务器和P2P混合的体系结构</p><ul><li>Napster<ul><li>文件在对等方之间交换</li><li>文件搜索通过服务器</li><li>中心服务器记录对等方内容</li><li>对等方查询中心服务器来决定要求的文件位置</li></ul></li><li>即使讯息<ul><li>两个聊天用户之间是P2P</li><li>注册、查询通过服务器</li><li>用户上线要在中心服务器上进行注册</li><li>用户与中心服务器联系以找出在线伙伴</li></ul></li></ul></li></ul><h4 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2-进程通信"></a>2.1.2-进程通信</h4><p>客户机进程：发起通信的进程</p><p>服务器进程：等待其他进程联系的进程</p><h4 id="2-1-3-套接字"><a href="#2-1-3-套接字" class="headerlink" title="2.1.3-套接字"></a>2.1.3-套接字</h4><p>套接字：同一台主机内应用层与运输层之间的接口。也叫应用程序和网络之间的应用程序接口API ,是在网络上建立网络应用程序的可编程接口。<br><img src="E:\typora-user-images\image-20220610142315828-1697679581281276.png" alt="image-20220610142315828"></p><p>用户通过API对传输层的控制仅限于：<br>(1) 选择传输协议;<br>(2) 能设定几个参数</p><h4 id="2-1-4-进程识别信息"><a href="#2-1-4-进程识别信息" class="headerlink" title="2.1.4-进程识别信息"></a>2.1.4-进程识别信息</h4><ul><li>主机名称或地址：网络中的哪一个主机。<br>因特网中，用IP地址标识（32位，全球惟一）。</li><li>进程的标识：主机中的哪一个进程。<br>因特网中，采用端口号标识(port number)。</li></ul><h4 id="2-1-5用户代理"><a href="#2-1-5用户代理" class="headerlink" title="2.1.5用户代理"></a>2.1.5用户代理</h4><p>是用户有网络应用之间的接口<br><img src="E:\typora-user-images\image-20220610142843715-1697679581281277.png" alt="image-20220610142843715"></p><h3 id="2-2-Web应用和HTTP协议"><a href="#2-2-Web应用和HTTP协议" class="headerlink" title="2.2-Web应用和HTTP协议"></a>2.2-Web应用和HTTP协议</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1-概述"></a>2.2.1-概述</h4><p>HTTP：超文本传输协议，应用层协议，Web的核心</p><p>客户机程序：浏览器browser请求, 接收Web对象<br>服务器程序：Web服务器响应请求,发送 Web对象</p><p>HTTP协议定义了报文的格式以及客户机和服务器交换报文的格式和方式</p><p>Web页(文档)：由若干对象组成。<br>对象：是文件。如HTML文件、JPEG图形文件、Java小程序等。通过一个URL地址来寻址<br><img src="E:\typora-user-images\image-20220610144326435-1697679581281278.png" alt="image-20220610144326435"></p><p><img src="E:\typora-user-images\image-20220610144422752-1697679581281281.png" alt="image-20220610144422752"></p><p><img src="E:\typora-user-images\image-20220610144433668-1697679581281280.png" alt="image-20220610144433668"></p><p><strong>概述（续）</strong></p><ul><li>使用TCP<ul><li>客户初始化一个与HTTP服务器80端口的TCP连接 (创建套接字)</li><li>HTTP服务器接受来自客户的TCP连接请求, 建立连接</li><li>Browser (HTTP client)和Web服务器(HTTP server) 交换HTTP消息(应用层协议消息)包括HTTP请求和响应消息</li><li>最后结束(或叫关闭)TCP连接</li></ul></li><li>HTTP是无状态协议<ul><li>HTTP服务器不维护客户先前的状态信息</li></ul></li></ul><h4 id="2-2-2-HTTP连接"><a href="#2-2-2-HTTP连接" class="headerlink" title="2.2.2-HTTP连接"></a>2.2.2-HTTP连接</h4><ul><li>非持久HTTP连接<ul><li>每个TCP连接上只传送一个Web对象</li><li>只传送一个请求&#x2F;响应对</li><li>HTTP&#x2F;1.0使用非持续HTTP连接</li></ul></li><li>持久HTTP连接<ul><li>一个TCP连接上可以传送多个Web对象</li><li>传送多个请求&#x2F;响应对</li><li>HTTP&#x2F;1.1默认使用持续HTTP连接</li></ul></li></ul><p><strong>三次握手</strong></p><p>RTT（往返时间）：一个小分组从客户主机才服务器再到客户主机花费的时间</p><ul><li>客户机发送一个TCP连接请求报文段</li><li>服务器回送一个TCP确认响应报文段</li><li>客户机向服务器发送一个包含“ HTTP请求”与“TCP确认”的报文</li><li>总响应时间：两个RTT时延加上服务器发送文件的时间<br>总计 &#x3D; 2RTT+文件传输时间</li></ul><p><img src="E:\typora-user-images\image-20220610150001925-1697679581281279.png" alt="image-20220610150001925"></p><p><strong>HTTP报文格式</strong></p><p>2类HTTP报文：请求报文request，响应报文response</p><ul><li><p>HTTP请求报文（ASCII文本）<br><img src="E:\typora-user-images\image-20220610150246702-1697679581281282.png" alt="image-20220610150246702"></p><p><img src="E:\typora-user-images\image-20220610150327145-1697679581281283.png" alt="image-20220610150327145"></p><p><img src="E:\typora-user-images\image-20220610150611461-1697679581281284.png" alt="image-20220610150611461"></p></li><li><p>HTTP响应报文</p><p><img src="E:\typora-user-images\image-20220610150735163-1697679581282285.png" alt="image-20220610150735163"></p><p><img src="E:\typora-user-images\image-20220610150759015-1697679581282286.png" alt="image-20220610150759015"></p><p><img src="E:\typora-user-images\image-20220610150833810-1697679581282287.png" alt="image-20220610150833810"></p></li></ul><h4 id="2-2-3-Cookies"><a href="#2-2-3-Cookies" class="headerlink" title="2.2.3-Cookies"></a>2.2.3-Cookies</h4><p>Cookie：允许Web站点跟踪、识别用户；服务器可以限制用户访问，或把内容与用户身份关联<br><img src="E:\typora-user-images\image-20220610151052989-1697679581282288.png" alt="image-20220610151052989"></p><p>重要方面：</p><ul><li>cookie头部行在HTTP请求消息中</li><li>cookie头部行在HTTP响应消息中</li><li>cookie文件 保存在用户主机中并被用户浏览器管理</li><li>cookie也保存在Web站点的后端数据库</li></ul><h4 id="2-2-4-Web缓存（代理服务器）"><a href="#2-2-4-Web缓存（代理服务器）" class="headerlink" title="2.2.4-Web缓存（代理服务器）"></a>2.2.4-Web缓存（代理服务器）</h4><p>能够代表起始服务器来满足HTTP请求的网络实体</p><ul><li>用户配置浏览器: Web 访问经由缓存</li><li>所有HTTP请求指向缓存</li></ul><p>目标：代表起始服务器满足HTTP请求<br><img src="E:\typora-user-images\image-20220610151524793-1697679581282289.png" alt="image-20220610151524793"></p><p><img src="E:\typora-user-images\image-20220610151539460-1697679581282290.png" alt="image-20220610151539460"></p><p>Web缓存部署位置：</p><p>服务器端、代理服务器端、客户端</p><p>使用Web缓存替换算法，移除价值较低的对象算法如何实现？<br>随机替换算法<br>基于访问时间间隔的替换算法<br>基于访问频率的替换算法<br>基于对象大小的替换算法<br>基于目标函数的替换算法</p><p>条件GET方法</p><p><img src="E:\typora-user-images\image-20220610154537312-1697679581282291.png" alt="image-20220610154537312"></p><p><img src="E:\typora-user-images\image-20220610154525965-1697679581282292.png" alt="image-20220610154525965"></p><h3 id="2-3-文件传输协议：FTP"><a href="#2-3-文件传输协议：FTP" class="headerlink" title="2.3-文件传输协议：FTP"></a>2.3-文件传输协议：FTP</h3><p>文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议。<br>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。<br>FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。<br>RFC 959 很早就成为了因特网的正式标准</p><p>传输过程：</p><ul><li><p>用户提供远程主机的主机名：在本地主机的FTP客户机进程与远程主机FTP服务器进程之间建立TCP连接；</p></li><li><p>提供用户标识和口令：在该TCP连接上向服务器传送。</p></li><li><p>服务器验证通过后，进行文件传送（双向）：<br>将本地文件系统中的文件传送到远程文件系统（上传）或从远程文件系统中得到文件（下载）</p><p><img src="E:\typora-user-images\image-20220610160358897-1697679581282293.png" alt="image-20220610160358897"></p></li></ul><p><img src="E:\typora-user-images\image-20220610160455996-1697679581282295.png" alt="image-20220610160455996"></p><p><img src="E:\typora-user-images\image-20220610160538645-1697679581282294.png" alt="image-20220610160538645"></p><p>FTP命令和应答：</p><p><img src="E:\typora-user-images\image-20220610160618613-1697679581282296.png" alt="image-20220610160618613"></p><h3 id="2-4-因特网中的电子邮件SMTP，POP3，IMAP"><a href="#2-4-因特网中的电子邮件SMTP，POP3，IMAP" class="headerlink" title="2.4-因特网中的电子邮件SMTP，POP3，IMAP"></a>2.4-因特网中的电子邮件SMTP，POP3，IMAP</h3><p>邮件阅读器：允许用户阅读、回复、发送、保存和撰写报文</p><ul><li>当用户完成邮件撰写时，邮件代理向其邮件服务器发送邮件，并存放在发送队列中。</li><li>当用户想读取一封邮件时，邮件代理从其邮件服务器的邮箱中获取该邮件</li></ul><p><strong>发送过程</strong></p><ul><li>邮件保存到发送方报文队列</li><li>通过SMTP协议转发到接收方邮件服务器，保存到相应邮箱中<ul><li>若投递失败，发送方将其保存在一个报文队列中，以后每30分钟发送一次，若几天后仍未成功，将该报文删除，并通知发送方。</li><li>用户访问自己邮箱时，邮件服务器对其身份进行验证(用户名和口令)。</li></ul></li></ul><h4 id="2-4-1-电子邮件：SMTP"><a href="#2-4-1-电子邮件：SMTP" class="headerlink" title="2.4.1-电子邮件：SMTP"></a>2.4.1-电子邮件：SMTP</h4><p><img src="E:\typora-user-images\image-20220610161116420-1697679581282297.png" alt="image-20220610161116420"></p><p>例子：Alice发送消息到Bob</p><p><img src="E:\typora-user-images\image-20220610161247663-1697679581282299.png" alt="image-20220610161247663"></p><p>与HTTP的对比：</p><p><img src="E:\typora-user-images\image-20220610161222182-1697679581282298.png" alt="image-20220610161222182"></p><p>邮件消息的格式：</p><p><img src="E:\typora-user-images\image-20220610161514129-1697679581282300.png" alt="image-20220610161514129"></p><p>多媒体扩展：</p><p><img src="E:\typora-user-images\image-20220610161546598-1697679581282301.png" alt="image-20220610161546598"></p><p>邮件访问协议：</p><p><img src="E:\typora-user-images\image-20220610161736874-1697679581282302.png" alt="image-20220610161736874"></p><h4 id="2-4-2-POP3协议"><a href="#2-4-2-POP3协议" class="headerlink" title="2.4.2-POP3协议"></a>2.4.2-POP3协议</h4><p>POP3（第三版的邮局协议）<br><img src="E:\typora-user-images\image-20220610161840267-1697679581282303.png" alt="image-20220610161840267"></p><p><img src="E:\typora-user-images\image-20220610161901686-1697679581282304.png" alt="image-20220610161901686"></p><h4 id="2-4-3-IMAP协议"><a href="#2-4-3-IMAP协议" class="headerlink" title="2.4.3-IMAP协议"></a>2.4.3-IMAP协议</h4><p>IMAP（因特网邮件访问协议）</p><p> POP3缺陷：功能简单。 POP3会话是无状态的<br>IMAP： 功能强</p><ul><li>在用户的PC机上运行IMAP客户程序，然后与ISP的邮件服务器上的IMAP服务器程序建立TCP连接。</li><li>用户在自己的PC机上就可以操纵邮件服务器的邮箱，就像在本地操纵一样，是一个联机协议。</li><li>IMAP服务器把每个报文与一个文件夹联系起来。</li><li>IMAP 还允许收件人只读取邮件中的某一个部分</li><li>IMAP服务器维护用户的会话状态。</li><li>未发出删除命令前，一直保存在邮件服务器</li><li>实现起来复杂。</li></ul><h3 id="2-5-DNS：英特网的目录服务"><a href="#2-5-DNS：英特网的目录服务" class="headerlink" title="2.5-DNS：英特网的目录服务"></a>2.5-DNS：英特网的目录服务</h3><p>标识主机的两种方式：</p><ul><li>主机名<br>用于人记忆识别</li><li>IP地址<br>路由器同意处理，用于分组寻址</li></ul><p>域名系统DNS：进行主机名到IP地址的转换</p><ul><li>一个由分层的DNS服务器实现的分布式数据库</li><li>允许主机查询分布式数据库的应用层协议；</li><li>DNS协议运行在UDP之上，使用53号端口。</li><li>DNS通常直接由其他的应用层协议 (包括HTTP、SMTP 和FTP)使用，以将用户提供的主机名解析为IP地址。用户只是间接使用。</li></ul><h4 id="2-5-1-运行过程"><a href="#2-5-1-运行过程" class="headerlink" title="2.5.1-运行过程"></a>2.5.1-运行过程</h4><p><img src="E:\typora-user-images\image-20220610170514913-1697679581282305.png" alt="image-20220610170514913"></p><p><img src="E:\typora-user-images\image-20220610170655056-1697679581282306.png" alt="image-20220610170655056"></p><h4 id="2-5-2-DNS查询方法："><a href="#2-5-2-DNS查询方法：" class="headerlink" title="2.5.2-DNS查询方法："></a>2.5.2-DNS查询方法：</h4><ul><li><p>递归查询</p><p><img src="E:\typora-user-images\image-20220610171003276-1697679581282307.png" alt="image-20220610171003276"></p></li><li><p>迭代查询</p><p><img src="E:\typora-user-images\image-20220610171015144-1697679581282308.png" alt="image-20220610171015144"></p></li></ul><p>DNS缓存和权威DNS记录更新</p><ul><li><p>一旦名字服务器获得DNS映射, 它将缓存该映射到局部内存</p><ul><li><p>服务器在一定时间后将丢弃缓存的信息</p></li><li><p>本地DNS服务器可以缓存TLD服务器的IP地址</p></li><li><p>因此根DNS服务器不会被经常访问</p></li></ul></li><li><p>权威DNS服务器记录更新：IETF动态更新&#x2F;通报机制，RFC 2136</p></li></ul><h4 id="2-5-3-DNS记录："><a href="#2-5-3-DNS记录：" class="headerlink" title="2.5.3-DNS记录："></a>2.5.3-DNS记录：</h4><p>RR（存储资源记录）：提供主机名到IP地址映射<br>RR 格式: (name, value, type,ttl)</p><ul><li>Type&#x3D;A（Adress）<br>name &#x3D; 主机名<br>value &#x3D; IP地址</li><li>Type&#x3D;NS（ name server ）<br>name &#x3D; 域名(如baidu.com）<br>value &#x3D; 该域权威名字服务器的<br>主机名</li><li>Type&#x3D;CNAME（canonical name）<br>name &#x3D; 主机别名<br><a href="http://www.ibm.com的规范主机名为/">www.ibm.com的规范主机名为</a><br>servereast.backup2.ibm.com<br>value &#x3D; 真实的规范主机名</li><li>Type&#x3D;MX（mail exchange）<br>name &#x3D;邮件服务器的主机别名<br>value &#x3D;邮件服务器的真实规范主机</li></ul><h4 id="2-5-4-DNS协议："><a href="#2-5-4-DNS协议：" class="headerlink" title="2.5.4-DNS协议："></a>2.5.4-DNS协议：</h4><p>查询报文与应答报文，具有同样的报文格式<br><img src="E:\typora-user-images\image-20220610171625601-1697679581282309.png" alt="image-20220610171625601"></p><p><img src="E:\typora-user-images\image-20220610171715662-1697679581282316.png" alt="image-20220610171715662"></p><p>问题格式：<br><img src="E:\typora-user-images\image-20220610171906170-1697679581282310.png" alt="image-20220610171906170"></p><p>回答、权威、附加部分的格式：<br><img src="E:\typora-user-images\image-20220610171933435-1697679581282311.png" alt="image-20220610171933435"></p><p>例：<img src="E:\typora-user-images\image-20220610171947466-1697679581282312.png" alt="image-20220610171947466"></p><p>DOS攻击：</p><ul><li>DDoS攻击：对根域名服务器或顶级域名服务器发起拒绝服务攻击</li><li>重定向攻击：中间人攻击、DNS中毒攻击（发送欺骗的域名解析结果给DNS服务器）</li><li>利用DNS实现DDoS攻击： DNS反弹式拒绝服务攻击(DNS reflector attacks，又称DNS amplification attacks)。伪造客户地址向大量的dns服务器发出请求，导致客户无法访问dns服务器进行域名解析。</li></ul><h3 id="2-6-P2P技术"><a href="#2-6-P2P技术" class="headerlink" title="2.6-P2P技术"></a>2.6-P2P技术</h3><p>P2P文件共享：位于网络边缘的PC机（对等方peer）互相之间可以直接获取对象。<br>说明：每个参与的对等方既是内容的消费者也是内容的发布者（下<br>载同时也向其他用户上载）</p><h4 id="2-6-1-过程"><a href="#2-6-1-过程" class="headerlink" title="2.6.1-过程"></a>2.6.1-过程</h4><p><img src="E:\typora-user-images\image-20220610173302686-1697679581282314.png" alt="image-20220610173302686"></p><p><img src="E:\typora-user-images\image-20220610173323771-1697679581282313.png" alt="image-20220610173323771"></p><h4 id="2-6-2-内容定位体系结构"><a href="#2-6-2-内容定位体系结构" class="headerlink" title="2.6.2-内容定位体系结构"></a>2.6.2-内容定位体系结构</h4><ul><li><p>集中式目录</p><p><img src="E:\typora-user-images\image-20220610173456874-1697679581282315.png" alt="image-20220610173456874"></p><p><img src="E:\typora-user-images\image-20220610173506935-1697679581282317.png" alt="image-20220610173506935"></p><p><img src="E:\typora-user-images\image-20220610173523840-1697679581282320.png" alt="image-20220610173523840"></p></li><li><p>查询洪泛</p><p><img src="E:\typora-user-images\image-20220610173545121-1697679581282318.png" alt="image-20220610173545121"></p><ul><li><p>Gnutella</p><p><img src="E:\typora-user-images\image-20220610173620002-1697679581282319.png" alt="image-20220610173620002"></p><p><img src="E:\typora-user-images\image-20220610173701960-1697679581282321.png" alt="image-20220610173701960"></p><p><img src="E:\typora-user-images\image-20220610173725101-1697679581282322.png" alt="image-20220610173725101"></p><p><img src="E:\typora-user-images\image-20220610173741788-1697679581282323.png" alt="image-20220610173741788"></p></li><li></li></ul></li><li><p>利用不均匀性</p><ul><li>KaZaA</li></ul><p><img src="E:\typora-user-images\image-20220610173939624-1697679581282324.png" alt="image-20220610173939624"></p><p><img src="E:\typora-user-images\image-20220610173953772-1697679581282326.png" alt="image-20220610173953772"></p><p><img src="E:\typora-user-images\image-20220610174009306-1697679581282325.png" alt="image-20220610174009306"></p><p><img src="E:\typora-user-images\image-20220610174018292-1697679581282327.png" alt="image-20220610174018292"></p></li></ul><p>P2P文件分发-BitTorrent</p><p>BitTorrent是一种用于文件分发的流行P2P协议<br>参与一个特定文件分发的所有对等方的集合被称为一个洪流（torrent）<br>一个洪流中的对等方彼此下载等长度的文件快（chunk），典型快长度为256KB</p><p><img src="E:\typora-user-images\image-20220610174438358-1697679581282332.png" alt="image-20220610174438358"></p><p><img src="E:\typora-user-images\image-20220610174454613-1697679581282329.png" alt="image-20220610174454613"></p><h3 id="2-7-内容分发网络（CDN）"><a href="#2-7-内容分发网络（CDN）" class="headerlink" title="2.7-内容分发网络（CDN）"></a>2.7-内容分发网络（CDN）</h3><p>解决办法：基于基础应用设施级别的内容分发</p><p>多媒体视频流：DASH<br><img src="E:\typora-user-images\image-20220610185107942-1697679581282328.png" alt="image-20220610185107942"></p><p>选项：将多份拷贝存储在地理上分散的不同站点来提供服务（CDN）</p><p><img src="E:\typora-user-images\image-20220610185426177-1697679581282331.png" alt="image-20220610185426177"></p><p><img src="E:\typora-user-images\image-20220610185500912-1697679581282330.png" alt="image-20220610185500912"></p><p><img src="E:\typora-user-images\image-20220610185511319-1697679581282333.png" alt="image-20220610185511319"></p><h2 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h2><h3 id="3-1-传输层服务"><a href="#3-1-传输层服务" class="headerlink" title="3.1-传输层服务"></a>3.1-传输层服务</h3><p>在两个不同的主机上运行的应用程序之间提供逻辑通信</p><p>传输层协议运行在端系统</p><ul><li>发送方：将应用程序报文分成数据段传递给网络层</li><li>接受方：将数据段重新组装成报文传递到应用层</li></ul><p>从通信和信息服务处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能的最低层</p><p>传输层：两个进程之间的逻辑通信；可靠，增强的网络层服务</p><ul><li>解决的是计算机进程到计算机进程之间的通信问题，即所谓的“端”到“端”的通信</li></ul><p>网络层：两个主机之间的逻辑通信</p><h3 id="3-2-多路复用和多路分解"><a href="#3-2-多路复用和多路分解" class="headerlink" title="3.2-多路复用和多路分解"></a>3.2-多路复用和多路分解</h3><p><img src="E:\typora-user-images\image-20220610203158190-1697679581282334.png" alt="image-20220610203158190"></p><p><img src="E:\typora-user-images\image-20220610203234096-1697679581282336.png" alt="image-20220610203234096"></p><p>多路分解工作过程：</p><ul><li><p>主机接受IP数据报</p><ul><li>每个数据包承载1个运输层段</li><li>每个段具有源、目的端口号</li></ul></li><li><p>主机使用IP地址&amp;端口号将段定向到适当的套接字</p></li></ul><p>无连接多路分解：</p><ul><li><p>生成具有端口号的套接字:<br>DatagramSocket mySocket1 &#x3D; new<br>DatagramSocket(9911);<br>serverSocket &#x3D; socket(AF_INET,SOCK_DGRAM)<br>serverSocket.bind((‘’, serverPort))</p></li><li><p>UDP套接字由二元组标识 :<br>(目的地IP地址, 目的地端口号)</p></li><li><p>当主机接收UDP报文段时:</p><ul><li>在报文段中检查目的地端口号</li><li>将UDP段定向到具有该端口号的套接字</li></ul></li><li><p>具有不同的源IP地址且&#x2F;或源端口号，但具有相同的目的IP地址和目的端口号的IP报文段指向同样的套接</p><p><img src="E:\typora-user-images\image-20220610204317898-1697679581282337.png" alt="image-20220610204317898"></p></li></ul><p>面向连接的多路分解：</p><p>TCP 套接字由4部分指定：源IP地址、源端口号、目的IP地址、目的端口号<br>接收主机使用所有四个值将数据段定位到合适的套接字</p><p>服务器主机支持很多同时的TCP 套接字：每个套接字用4部分来表示</p><p><img src="E:\typora-user-images\image-20220610204516450-1697679581282335.png" alt="image-20220610204516450"></p><h3 id="3-3-无连接传输：UDP"><a href="#3-3-无连接传输：UDP" class="headerlink" title="3.3-无连接传输：UDP"></a>3.3-无连接传输：UDP</h3><p>1、</p><ul><li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</li><li>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</li><li>UDP 是无连接的，即发送数据之前不需要建立连接。</li><li>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</li><li>UDP 没有拥塞控制，很适合多媒体通信的要求。</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li></ul><p>2、</p><ul><li><p>UDP 的首部开销小，只有 8 个字节。</p></li><li><p>UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在加<br>首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，<br>也不拆分，而是保留这些报文的边界。</p></li><li><p>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</p></li><li><p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原<br>封不动地交付上层的应用进程，一次交付一个完整的报文。</p></li><li><p>应用程序必须选择合适大小的报文。</p><p><img src="E:\typora-user-images\image-20220610205449862-1697679581283338.png" alt="image-20220610205449862"></p></li></ul><h4 id="3-3-1-UDP的报文段结构"><a href="#3-3-1-UDP的报文段结构" class="headerlink" title="3.3.1-UDP的报文段结构"></a>3.3.1-UDP的报文段结构</h4><p><img src="E:\typora-user-images\image-20220610205541331-1697679581283340.png" alt="image-20220610205541331"></p><p><img src="E:\typora-user-images\image-20220610214142543-1697679581283339.png" alt="image-20220610214142543"></p><p><img src="E:\typora-user-images\image-20220610205609480-1697679581283341.png" alt="image-20220610205609480"></p><h4 id="3-3-2-UDP校验和"><a href="#3-3-2-UDP校验和" class="headerlink" title="3.3.2-UDP校验和"></a>3.3.2-UDP校验和</h4><p>目标：对传输的数据进行差错检验</p><p>发送方：</p><ul><li>将数据段看成16bit的整数序列</li><li>校验和：段内容进行带循环进位的加法，结果取反码</li><li>发送者将校验和值放入UDP的校验和域</li></ul><p>接受方：</p><ul><li><p>计算接收到的整个报文段的校验和（包括校验和）</p></li><li><p>检查：</p><ul><li>0 ：没有检测到错误</li><li>非0：检测到错误</li></ul><p><img src="E:\typora-user-images\image-20220610214323234-1697679581283344.png" alt="image-20220610214323234"></p></li></ul><h3 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4-可靠数据传输原理"></a>3.4-可靠数据传输原理</h3><p><img src="E:\typora-user-images\image-20220610215041230-1697679581283342.png" alt="image-20220610215041230"></p><h4 id="3-4-1-Rdt1-0"><a href="#3-4-1-Rdt1-0" class="headerlink" title="3.4.1-Rdt1.0"></a>3.4.1-Rdt1.0</h4><p>完全可靠信道上的可靠数据传输<br>在完美可靠的信道上</p><ul><li>没有bit错误</li><li>没有分组丢失</li></ul><p>发送方、接受方单独的FSMs：</p><ul><li><p>发送方发送数据到下层信道</p></li><li><p>接收方从下层信道接受数据</p><p><img src="E:\typora-user-images\image-20220610215125587-1697679581283343.png" alt="image-20220610215125587"></p></li></ul><h4 id="3-4-2-Rdt2-0"><a href="#3-4-2-Rdt2-0" class="headerlink" title="3.4.2-Rdt2.0"></a>3.4.2-Rdt2.0</h4><p>具有bit错误的信道</p><ul><li><p>下层信道可能让传输分组中的bit受损</p><ul><li>校验和将检测到bit错误</li></ul></li><li><p>问题: 如何从错误中恢复</p><ul><li>确认(ACKs): 接收方明确告诉发送方 分组接收正确</li><li>否认 (NAKs):接收方明确告诉发送方 分组接收出错</li><li>发送方收到NAK后重发这个分组</li></ul></li><li><p>在 rdt2.0的新机制 (在 rdt1.0中没有的):</p><ul><li>差错检测</li><li>接收方反馈: 控制信息 (ACK,NAK)</li><li>重传</li></ul><p><img src="E:\typora-user-images\image-20220611101420503-1697679581283345.png" alt="image-20220611101420503"></p><p><img src="E:\typora-user-images\image-20220611101439242-1697679581283346.png" alt="image-20220611101439242"></p><p><img src="E:\typora-user-images\image-20220611101503786-1697679581283347.png" alt="image-20220611101503786"></p><p><img src="E:\typora-user-images\image-20220611102139957-1697679581283348.png" alt="image-20220611102139957"></p></li></ul><h4 id="3-4-3-Rdt2-1"><a href="#3-4-3-Rdt2-1" class="headerlink" title="3.4.3-Rdt2.1:"></a>3.4.3-Rdt2.1:</h4><ul><li><p>发送方</p><ul><li>序号seq # 加入分组中</li><li>两个序号seq. #’s (0,1) 将够用.<br>( 为什么?)</li><li>必须检查是否收到的ACK&#x2F;NAK<br>受损</li><li>状态增加一倍： 状态必须“记住”是否“当前的”分组具有0或1序号</li></ul></li><li><p>接收方</p><ul><li>必须检查是否接收到的分组是冗余的：状态指示是否0或1是所期待的分组序号seq #</li><li>注意: 接收方不能知道是否它的<br>最后的ACK&#x2F;NAK在发送方已经<br>被正确的接收</li></ul><p><img src="E:\typora-user-images\image-20220611133112155-1697679581283349.png" alt="image-20220611133112155"></p><p><img src="E:\typora-user-images\image-20220611133122827-1697679581283350.png" alt="image-20220611133122827"></p></li></ul><h4 id="3-4-4-Rdt2-2"><a href="#3-4-4-Rdt2-2" class="headerlink" title="3.4.4-Rdt2.2"></a>3.4.4-Rdt2.2</h4><p>一个不要NAK的协议</p><ul><li><p>同 rdt2.1一样的功能, 只用 ACKs</p></li><li><p>代替NAK,接收方对最后正确接收的分组发送ACK： 接收方必须明确包含被确认的报文的序号</p></li><li><p>发送方收到重复 ACK 将导致和 NAK一样的处理:<br>重发当前报文</p><p><img src="E:\typora-user-images\image-20220611133216945-1697679581283351.png" alt="image-20220611133216945"></p></li></ul><h4 id="3-4-5-Rdt3-0"><a href="#3-4-5-Rdt3-0" class="headerlink" title="3.4.5-Rdt3.0"></a>3.4.5-Rdt3.0</h4><p>具有出错和丢失的信道</p><p>方法：发送方等待ACK一段“合理的”时间</p><ul><li>如在这段时间没有收到ACK则重传</li><li>如果分组(或ACK)只是延迟(没有丢失)：<ul><li>重传将是冗余的，但序号的使用已经<br>处理了该情况</li><li>接收方必须定义被确认的分组序号</li></ul></li><li>需要倒计时定时器</li></ul><p><img src="E:\typora-user-images\image-20220611133751040-1697679581283352.png" alt="image-20220611133751040"></p><p><img src="E:\typora-user-images\image-20220611133804972-1697679581283353.png" alt="image-20220611133804972"></p><p><img src="E:\typora-user-images\image-20220611133814782-1697679581283354.png" alt="image-20220611133814782"></p><h4 id="3-4-6-流水线技术"><a href="#3-4-6-流水线技术" class="headerlink" title="3.4.6-流水线技术"></a>3.4.6-流水线技术</h4><p>流水线：发送方允许发送多个“在路上的”，还没有确认的报文</p><ul><li>序号数目的范围必须增加</li><li>在发送方&#x2F;接收方必须有缓冲区</li></ul><p>通用形式：</p><ul><li>GO-Back—N<ul><li><img src="E:\typora-user-images\image-20220611134108597-1697679581283355.png" alt="image-20220611134108597"></li><li><img src="E:\typora-user-images\image-20220611134127008-1697679581283356.png" alt="image-20220611134127008"></li><li><img src="E:\typora-user-images\image-20220611134145512-1697679581283357.png" alt="image-20220611134145512"></li><li><img src="E:\typora-user-images\image-20220611134155483-1697679581283358.png" alt="image-20220611134155483"></li><li><img src="E:\typora-user-images\image-20220611134206380-1697679581283359.png" alt="image-20220611134206380"></li></ul></li><li>选择性重传<ul><li>接收方分别确认已经收到的分组：必要时，缓冲报文, 最后按序提交给上层</li><li>发送者只重发没有收到确认的分组：对每个没有确认的报文发送者都要启动一个定时器(每个未被确认的报文都有一个定时器)</li><li>发送窗口<br>N 个连续序号<br>也需要限制已发送但尚未应答分组的序号</li><li><img src="E:\typora-user-images\image-20220611134312402-1697679581283360.png" alt="image-20220611134312402"></li><li><img src="E:\typora-user-images\image-20220611134335283-1697679581283361.png" alt="image-20220611134335283"></li><li><img src="E:\typora-user-images\image-20220611134347234-1697679581283362.png" alt="image-20220611134347234"></li></ul></li></ul><h3 id="3-5-面向连接传输：TCP"><a href="#3-5-面向连接传输：TCP" class="headerlink" title="3.5-面向连接传输：TCP"></a>3.5-面向连接传输：TCP</h3><p>点到点：一个发送方，一个接收方</p><p>面向连接：<br>在进行数据交换前，初始化发送方与接收方状态，进行握手（交换控制信息）<br>连接状态与端系统有关，不为路由器所知</p><p>全双工数据：同一连接上的双向数据</p><p>TCP面向流的概念：</p><p><img src="E:\typora-user-images\image-20220611134834190-1697679581283363.png" alt="image-20220611134834190"></p><p><img src="E:\typora-user-images\image-20220611134841760-1697679581283364.png" alt="image-20220611134841760"></p><h4 id="3-5-1-报文段结构"><a href="#3-5-1-报文段结构" class="headerlink" title="3.5.1-报文段结构"></a>3.5.1-报文段结构</h4><p><img src="E:\typora-user-images\image-20220611135018974-1697679581283365.png" alt="image-20220611135018974"></p><ul><li>源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分解功能都要通过端口才能实现。</li><li>序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据<br>的第一个字节的序号。</li><li>首部长度（即数据偏移）——占 4 位，指示了以32比特的字为单位的TCP首部长度。也就是说，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</li><li>保留字段——占 6 位，保留为今后使用，但目前应置为 0。</li><li>紧急 URG —— 当 URG &#x3D; 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</li><li>确认 ACK —— 只有当 ACK &#x3D; 1 时确认号字段才有效。当ACK &#x3D; 0 时，确认号无效。</li><li>推送 PSH (PuSH) —— 接收 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li><li>复位 RST (ReSeT) —— 当 RST &#x3D; 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li><li>同步 SYN —— 同步 SYN &#x3D; 1 表示这是一个连接请求或连接接受报文。</li><li>终止 FIN (FINis) —— 用来释放一个连接。FIN &#x3D; 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li><li>窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。用于流量控制，用于指示作为接受方，愿意接受的字节量。</li><li>检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li>紧急指针字段 —— 占 16 位，指出紧急数据最后一个字节的位置，也就是指出在本报文段中，紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</li><li>选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”</li><li>其他选项<ul><li>窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。</li><li>时间戳选项——占10 字节，其中最主要的字段时间戳值字段（4字节）和时间戳回送回答字段（4 字节）。</li><li>选择确认选项。</li></ul></li><li>填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。</li></ul><p><img src="E:\typora-user-images\image-20220611141049848-1697679581283366.png" alt="image-20220611141049848"></p><h4 id="3-5-2-TCP-往返时延的估计和超时"><a href="#3-5-2-TCP-往返时延的估计和超时" class="headerlink" title="3.5.2-TCP 往返时延的估计和超时"></a>3.5.2-TCP 往返时延的估计和超时</h4><p>如何设置TCP超时值：</p><ul><li>应比RTT长，但RTT是变化的<ul><li>太短：过早超时，造成不必要的重传</li><li>太长：到数据段丢失响应慢</li></ul></li></ul><p>如何估计RTT：</p><ul><li>样本RTT（SampleRTT）: 测量从报文段发送到收到确认的时间<ul><li>忽略重传</li></ul></li><li>样本RTT会变化，因此需要一个样本RTT均值（Estimated RTT）<br>-平均最近的测量值,并不仅仅是当前SampleRTT</li></ul><p><img src="E:\typora-user-images\image-20220611141350502-1697679581283367.png" alt="image-20220611141350502"></p><p><img src="E:\typora-user-images\image-20220611141458826-1697679581283368.png" alt="image-20220611141458826"></p><p><img src="E:\typora-user-images\image-20220611141526257-1697679581283369.png" alt="image-20220611141526257"></p><h4 id="3-5-3-可靠数据传输机制"><a href="#3-5-3-可靠数据传输机制" class="headerlink" title="3.5.3-可靠数据传输机制"></a>3.5.3-可靠数据传输机制</h4><ul><li>TCP在IP不可靠服务的基础上创建可靠数据传输服务<ul><li>肯定确认和定时器</li><li>序号、重传</li></ul></li><li>流水线发送报文段</li><li>累计确认</li><li>TCP使用单个重传计时器</li><li>重传被下列事件触发:<ul><li>超时事件</li><li>重复ACK</li></ul></li><li>先考虑简化的TCP发送方:<ul><li>忽略重复ACK</li><li>忽略流量控制，拥塞控制</li></ul></li></ul><p>TCP发送方事件：</p><ul><li>1.从应用程序接受数据：<ul><li>根据序号创建一个报文段。</li><li>序号是报文段中第一个数据字节在字节流中的位置编号。</li><li>如果没有启动定时器，则启动定时器 。<ul><li>定时器与最早没有被确认的<br>报文段关联。</li><li>设置超时间隔:<br>TimeOutInterval</li></ul></li></ul></li><li>2.超时：<ul><li>重发导致超时的报文段。</li><li>重新开始定时器</li></ul></li><li>3.收到确认<ul><li>如果确认了还没有确认的报文段<ul><li>更新还没有确认的报文段序<br>号。</li><li>还有已发送而未被确认的报<br>文段，重新开始定时器。</li></ul></li></ul></li></ul><p><img src="E:\typora-user-images\image-20220611142414891-1697679581283370.png" alt="image-20220611142414891"></p><p><img src="E:\typora-user-images\image-20220611142426854-1697679581283371.png" alt="image-20220611142426854"></p><p><strong>快速重传：</strong></p><ul><li>发送方可以在超时之前通过重复的ACK检测丢<br>失报文段<ul><li>发送方常常一个接一个地发送很多报文段</li><li>如果报文段丢失,则发送方将可能接收到很多重复的 ACKs</li></ul></li><li>如果发送方收到3个对同样报文段的冗余确认，则发送方认为该报文段之后的数据已经丢失。<ul><li>启动快速重传: 在定时器超时之前重发丢失<br>的报文段</li></ul></li></ul><p><img src="E:\typora-user-images\image-20220611143716544-1697679581283372.png" alt="image-20220611143716544"></p><p><img src="E:\typora-user-images\image-20220611143754427-1697679581283373.png" alt="image-20220611143754427"></p><p><img src="E:\typora-user-images\image-20220611145433565-1697679581283374.png" alt="image-20220611145433565"></p><p><img src="E:\typora-user-images\image-20220611145453955-1697679581283375.png" alt="image-20220611145453955"></p><p><strong>TCP流量控制：</strong></p><p><img src="E:\typora-user-images\image-20220611145812046-1697679581283376.png" alt="image-20220611145812046"></p><p><img src="E:\typora-user-images\image-20220611145831171-1697679581283378.png" alt="image-20220611145831171"></p><p><strong>TCP连接管理：</strong></p><p>回想: TCP 发送方与接收方在交换报文段前要先建连接</p><ul><li>初始化 TCP 变量:<br>• 序号<br>• 缓冲区和流控信息 (如RcvWindow)</li><li>客户机: 连接的发起方<br>clientSocket.connect((serverName,serverPort));</li><li>服务器: 接受客户请求<br>connectionSocket, addr &#x3D; serverSocket.accept();</li></ul><p>三次握手：</p><ul><li><p>步骤 1: 客户机向服务器发送 TCP SYN报文段<br>• 指定初始序号<br>• 没有数据</p></li><li><p>步骤 2: 服务器收到SYN报文段, 用SYNACK报文段回复<br>• 服务器为该连接分配缓冲区和变量<br>• 指定服务器初始序号</p></li><li><p>步骤 3: 客户机接收到 SYNACK, 分配缓冲，用ACK报文段回复,可能包含数据</p><p><img src="E:\typora-user-images\image-20220611150229078-1697679581283377.png" alt="image-20220611150229078"></p></li></ul><p>关闭连接：</p><ul><li>Step 1: 客户发送 TCP FIN 控制报文段到服务器</li><li>Step 2: 服务器接收 FIN, 回复 ACK. 半关闭连接, 并发送FIN到客户</li><li>Step 3: 客户接收 FIN, 回复 ACK，进入 “timed wait”状态。等待结束时释放连接资源</li><li>Step 4: 服务器接收 ACK. 连接关闭.</li><li><img src="E:\typora-user-images\image-20220611150435861-1697679581284379.png" alt="image-20220611150435861"></li></ul><h3 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6-拥塞控制原理"></a>3.6-拥塞控制原理</h3><p>拥塞:</p><ul><li>从信息角度看: “太多源主机发送太多的数据，速度太快<br>以至于网络来不及处理”</li><li>和流量控制不同:<br>丢失分组 (路由器的缓冲区溢出)<br>长延迟 (在路由器的缓冲区排队)</li></ul><p>两类方法：</p><ul><li>端到端的拥塞控制<ul><li>网路层没有为运算层提供显示的支持。</li><li>从端系统根据观察到的时延和丢失现象推断出拥塞</li><li>这是TCP所采用的方法</li></ul></li><li>网络辅助的拥塞控制<ul><li>路由器为端系统提供反馈<br>• 一个bit指示一条链路出现拥塞(SNA,DECnet)<br>• 指示发送方按照一定速率发送（ATM）<br>• 两种形式</li></ul></li></ul><p><img src="E:\typora-user-images\image-20220611152018737-1697679581284382.png" alt="image-20220611152018737"></p><p><img src="E:\typora-user-images\image-20220611152029168-1697679581284380.png" alt="image-20220611152029168"></p><h3 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7-TCP拥塞控制"></a>3.7-TCP拥塞控制</h3><ul><li><p>1、发送方如何限制其发送速率?</p><p><img src="E:\typora-user-images\image-20220611152203196-1697679581284381.png" alt="image-20220611152203196"></p><p>CongWin：拥塞窗口，RecWin：接受窗口</p></li><li><p>2、发送方如何感知网络拥塞?</p><p><img src="E:\typora-user-images\image-20220611152218305-1697679581284383.png" alt="image-20220611152218305"></p></li><li><p>3、TCP发送方怎样确定它应当发送的速率呢?</p><ul><li>一个丢失的报文段意味着拥塞，应当降低TCP发送速率。</li><li>当收到未确认报文段的确认到达时，能够增加发送方的速率。</li><li>带宽探测：每个TCP发送方根据异步于其他发送的本地信息而行动。</li></ul></li></ul><p>TCP拥塞控制算法：慢启动、拥塞避免、快速恢复</p><ul><li>慢启动</li></ul><p><img src="E:\typora-user-images\image-20220611152626518-1697679581284384.png" alt="image-20220611152626518"></p><p><img src="E:\typora-user-images\image-20220611152709724-1697679581284385.png" alt="image-20220611152709724"></p><ul><li>对拥塞事件的反应</li></ul><p><img src="E:\typora-user-images\image-20220611152823055-1697679581284386.png" alt="image-20220611152823055"></p><p><img src="E:\typora-user-images\image-20220611152946125-1697679581284387.png" alt="image-20220611152946125"></p><p><img src="E:\typora-user-images\image-20220611153009022-1697679581284388.png" alt="image-20220611153009022"></p><p>小结：</p><p><img src="E:\typora-user-images\image-20220611153105855-1697679581284389.png" alt="image-20220611153105855"></p><h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1-概述"></a>4.1-概述</h3><p>发送方主机网络层的作用：</p><ul><li>将来自运输层的每个报文段封装成一个数据报（网络层分组）；</li><li>将数据报向目的地发送，即向相邻的路由器R1发送。</li></ul><p>接收方主机网络层的作用</p><ul><li>接收来自相邻的路由器R2的数据报；</li><li>解封出报文段，并交付给其运输层</li></ul><p><strong>功能：</strong></p><p>将分组从发送主机移动到接受主机</p><ul><li>转发：将分组从路由器的一个输入链路接口转移到一个合适的输出链路接口的本地动作。<ul><li>只涉及分组在路由器中从入链路到出链路的传送。</li><li>通常用硬件实现，与路由器的内部结构有关。</li></ul></li><li>选路：指分组从源到目的地的端到端路径的网络范围动作。<ul><li>涉及网络中的所有路由器，集体经选路协议交互，决定分组从源到目的地的路径。</li><li>通常由软件实现，通过选路算法计算路径。</li></ul></li></ul><p>转发表：每台路由器有一张<br>分组首部（目的地址或某个连接标识）和相应输出链路的对照表</p><p>路由器根据到达分组的首部值在转发表中查询，找到相应的输出链路接口，并将分组转发出去。</p><p><strong>数据平面和控制平面</strong></p><p>数据平面：</p><ul><li>本地的，每个路由器自身的功能</li><li>决定抵达路由器输入端口的数据包如何转发到输出端口</li></ul><p>控制平面：</p><ul><li><p>整个网络范围</p></li><li><p>决定数据报在端到端路径上的路由器之间如何路由</p></li><li><p>两种数据平面的实现方式：<br>•传统的路由算法: 在路由器内实现<br>•软件定义网络（software-defined networking, SDN): 在远程服务器上实现</p><p><img src="E:\typora-user-images\image-20220611194812700-1697679581284390.png" alt="image-20220611194812700"></p></li></ul><p> 分组交换机：一台通用分组交换设备，根据分组首部值，从输入链路接<br>口到输出链路接口传送分组。<br>链路层交换机：根据链路层字段值作转发决定的分组交换机。<br>路由器：根据网络层字段值作转发决定的分组交换机。</p><p><strong>网络层提供的服务</strong></p><ul><li>网络层可能提供的服务<ul><li>确保交付：确保分组到达目的地。</li><li>有序分组交付：按发送顺序到达。</li><li>具有时延上界的确保交付：主机到主<br>机的时延。</li><li>确保最小带宽：当发送主机以低于特定比特率的速率发送比特，分组不会丢失，在一定时延到达。</li><li>确保最大时延抖动：发送方发送两个连续分组的时间间隔与接收到的间隔相同。</li></ul></li><li>因特网的网络层提供的服务<ul><li>单一服务，即尽力而为服务(best-effort service) 。</li><li>分组间的定时不能被保证；</li><li>分组的接收顺序与发送顺序不一定相同；</li><li>传送的分组不能保证最终交付，即网络可能未向目的地交付分<br>组。</li></ul></li></ul><h3 id="4-2-路由器的工作原理"><a href="#4-2-路由器的工作原理" class="headerlink" title="4.2-路由器的工作原理"></a>4.2-路由器的工作原理</h3><h4 id="4-2-1-路由器的整体结构"><a href="#4-2-1-路由器的整体结构" class="headerlink" title="4.2.1-路由器的整体结构"></a>4.2.1-路由器的整体结构</h4><ul><li><p>网络转发功能：</p><p>将分组从路由器的输入链路传送到适当的输出链路</p></li><li><p>路由器的体系结构：</p><p><img src="E:\typora-user-images\image-20220612130705195-1697679581284391.png" alt="image-20220612130705195"></p><ul><li>输入端口功能：<ul><li>第一个线路端接模块：将一条物理链路端接到路由器的物理层；</li><li>第二个数据链路处理模块：实现路由器的数据链路层功能；</li><li>第三个查找与转发模块：实现查找与转发功能，以便分组通过路由器交换结构转发到适当的输出端口；</li></ul></li></ul></li></ul><h4 id="4-2-2-输入端口-查找-x2F-转发模块"><a href="#4-2-2-输入端口-查找-x2F-转发模块" class="headerlink" title="4.2.2-输入端口-查找&#x2F;转发模块"></a>4.2.2-输入端口-查找&#x2F;转发模块</h4><p>确定将一个到达的分组通过交换结构转发给哪个输出端口。 通过查找<br>转发表实现，这里的转发表是存储在输入端口的内存中。</p><p>分散式转发：</p><ul><li>选路处理器计算转发表，给每个输入端口存放一份转发表拷贝。</li><li>在每个输入端口本地做出交换决策，无须激活中央选路处理器。</li><li>可避免在路由器中某个单点产生转发处理瓶颈。</li></ul><p>查表速度：</p><ul><li>查表：搜索转发表，查找最长匹配的表项，若无相应表项找出默认选路表项。</li><li>查找速度：受许多因素影响，如路由器速度、链路速率、查找算法等。</li><li>目标：输入端口的处理速度要超过线路速度。<br>即完成一次查找的时间应少于从输入端口接收一个分组所需的时间（对收到的分组的输入处理在下一个接收操作结束之前完成）。</li></ul><p>查找方法：</p><ul><li><p>线性查找：按顺序找。对庞大的转发表不合适。</p></li><li><p>二分查找：将转发表表项存放在一个树形数据结构中。树的每一层对应目的地址的一个比特，查找某个地址时，从树的根节点开始，依次查地址的每一位。</p><p><img src="E:\typora-user-images\image-20220612131659593-1697679581284392.png" alt="image-20220612131659593"></p></li><li><p>三态内容可寻址内存(TCAM)：是一种特殊的存储阵列。它具有将输入数据与TCAM中存储的所有数据项同时进行比较,迅速判断输入数据是否与TCAM中存储的数据项相匹配,并给出数据项对应地址和匹配信息的特点。将一个32bit IP地址提交给CAM，由它以常数时间返回该地址对应的转发表表项内容。如，MOTOROLA公司的TCAM芯片——MCM69C233。</p></li><li><p>将最近被访问的表项保存在高速缓存(cache)中：</p></li></ul><p>输入端口问题：</p><ul><li>分组阻塞：来自其他输入端口的分组当前正在使用交换结构。被阻塞的分组必须在输入端口处排队，等待以后调度通过交换结构。除查找这个最基本的动作外，在输入端口还必须采取其他动作：<ul><li>必须实现物理层和链路层处理。</li><li>必须检查分组的版本号、检验和以及TTL字段。</li><li>必须更新用于网络的管理的计数器。</li></ul></li></ul><p>交换结构：</p><p>将分组从输入端口缓存交换（转发到恰当的输出端口缓存中）</p><p>三种类型的交换结构：内存、总线、纵横式<br><img src="E:\typora-user-images\image-20220612132131795-1697679581284393.png" alt="image-20220612132131795"></p><ul><li><p>经内存的交换结构：</p><ul><li>早期用计算机作为路由器时采用的结构(第一代)</li><li>输入端口与输出端口之间的交换由CPU(选路处理器)控制完成；</li><li>输入端口与输出端口类似I&#x2F;O设备：<ul><li>当分组到达输入端口时，通过中断向选路处理器发出信号，将分组拷贝到处理器内存中；</li><li>选路处理器根据分组中的目的地址查表找出适当的输出端口，将该分组拷贝到输出端口的缓存中。</li></ul></li><li>交换速度收总线带宽的速度限制（每个分组穿过两次总线）</li><li>若总线带宽为每秒写入或读出B个分组，则总的转发吞吐量 (分组从输入端口被传送到输出端口的总速率)小于B&#x2F;2。<br><img src="E:\typora-user-images\image-20220612133653911-1697679581284394.png" alt="image-20220612133653911"></li></ul></li><li><p>经总线的交换结构：输入端口通过一条共享总线将分组直接传送到输出端口，不需要选路处理器的干预。</p><ul><li>每次只能有一个分组通过总线传送。</li><li>分组到达一个输入端口时，若总线正忙，会被暂时阻塞，在输入端口排队</li><li>路由器交换带宽受总线速率限制。</li></ul></li><li><p>经交换矩阵交换（经互联网络交换）结构：</p><ul><li>纵横式交换机：由2n 条总线组成，n 个输入端口与n 个输出端口连接。</li><li>到达输入端口的分组沿水平总线穿行，直至与所希望的输出端口的垂直总线交叉点：<ul><li>若该条垂直总线空闲，则分组被传送到输出端口；</li><li>否则，该到达的分组被阻塞，必须在输入端口排队。</li></ul></li><li><img src="E:\typora-user-images\image-20220612133938495-1697679581284395.png" alt="image-20220612133938495"></li></ul></li></ul><h4 id="4-2-3-输出端口"><a href="#4-2-3-输出端口" class="headerlink" title="4.2.3-输出端口"></a>4.2.3-输出端口</h4><p>取出存放在输出端口内存中的分组，并将其传输到输出链路上<br>当交换结构将分组交付给输出端口的速率超过输出链路速率，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。</p><ul><li><p>输入端口不排队</p><ul><li>若交换结构的速率至少是输入线路速率的n倍，在输入端口处不会出现排队。</li><li>最坏情况：有n条输入线路同时接收分组。<br>交换结构可以在每个输入端口(同时)接收一个分组的时间内将n个分组从输入端口传送到输出端口。</li></ul></li><li><p>输入端口分组排队</p><ul><li>交换结构比输入端口总和的速度慢 →输入队列产生排队</li><li>交换结构不够快，即相对于输入线路速度不能快得使所有到达的分组无延迟地通过它传送，则在输入端口出现分组排队，等待通过交换结构传送到输出端口。</li></ul></li><li><p>如果采用纵横式交换结构：<br>所有链路速度相同；<br>交换结构速率与输入链路速率相同：分组从输入端口传送到给定输出端口的时间与从输入链路接收一个分组的时间相同；<br>分组按FCFS方式从输入队列移动到输出队列中。<br>结果：</p><ul><li>分组输出端口不同：多个分组可以被并行传送。</li><li>发往相同输出端口：不同输入队列中的分组发往同一输出队列，其中的一些分组被阻塞，在输入队列中等待（交换结构一次传一个分组到端口）。</li></ul><p><img src="E:\typora-user-images\image-20220612134829770-1697679581284396.png" alt="image-20220612134829770"></p></li><li><p>输出端口排队<br>设交换结构的速率至少是线路速率的n倍</p><ul><li>最坏情况：到达每个输入端口的分组都被发往同一个输出端口。<ul><li>在一个单位时间（接收或发送一个分组）内，将有n个分组到达该输出端口，排队(等待)发送到输出链路上；</li><li>在发出队列中一个分组的时间内，又有n个分组到达。依此类推，最终排队的分组快速增长，很快占满输出端口的存储空间，使后续分组被丢弃。</li></ul></li></ul></li></ul><p>分组丢弃方法：</p><p>若缓存已满，丢弃分组。<br>丢弃后到的分组（弃尾）；<br>删除一个或多个已排队的分组；<br>    主动队列管理AQM算法：在缓存填满前丢弃分组或首部加标记，向发送方提供拥塞信号。<br>    如，随机早期检测RED算法： 输出队列长度维护一个加权平均值</p><ul><li>随机早期检测RED算法<br>设最小阈值minth和最大阈值maxth<ul><li>平均队列长度小于最小阈值minth，到达分组被纳入队列；</li><li>队列满或平均队列长度大于最大阈值maxth ，到达分组被标记或丢弃；</li><li>平均队列长度在[minth， maxth]之间，到达分组以某种概率被标记或丢弃</li></ul></li></ul><p>分组调度程序：</p><p>在输出端口排队的分组选出一个发送。</p><p>原则：<br>先来先服务FCFS、优先权排队、加权公平排队WFQ（在具有排队分组的不同端到端连接之间公平地共享输出链路。）</p><ul><li>先来先服务FCFS<ul><li>按到达的顺序发送分组；</li><li>如果分组到达时，没有足够的缓存空间，该如何丢弃分组？<ul><li>尾弃</li><li>基于优先级删除</li><li>随机删除</li></ul></li><li><img src="E:\typora-user-images\image-20220612143301422-1697679581284397.png" alt="image-20220612143301422"></li></ul></li><li>优先权排队<ul><li>输出队列分类为多个具有不同优先级队列；</li><li>根据到达分组的类型，引导到不同优先级的队列中。</li><li>优先发送具有最高优先级队列中的分组；</li><li><img src="E:\typora-user-images\image-20220612143348750-1697679581284398.png" alt="image-20220612143348750"></li></ul></li><li>循环和加权公平队列<ul><li>循环队列规则：<ul><li>输出队列按类分为多个队列，不同类之间没有严格的服务优先权区分。</li><li>根据到达分组的类型，引导到不类别的队列中。</li><li>循环调度器在这些不同类所对应的队列中轮流提供服务。</li><li><img src="E:\typora-user-images\image-20220612143529279-1697679581284399.png" alt="image-20220612143529279"></li></ul></li><li>加权公平排队：<ul><li>WFQ也循环为各个不同类的队列提供服务；</li><li>但是不同类的队列，在每个循环周期中，所获得的服务量并不平等，而是由其权值决定。</li><li><img src="E:\typora-user-images\image-20220612143554735-1697679581284400.png" alt="image-20220612143554735"></li></ul></li></ul></li></ul><h3 id="4-3-网际协议：因特网中的转发和编址"><a href="#4-3-网际协议：因特网中的转发和编址" class="headerlink" title="4.3-网际协议：因特网中的转发和编址"></a>4.3-网际协议：因特网中的转发和编址</h3><h4 id="4-3-1-IP数据报格式"><a href="#4-3-1-IP数据报格式" class="headerlink" title="4.3.1-IP数据报格式"></a>4.3.1-IP数据报格式</h4><p><img src="E:\typora-user-images\image-20220612144451929-1697679581284401.png" alt="image-20220612144451929"></p><p>一个 IP 数据报由首部和数据两部分组成。<br>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。<br>在首部的固定部分的后面是一些可选字段，其长度是可变的。</p><p><img src="E:\typora-user-images\image-20220612150532540-1697679581284402.png" alt="image-20220612150532540"></p><ul><li>版本——占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 (即 IPv4)</li><li>首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)因此 IP 的首部长度的最大值是 60 字节。</li><li>区分服务——占 8 位，用来获得更好的服务在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段区分服务</li><li>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li><li>标识(identification) 占 16 位，它是一个计数器，用来产生数据报的标识</li><li>标志(flag) 占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF &#x3D; 1 表示后面“还有分片”。MF &#x3D; 0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF &#x3D; 0 时才允许分片。</li><li>片偏移(12 位)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</li><li>生存时间(8 位)记为 TTL (Time To Live)数据报在网络中可通过的路由器数的最大值</li><li>协议(8 位)字段指出此数据报携带的数据用于何种协议,以便目的主机的 IP 层将数据部分上交给哪个处理过程<ul><li><img src="E:\typora-user-images\image-20220612150948397-1697679581284403.png" alt="image-20220612150948397"></li></ul></li><li>首部检验和(16 位)字段只检验数据报的首部不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。</li><li>源地址和目的地址都各占 4 字节</li><li>IP 数据报首部的可变部分<ul><li>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。</li><li>选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。</li><li>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。</li><li>实际上这些选项很少被使用</li></ul></li></ul><h4 id="4-3-2-IP数据报分片和重组"><a href="#4-3-2-IP数据报分片和重组" class="headerlink" title="4.3.2-IP数据报分片和重组"></a>4.3.2-IP数据报分片和重组</h4><p>每个数据链路有自己的MTU，链路类型不同，MTU的值也不同，这里MTU指的是数据链路帧的数据区的最大字节数。<br>在因特网中，一个大的分组可能在路由器中被分割为几个分片，在最终的目的主机上，将这些分片重新组装成一个大的分组。<br>为了进一步识别出这些分组，需要对分片进行标识。</p><p><img src="E:\typora-user-images\image-20220612151306382-1697679581284404.png" alt="image-20220612151306382"></p><p><img src="E:\typora-user-images\image-20220612151443525-1697679581284405.png" alt="image-20220612151443525"></p><p>分片的问题：</p><ul><li>分片是有开销的。</li><li>使路由器和端系统更为复杂。</li><li>分片能够被用于生产致命的DoS攻击。</li></ul><h4 id="4-3-3-IP地址"><a href="#4-3-3-IP地址" class="headerlink" title="4.3.3-IP地址"></a>4.3.3-IP地址</h4><p>IP 地址: 分配给主机或路由器接口的标识符<br>接口: 主机&#x2F;路由器与物理链路之间的边界</p><ul><li>路由器有多个接口</li><li>主机可以有多个接口</li><li>每个接口有一个IP地址</li></ul><p>IP地址有两种：IPV4和IPV6</p><ul><li>IPV4：32个二进制位长（4字节），常用点分十进制表示；</li><li>IPV6：128个二进制位长（16字节）常用冒号分隔表示</li></ul><p><strong>IPv4编址</strong></p><p><img src="E:\typora-user-images\image-20220612151803974-1697679581284406.png" alt="image-20220612151803974"></p><p>IP地址结构：</p><p><img src="E:\typora-user-images\image-20220612151856510-1697679581284407.png" alt="image-20220612151856510"></p><ul><li><img src="E:\typora-user-images\image-20220612152245756-1697679581284408.png" alt="image-20220612152245756"></li><li>A类地址<ul><li>A类IP地址的网络号长度为8位，主机号长度为24位；</li><li>A类地址是从：1.0.0.1～127.255.255.254；</li><li>网络号可变长度为7位，从理论上可以有27&#x3D;128个网络；</li><li>网络号为全0和全1（用十进制表示为0与127）的两个地址保留用于特殊目<br>的，实际允许有126个不同的A类网络；</li><li>由于主机号长度为24位，因此每个A类网络的主机IP数理论上为224&#x3D;16777216；</li><li>主机IP为全0和全1的两个地址保留用于特殊目的，每个网段实际允许连接16777214个主机；</li><li>A类IP地址结构适用于有大量主机的大型网络</li></ul></li><li>B类地址<ul><li>B类IP地址的网络号长度为16位，主机号长度为16位；</li><li>B类IP地址是从：128.0.0.1～191.255.255.254；</li><li>由于网络IP可变长度为14位，因此理论允许有214&#x3D;16384个不同的B类网络；</li><li>由于主机IP长度为16位，因此理论上每个B类网络可以有216&#x3D;65536个主机或路由器，实际一个B类IP地址允许连接65534个主机或路由器；</li><li>B类IP地址适用于一些国际性大公司与政府机构等中等大小的组织使用。</li></ul></li><li>C类地址<ul><li>C类IP地址的网络号长度为24位，主机号长度为8位；</li><li>C类IP地址是从：192.0.0.1～223.255.255.254；</li><li>网络号可变长度为21位，因此理论允许有221&#x3D;2097152个不同的C类网络；</li><li>主机号长度为8位，理论上每个C类网络的主机地址数最多为28&#x3D;256个，实际允许连接254个主机或路由器；</li><li>C类IP地址适用于一些小公司与普通的研究机构。</li></ul></li><li>D类地址和E类地址<ul><li>D类IP地址不标识网络;<br>地址范围：224.0.0.0～239.255.255.255<br>用于其他特殊的用途，如多播地址Multicasting；</li><li>E类IP地址暂时保留；<br>地址范围：240.0.0.0～255.255.255.255；<br>用于某些实验和将来使用。</li></ul></li></ul><p>特殊IP地址段：</p><p><img src="E:\typora-user-images\image-20220612152432339-1697679581284409.png" alt="image-20220612152432339"></p><p><img src="E:\typora-user-images\image-20220612152446573-1697679581284412.png" alt="image-20220612152446573"></p><p><img src="E:\typora-user-images\image-20220612152517660-1697679581284410.png" alt="image-20220612152517660"></p><p><strong>互联网中的IP地址</strong></p><ul><li>同一局域网上的主机或路由器的IP地址中的网络号必须相同。用IP术语来说，具有相同网络号的局域网，称为子网。 （ 在因特网文献中 ， 子网也称为 1P 网络或直接称为网络 。 ）</li><li>交换机互连的网络仍然是一个局域网，只能有一个网络号。</li><li>路由器总是具有两个或两个以上IP地址。</li><li>当两个路由器直接相连时，在连线两端的接口处，可以指明<br>IP地址也可以不指明IP地址。</li></ul><p>子网的特点：</p><ul><li>设备接口的IP地址具有同样的网络部分</li><li>没有路由器的介入，物理上能够相互到达</li></ul><p><strong>无类别域间路由CIDR</strong></p><p>传统IP分类方法的问题：<br>⚫一个A类的IP地址，可以有24bit用于分配主机地址，因此可以<br>支持2^24个主机，但是一个家庭或者组织往往不需要这么多的地<br>址空间，造成浪费。<br>⚫ 一个C类的IP地址，只有8bit用于分配主机地址，因此只能支持<br>256个主机，又不太够用。<br>⚫ 因此，按传统IP地址分类方式分配IP被CIDR技术取代</p><p>CIDR：</p><p>⚫CIDR消除了传统的A类、B类和C类地址的概念。<br>⚫使用斜线记法，又称为CIDR记法来区分网络前缀和主机号，即在IP地址后面加上一个斜线“&#x2F;”，斜线后面用一个数字指定网络前缀的长度。地址格式: a.b.c.d&#x2F;x, 这里 x 是地址网络部分的bit数<br>⚫CIDR将网络前缀都相同的连续的IP地址组成“CIDR地址块”。</p><p><img src="E:\typora-user-images\image-20220612153139434-1697679581284411.png" alt="image-20220612153139434"></p><p>子网掩码：</p><p><img src="E:\typora-user-images\image-20220612153230356-1697679581284413.png" alt="image-20220612153230356"></p><p>子网划分总结：</p><ul><li>对于子网划分，建议先把主机数量最多的子网划分了，再划分主机数量较小的子网。</li><li>对于子网划分，一个子网能使用的IP的范围，其起始IP一定是奇数、其截止的IP一定是一个偶数。</li><li>两个主机号相邻的子网，小序号子网的截止IP和大序号子网的起始IP，中间的差值为3，比如上题的223.1.17.65–126和223.1.17.129-254。126和129之间的差值为3，因为其间间隔了两个主机号为全1和全0的IP。</li><li>对于网络号的表示，用于主机的所有bit都要为0，比如： 223.1.17.128&#x2F;25的后面7bit全为0（对应128）、 223.1.17.64&#x2F;26的后面6bit全为0（对应64） 。<br>1000 0000&#x3D;128 1100 0000&#x3D;192 1110 0000&#x3D;224<br>1111 0000&#x3D;240 1111 1000&#x3D;248 1111 1100&#x3D;252<br>1111 1110&#x3D;254</li></ul><p><strong>IP地址的获取</strong></p><ul><li><p>手工指定（保存在系统配置中）</p><ul><li>Windows: 控制面板-&gt;网络</li><li>UNIX&#x2F;LINUX: 在&#x2F;etc&#x2F;rc.config中，可使用ifconfig命令配置</li></ul></li><li><p>DHCP: Dynamic Host Configuration Protocol</p><ul><li>自动从一个DHCP服务器得到IP地址</li><li>方便灵活</li></ul><p><img src="E:\typora-user-images\image-20220612161350930-1697679581284414.png" alt="image-20220612161350930"></p></li></ul><p><img src="E:\typora-user-images\image-20220612161421307-1697679581284415.png" alt="image-20220612161421307"></p><p>DHCP协议的工作过程：</p><ul><li><img src="E:\typora-user-images\image-20220612161603765-1697679581284416.png" alt="image-20220612161603765"></li><li><img src="E:\typora-user-images\image-20220612161630823-1697679581285417.png" alt="image-20220612161630823"></li><li><img src="E:\typora-user-images\image-20220612161646825-1697679581285418.png" alt="image-20220612161646825"></li><li><img src="E:\typora-user-images\image-20220612161705678-1697679581285419.png" alt="image-20220612161705678"></li><li><img src="E:\typora-user-images\image-20220612161723184-1697679581285420.png" alt="image-20220612161723184"></li><li></li></ul><p><img src="E:\typora-user-images\image-20220612161733689-1697679581285421.png" alt="image-20220612161733689"></p><ul><li><p><img src="E:\typora-user-images\image-20220612161755397-1697679581285422.png" alt="image-20220612161755397"></p></li><li><p><img src="E:\typora-user-images\image-20220612161845330-1697679581285423.png" alt="image-20220612161845330"></p></li><li><p><img src="E:\typora-user-images\image-20220612161921001-1697679581285424.png" alt="image-20220612161921001"></p></li><li><p><img src="E:\typora-user-images\image-20220612161950925-1697679581285425.png" alt="image-20220612161950925"></p></li><li><p><img src="E:\typora-user-images\image-20220612162005809-1697679581285426.png" alt="image-20220612162005809"></p></li></ul><p>DHCP中继代理：</p><ul><li>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理(通常是一台路由器)，它配置了 DHCP 服务器的 IP 地址信息。</li><li>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</li></ul><h4 id="4-3-4-NAT网络地址转换"><a href="#4-3-4-NAT网络地址转换" class="headerlink" title="4.3.4-NAT网络地址转换"></a>4.3.4-NAT网络地址转换</h4><p>动机: 对外部网络来讲，本地网络只用一个IP地址<br>• 不需要从 ISP分配一系列地址—— 只要一个IP地址用于所有设备<br>• 在本地网络，改变设备的IP地址不用通知外部世界<br>• 可以变更 ISP ，不用改变本地网络的设备的地址<br>• 本地网络内部设备不能被外部世界明确寻址，或是不可见 (增加了安全性)</p><p><img src="E:\typora-user-images\image-20220612162541615-1697679581285427.png" alt="image-20220612162541615"></p><p>执行NAT，路由器必须做到：</p><ul><li>外出的分组: 替换每个外出的分组的 (源IP 地址, 端口号) 为 (NAT<br>IP 地址, 新端口号)<br>远程客户&#x2F;服务器用(NAT IP地址, 新端口号)作为目的地来响应。</li><li>在NAT转换表中，记录了每个(源IP 地址, 端口号)到 (NAT IP地<br>址, 新端口号) 的对应关系。</li><li>进来的分组: 对每个进来的分组，用保存在NAT表中的对应的(源<br>IP 地址, 端口号) 替换分组中的目的域 (NAT IP 地址, 新端口号）</li></ul><p>限制：</p><p><img src="E:\typora-user-images\image-20220612162907791-1697679581285428.png" alt="image-20220612162907791"></p><p><strong>ICMP因特网控制报文协议</strong></p><p>⚫用于主机路由器之间彼此交流网络层信息<br>        •差错报告: 不可到达的主机, 网络,端口,协议<br>        •请求&#x2F;应答 (用于ping,traceroute)<br>⚫ 位于IP之上<br>        •因为ICMP消息是装载在IP分组里的</p><p><img src="E:\typora-user-images\image-20220612163843092-1697679581285430.png" alt="image-20220612163843092"></p><p><img src="E:\typora-user-images\image-20220612164146711-1697679581285429.png" alt="image-20220612164146711"></p><p><img src="E:\typora-user-images\image-20220612164157622-1697679581285431.png" alt="image-20220612164157622"></p><h4 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5-IPv6"></a>4.3.5-IPv6</h4><p> 初始动机: 32-bit 地址空间即将用尽。<br>其他动机:</p><ul><li>首部格式可帮助加速处理&#x2F;转发</li><li>改变首部利于QoS要求</li></ul><p>首部格式改变:</p><ul><li>IPv6 数据报:扩大的地址容量</li><li>简化高效的 40 字节首部</li><li>流标签</li></ul><p><strong>IPv6首部：</strong></p><p>流量类型:表示流中分组的优先级,类似IPv4中的TOS字段，可用于给出给出一个流中某些数据的优先级。<br>流标签: 表示分组在同一个 “流”中 (“流”的概念尚未完全定义).<br>下一个首部: 表示数据的上层协议，类似IPv4中的协议字段。</p><p><img src="E:\typora-user-images\image-20220612164425620-1697679581285432.png" alt="image-20220612164425620"></p><p><strong>IPv6对址表示：</strong></p><p><img src="E:\typora-user-images\image-20220612164636126-1697679581285435.png" alt="image-20220612164636126"></p><p>地址分类：</p><ul><li>单播地址：一个单播地址对应一个接口，发往单播地址的数据包会被对应的接口接收。</li><li>多播(组播)地址：一个组播地址对应一组接口，发往组播地址的数据包会被这组的所有接口接收；目的地为多个主机的数据包在特殊的多播地址上发送。 所有对该组播信息感兴趣的主机需要首先加入该组播组。 加入组的所有接口接收组播数据包并对其进行处理，而对组播数据不感兴趣的其他主机则忽略组播信息。</li><li>任播地址：一个任播地址对应一组接口，发往任播地址的数据包会被这组接口的其中一个接收，被哪个接口接收由具体的路由协议确定；（IPv6不使用广播地址，广播地址的功能由多播地址代替。）</li></ul><p><img src="E:\typora-user-images\image-20220612165132665-1697679581285433.png" alt="image-20220612165132665"></p><p><img src="E:\typora-user-images\image-20220612165147663-1697679581285434.png" alt="image-20220612165147663"></p><p>IPv4到IPv6的过渡：</p><ul><li><p>并不是所有的路由器都能够同时升级</p><ul><li>没有 “标志日”</li><li>同时有 IPv4 和 IPv6 路由器的网络如何工作?</li></ul></li><li><p>两种推荐方法:</p><ul><li><p>双栈：一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换</p><p><img src="E:\typora-user-images\image-20220612165259366-1697679581285436.png" alt="image-20220612165259366"></p></li><li><p>隧道: 在穿过IPv4路由器时，IPv6分组作为 IPv4分组的负载</p><p><img src="E:\typora-user-images\image-20220612165320156-1697679581285437.png" alt="image-20220612165320156"></p></li></ul></li></ul><h3 id="4-4-路由和选路算法"><a href="#4-4-路由和选路算法" class="headerlink" title="4.4-路由和选路算法"></a>4.4-路由和选路算法</h3><h4 id="4-4-1-选路算法"><a href="#4-4-1-选路算法" class="headerlink" title="4.4.1-选路算法"></a>4.4.1-选路算法</h4><p>默认路由器：与主机直接相连的路由器，又叫第一跳路由器。每当主机发送一个分组时，都先传送给它的默认路由器。</p><ul><li>源路由器：源主机的默认路由器。</li><li>目的路由器：目的主机的默认路由器。</li><li>从源主机到目的主机的选路归结为从源路由器到目的路由器的选路。</li></ul><p>路由算法：是确定一个分组从源路由器到目的路由器所经路径的算法</p><p>路由算法的关键：在给定的一组路由器以及连接路由器的链路中，找到一条从源路由器到目的路由器的“好”路径。</p><p>路由算法分类：</p><ul><li><p>1</p><ul><li><p>全局选路算法</p><p><img src="E:\typora-user-images\image-20220612165809838-1697679581285438.png" alt="image-20220612165809838"></p></li><li><p>分散式选路算法</p><p><img src="E:\typora-user-images\image-20220612165825979-1697679581285439.png" alt="image-20220612165825979"></p></li></ul></li><li><p>2</p><ul><li>静态选路算法：路由确定后基本不再变化。当人工干预调整时，可能有一些变化。</li><li>动态选路算法：当网络的流量负载或拓扑发生变化时，改变路径。可以周期性地或直接地响应拓扑或链路费用的变化。易受选路循环、路由振荡之类问题的影响。</li></ul></li><li><p>3</p><ul><li>负载敏感算法：链路费用会动态地变化，反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路被赋以高费用，则选路算法应绕开该拥塞链路来选择路由。如早期的ARPAnet选路算法。</li><li>负载迟钝算法：某条链路的费用一般不反映其当前的(或最近的)拥塞级别。如因特网的选路算法。</li></ul></li></ul><h4 id="4-4-2-链路状态选路算法LS"><a href="#4-4-2-链路状态选路算法LS" class="headerlink" title="4.4.2-链路状态选路算法LS"></a>4.4.2-<strong>链路状态选路算法</strong>LS</h4><p>一种全局选路算法</p><p>前提条件：已知网络拓扑和所有链路的费用，作为算法的输入。</p><p>获取方法：每个节点向网络中广播链路状态分组（含有它所连接的链路的费用）。<br>        由链路状态广播算法实现。最终使所有节点都有一个相同且完整的网络视图。</p><p>每个节点都可以运行链路状态算法并计算出最低费用路径集。</p><p>计算从某节点（源节点，如u）到网络中所有其他节点的最低费用路径。</p><p>是一种迭代算法，即：<br>        经第k次迭代后，可知道到k个目的节点的最低费用路径。</p><p>基本思想：<br>        以源节点为起点，每次找出一个到源节点的费用最低的节点，直到把所有的目的节点都找到为止</p><p><strong>术语定义：</strong></p><p>c(x,y)：表示从节点x到y的链路费用;&#x3D; ∞ 如果不是直接邻居<br>D(v)：表示从源节点到目的节点v的当前路径的费用；<br>p(v)：表示从源节点到目的节点v的路径上的前驱节点(例如w是v的前驱<br>节点)；<br>N’：表示已经找到最低费用路径的节点集合。</p><p><img src="E:\typora-user-images\image-20220612171029381-1697679581285440.png" alt="image-20220612171029381"></p><p><img src="E:\typora-user-images\image-20220612171345554-1697679581285441.png" alt="image-20220612171345554"></p><p><img src="E:\typora-user-images\image-20220612171357267-1697679581285442.png" alt="image-20220612171357267"></p><p><strong>算法描述：</strong></p><p><img src="E:\typora-user-images\image-20220612171738236-1697679581285443.png" alt="image-20220612171738236"></p><p><img src="E:\typora-user-images\image-20220612171751812-1697679581285444.png" alt="image-20220612171751812"></p><p>例子：</p><p><img src="E:\typora-user-images\image-20220612171910298-1697679581285445.png" alt="image-20220612171910298"></p><p>构建从源节点到所有节点的路径：</p><p><img src="E:\typora-user-images\image-20220612172333742-1697679581285446.png" alt="image-20220612172333742"></p><p>构建最低费用路径树：</p><p><img src="E:\typora-user-images\image-20220612172400158-1697679581285447.png" alt="image-20220612172400158"></p><p>构建转发表：</p><p><img src="E:\typora-user-images\image-20220612172418115-1697679581285448.png" alt="image-20220612172418115"></p><p>注意事项：</p><p><img src="E:\typora-user-images\image-20220612172448926-1697679581286449.png" alt="image-20220612172448926"></p><p>讨论：</p><ul><li><p>计算复杂度：</p><p><img src="E:\typora-user-images\image-20220612172640702-1697679581286450.png" alt="image-20220612172640702"></p></li><li><p>可能产生振荡：</p><p><img src="E:\typora-user-images\image-20220612172711518-1697679581286451.png" alt="image-20220612172711518"></p><p><img src="E:\typora-user-images\image-20220612172956657-1697679581286452.png" alt="image-20220612172956657"></p></li><li><p>避免振荡：</p></li><li><p><img src="E:\typora-user-images\image-20220612173006621-1697679581286453.png" alt="image-20220612173006621"></p></li></ul><h4 id="4-4-3-距离向量路由算法DV"><a href="#4-4-3-距离向量路由算法DV" class="headerlink" title="4.4.3-距离向量路由算法DV"></a>4.4.3-距离向量路由算法DV</h4><p>距离向量路由算法是一种迭代的、异步的和分布式的算法。</p><ul><li>分布式：每个节点都从其直接相连邻居接收信息，进行计算，再将<br>计算结果分发给邻居。</li><li>迭代：计算过程一直持续到邻居之间无更多信息交换为止。</li><li>异步：不要求所有节点相互之间步伐一致地操作。</li><li>自我终结：算法能自行停止。</li></ul><p>最低费用表示：</p><p><img src="E:\typora-user-images\image-20220612180926688-1697679581286454.png" alt="image-20220612180926688"></p><p>举例：</p><p><img src="E:\typora-user-images\image-20220612181507837-1697679581286455.png" alt="image-20220612181507837"></p><p><strong>基本思想：</strong></p><p><img src="E:\typora-user-images\image-20220612181639350-1697679581286456.png" alt="image-20220612181639350"></p><p>距离向量表：</p><p><img src="E:\typora-user-images\image-20220612181803265-1697679581286457.png" alt="image-20220612181803265"></p><p>基本过程：</p><p><img src="E:\typora-user-images\image-20220612181902378-1697679581286458.png" alt="image-20220612181902378"></p><p><img src="E:\typora-user-images\image-20220612181938319-1697679581286459.png" alt="image-20220612181938319"></p><ul><li><p><img src="E:\typora-user-images\image-20220612182042025-1697679581286460.png" alt="image-20220612182042025"></p></li><li><p><img src="E:\typora-user-images\image-20220612182055600-1697679581286461.png" alt="image-20220612182055600"></p></li><li><p><img src="E:\typora-user-images\image-20220612182120152-1697679581286462.png" alt="image-20220612182120152"></p></li><li><p><img src="E:\typora-user-images\image-20220612182142035-1697679581286463.png" alt="image-20220612182142035"></p></li></ul><p>例：</p><p><img src="E:\typora-user-images\image-20220612182301884-1697679581286464.png" alt="image-20220612182301884"></p><ul><li>多次重复从邻居接收更新距离向量、重新计算选路表项、并向<br>邻居发送更新通知的过程，一直持续到没有更新报文发出为止。</li><li>算法进入静止状态，直到某个链路费用发生改变为止。</li></ul><p><strong>链路费用改变与链路故障</strong></p><p>当一个节点检测到从它到邻居的链路费用发生变化时，就更新其距离向量，如果最低费用路径的费用发生变化，通知其邻居。</p><ul><li><p>某链路费用减少时情况</p><p><img src="E:\typora-user-images\image-20220612182509746-1697679581286465.png" alt="image-20220612182509746"></p><p><img src="E:\typora-user-images\image-20220612182521131-1697679581286466.png" alt="image-20220612182521131"></p></li><li><p>某链路费用增加使情况</p><p><img src="E:\typora-user-images\image-20220612182549312-1697679581286467.png" alt="image-20220612182549312"></p><p><img src="E:\typora-user-images\image-20220612182652645-1697679581286468.png" alt="image-20220612182652645"></p><p><img src="E:\typora-user-images\image-20220612182834085-1697679581286469.png" alt="image-20220612182834085"></p><p><img src="E:\typora-user-images\image-20220612182845155-1697679581286470.png" alt="image-20220612182845155"></p></li></ul><p>毒性逆转：</p><p>假如 Z通过 Y 到达 X ，则Z告诉Y：它到X的距离是无穷大，Y将不会再经过Z到X</p><p><img src="E:\typora-user-images\image-20220612183030528-1697679581286471.png" alt="image-20220612183030528"></p><p><strong>LS算法与DV算法比较</strong></p><ul><li>消息复杂度<ul><li>LS算法：知道网络每条链路的费用，需发送O(nE)个报文；当一条链路的费用变化时，必须通知所有节点</li><li>DV算法：迭代时，仅在两个直接相连邻居之间交换报文；当链路费用改变时，只有该链路相连的节点的最低费用路径发生改变时，才传播已改变的链路费用。</li></ul></li><li>收敛速度：<ul><li>LS算法：需要O(nE)个报文和O(n^2)的搜寻，可能会振荡</li><li>DV算法：收敛较慢。可能会遇到选路回环，或计数到无穷的问题。</li></ul></li><li>健壮性：当一台路由器发生故障、操作错误或受到破坏时，会发生什么情况?<ul><li>LS算法：路由器向其连接的一条链路广播不正确费用，路由计算基本独立（仅计算自己的转发表），有一定健壮性。</li><li>DV算法：一个节点可向任意或所有目的节点发布其不正确的最低费用路径，一个节点的计算值会传递给它的邻居，并间接地传递给邻居的邻居。一个不正确的计算值会扩散到整个网络。</li></ul></li></ul><h4 id="4-4-4-层次选路"><a href="#4-4-4-层次选路" class="headerlink" title="4.4.4-层次选路"></a>4.4.4-层次选路</h4><p>自治系统AS：按区域划分的系统。每个AS由一组在相同控制管理下的路由器组成，同一个AS内的路由器可运行相同的选路算法，且拥有相互之间的信息。</p><p>层次选路：</p><ul><li>将一个大的系统划分成若干小系统（自治系统），</li><li>按区域或自治系统的形式组织路由器。</li><li>自治系统之间再互连。</li></ul><p>自治系统内部选路协议：在一个自治系统运行的选路算法</p><p>网关路由器：互连各AS，负责转发目的地在本AS之外的分组（将本AS内的分组转发到另一个AS的路由器）</p><p>自治系统间选路协议：在各AS之间进行选路的选路算法。将分组从一个AS选路到另一个AS</p><p>路由器转发表：由AS内部选路协议和AS间选路协议产生。</p><p><img src="E:\typora-user-images\image-20220612184432016-1697679581286472.png" alt="image-20220612184432016"></p><p>例：</p><p><img src="E:\typora-user-images\image-20220612203027647-1697679581286473.png" alt="image-20220612203027647"></p><p><img src="E:\typora-user-images\image-20220612203037162-1697679581286474.png" alt="image-20220612203037162"></p><p><img src="E:\typora-user-images\image-20220612203052725-1697679581286475.png" alt="image-20220612203052725"></p><p><img src="E:\typora-user-images\image-20220612203134778-1697679581286477.png" alt="image-20220612203134778"></p><p>自治系统的优点：</p><ul><li>减少规模大的网络选路计算的复杂性：<ul><li>AS内部路由器运行相同的自治系统内部选路协议，仅需要知道本AS内的路由器与网关路由器。</li><li>各AS之间，运行相同的AS间选路协议。</li></ul></li><li>管理职权灵活：<ul><li>一个组织可自行选择AS内部选路协议，每对相连的AS运行相同<br>AS间选路协议，交换信息</li></ul></li></ul><p><strong>AS内部选路协议</strong></p><p>RIP选路信息协议：基于距离向量的路由协议</p><p>OSPF(Open Shortest Path First)开放最短路径优先：采用采用Dijkstra最短费用路径算法，是一种链路状态协议（？LS算法）</p><ul><li>open”: 开放、公用的</li><li>用链路状态算法<br>• 采用洪泛链路状态信息，分发LS 分组<br>• 每个节点具有网络拓扑图<br>• 路由计算使用 Dijkstra算法</li><li>每个router都以洪泛的方式广播OSPF通告，OSPF通告里为每个邻<br>居路由器设一个表项（记录每个邻居的链路特征和费用）。</li><li>通告会散布到整个自治系统 (通过洪泛法)<br>• OSPF信息直接通过 IP传输 (不是 TCP 或 UDP）</li></ul><p>OSPF的优点：</p><ul><li>安全: 所有OSPF 消息需要认证 (防止恶意入侵)</li><li>允许多个相同开销的路径 (在 RIP中只有一条路径)</li><li>单播和多播综合支持: 多播 OSPF (MOSPF) 使用和 OSPF同样的链路数据库</li><li>在大的区域中使用层次 OSPF</li></ul><p><img src="E:\typora-user-images\image-20220612204444656-1697679581286476.png" alt="image-20220612204444656"></p><p><strong>AS间选路协议</strong></p><p>BGP (Border Gateway Protocol)边界网关协议：基于距离向量的路由协议。相邻BGP路由器相互交换路径信息。</p><p>BGP 为每个 AS 提供了一种手段:</p><ul><li>从相邻AS获取子网可达信息</li><li>向该AS内部的所有路由器传播这些可达性信息</li><li>基于该可达信息和AS策略，决定到达子网的“好”路由</li></ul><p>允许一个子网向Internet的其他部分通告它的存在 “I<br>am here”</p><p>路由器对（BGP对等方）通过TCP连接来交换选路信息：BGP 会话<br>BGP会话和物理链路无关（是TCP连接，并不总是和某条物理链路对应）。<br>在BGP中，目的地不是主机地址，而是CIDR化前缀。<br>        当AS2通告一个前缀给AS1,说明AS2能够转发目的地址前缀，是具有这个通告前缀 的所有分组。</p><p>例：</p><p><img src="E:\typora-user-images\image-20220612205145942-1697679581286478.png" alt="image-20220612205145942"></p><ul><li><p>路径属性和BGP路由</p><ul><li>当通告前缀时，通告包含了BGP属性.</li><li>前缀+属性&#x3D;“路由”</li><li>两个重要的属性:<ul><li>AS-PATH: 包含了前缀的通告已经通告过的那些AS,如 AS 67 AS 17</li><li>NEXT-HOP: 指出到达下一个AS的具体AS间边界路由器（可能存在多条从当前AS到达下一个AS的链路）</li></ul></li><li>当网关路由器接收到路由通告时，使用输入策略来决定接收&#x2F;舍弃该<br>通告。</li></ul></li><li><p>BGP路由选择</p><ul><li>路由器可能知道到相同前缀的多条路由，路由器必须从中选择.</li><li>排除规则（应用排除规则直到有一条留下）<ul><li>本地偏好值属性: 具有最高偏好值的路由被选择</li><li>最短AS-PATH的路由 （使用AS跳数）</li><li>最靠近 NEXT-HOP路由器的路由 : 热土豆路由（AS内部路由算法决定）。</li><li>其他标准</li></ul></li></ul></li></ul><p>IP任播：</p><p><img src="E:\typora-user-images\image-20220612205737512-1697679581287479.png" alt="image-20220612205737512"></p><ul><li><p>BGP选路策略：</p><p><img src="E:\typora-user-images\image-20220612205810058-1697679581287480.png" alt="image-20220612205810058"></p><p><img src="E:\typora-user-images\image-20220612234712324-1697679581287481.png" alt="image-20220612234712324"></p></li></ul><p>为什么AS内选路和AS间选路采用不同的协议？</p><ul><li>策略:<ul><li>AS间: 管理员想控制本AS内产生的通信流怎样选路，以及什么通信流穿过自己的网络</li><li>AS内:单个管理者, 因此不需要策略</li></ul></li><li>规模:<ul><li>层次路由节省了转发表的大小空间，减少了路由更新的流量</li></ul></li><li>性能:<ul><li>AS内: 集中在性能上</li><li>AS间: 策略可能比性能更加重</li></ul></li></ul><h4 id="4-4-5-SDN"><a href="#4-4-5-SDN" class="headerlink" title="4.4.5-SDN"></a>4.4.5-SDN</h4><p>软件定义网络(SDN,SoftwareDefinedNetwork):源自美国斯坦福大学CLeanState研究组提出的一种新型网络创新架构，可通过软件编程的形式定义和控制网络，具有控制平面和转发平面分离及开放性可编程的特点。</p><p>SDN的核心理念是，希望应用软件可以参与对网络的控制管理，满足上层业务需求，通过自动化业务部署，简化网络运维。</p><p>SDN并不是一个具体的技术，它是一种网络设计理念，规划了网络的各个组成部分（软件、硬件、转发面和控制面）及相互之间的互动关系。</p><p>核心思想：建立一个通用转发体系<br>每个交换设备包含一个流表，流表有一个逻辑上中心化的控制器（远程控制器）来计算和分发<br><img src="E:\typora-user-images\image-20220612235128657-1697679581287482.png" alt="image-20220612235128657"></p><p>通用转发和SDN：<br><img src="E:\typora-user-images\image-20220612235322266-1697679581287483.png" alt="image-20220612235322266"></p><p><img src="E:\typora-user-images\image-20220612235334593-1697679581287485.png" alt="image-20220612235334593"></p><p><strong>OpenFLow数据平面抽象</strong></p><p><img src="E:\typora-user-images\image-20220612235418522-1697679581287484.png" alt="image-20220612235418522"></p><p>流表条目：</p><p><img src="E:\typora-user-images\image-20220612235736874-1697679581287486.png" alt="image-20220612235736874"></p><p>数据平面抽象：</p><p><img src="E:\typora-user-images\image-20220612235803404-1697679581287487.png" alt="image-20220612235803404"></p><p><img src="E:\typora-user-images\image-20220612235810915-1697679581287488.png" alt="image-20220612235810915"></p><p>SDN体系结构及特征：</p><p><img src="E:\typora-user-images\image-20220612235858360-1697679581287489.png" alt="image-20220612235858360"></p><p>SDN控制器的组件：</p><p><img src="E:\typora-user-images\image-20220612235930842-1697679581287490.png" alt="image-20220612235930842"></p><h2 id="第五章-链路层"><a href="#第五章-链路层" class="headerlink" title="第五章 链路层"></a>第五章 链路层</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1-概述"></a>5.1-概述</h3><p>节点node：主机、交换机和路由器、WIFI接入点等。</p><p>链路link：连接相邻节点的通信信道，包括：有线链路、无线链路、局域网</p><p>数据链路层的职责：将分组通过一个链路，从一个节点传输到临近的另一个节点。</p><p>链路层协议：用来在单段链路上传输分组。（定义了在链路两端的节点之间交互的分组格式，以及当发送和接受分手时节点采取的动作）</p><ul><li>交换的数据单元称为帧frame，封装了一个网络层的数据报。</li><li>所采取的动作：包括差错检测、重传、流量控制和随机访问</li><li>典型协议：以太网、802.11无线LAN、令牌环和PPP</li></ul><p>类比：</p><ul><li>数据报可以在不同的链路上，通过不同的链路层协议发送</li><li>每个链路层协议提供不同的服务（可以提供&#x2F;不提供可靠数据传输服务）</li></ul><p><strong>链路层提供的服务：</strong></p><ul><li><p>封装成帧</p><ul><li>封装数据报为数据帧，增加头部，尾部信息，再传送到链路上</li><li>不同的链路层协议，帧格式可能不同</li></ul></li><li><p>链路访问</p><ul><li>有媒体访问MAC协议定义帧在链路上传输的规则<ul><li>点对点链路：一个发送方和一个接收方，MAC协议比较简单（或不存在），即任何时候只要链路空闲，发送方都能够发送帧</li><li>广播链路：多个节点共享一个链路（多路访问），使用MAC协议协调多个节点的帧传输</li></ul></li></ul></li><li><p>在相邻节点之间可靠交付</p><ul><li>保证网络层的数据报无差错地通过链路层</li></ul></li><li><p>流量控制</p><ul><li>用于控制发送节点向直接相连的接受节点发送数据帧的频率</li></ul></li><li><p>差错检查</p><ul><li>差错可能有信号衰减、噪声引入</li><li>接收方检测是否出现错误<ul><li>通知发送方重传或丢弃数据帧</li></ul></li></ul></li><li><p>错误纠正</p><ul><li>接收方标识和纠正比特错误，而不需要请求重传</li></ul></li><li><p>半双工和全双工</p><ul><li>在半双工模式，链路的两个节点都可以发送数据，但是不能同时发送</li></ul></li></ul><p><strong>链路层实现的位置</strong></p><ul><li>在主机和网络设备(路由器)上实现</li><li>在主机上，链路层的主体部分是在网络适配器上实现的(称为网卡)<ul><li>以太网卡，802.11卡；以太网芯<br>片组</li><li>实现链路层和物理层的功能</li></ul></li><li>硬件、软件、固件的组合</li></ul><p>网络适配器：</p><ul><li>发送方<ul><li>封装数据报为数据帧</li><li>增加差错检测比特，可靠数据传输，流量控制等机制</li></ul></li><li>接收方<ul><li>执行检查错误、可靠数据传输、流量控制等机制</li><li>抽取数据报，将其递交给上层</li></ul></li></ul><h3 id="5-2-差错检测和纠错"><a href="#5-2-差错检测和纠错" class="headerlink" title="5.2-差错检测和纠错"></a>5.2-差错检测和纠错</h3><p>错误检测不是100%可靠<br>协议有可能漏掉一些错误，但很少<br>大的校验信息能提供更好的检错能力<br><img src="E:\typora-user-images\image-20220613135225569-1697679581287491.png" alt="image-20220613135225569"></p><p>三种主要差错检测技术：奇偶检验、Internet校验和、循环冗余检测</p><h4 id="5-2-1-比特奇偶校验"><a href="#5-2-1-比特奇偶校验" class="headerlink" title="5.2.1-比特奇偶校验"></a>5.2.1-比特奇偶校验</h4><ul><li>发送方<ul><li>在要发送的信息D（d位）后面附加一个奇偶校验位 使“1”的个数是奇数（奇校验）或偶数（偶校验）</li><li>一起传输发送（d+1位）。</li></ul></li><li>接收方<ul><li>检测收到的信息（d+1位）中“1”的个数。</li><li>偶校验：发现奇数个“1”，至少有一个比特发生差错（奇数个比特差错）。</li><li>奇校验：发现偶数个“1”，至少有一个比特发生差错。</li></ul></li></ul><p>可以查出任意奇数个错误，但不能发现偶数个错误。<br>若比特差错概率很小，差错独立发生，一比特奇偶校验可满足要求。<br>若差错集中一起“突发”（突发差错），一帧中未检测到的差错的概率达到50%。</p><p>二维奇偶校验</p><p>基本思想：</p><ul><li>将要传信息D（d比特）划分为i行j列（i 个组，每组j位）；</li><li>对每行和每列分别计算奇偶值；</li><li>结果的i+j+1个奇偶比特构成了帧的差错检测比特。</li></ul><p>例：</p><p><img src="E:\typora-user-images\image-20220613141603530-1697679581287492.png" alt="image-20220613141603530"></p><h4 id="5-2-2-Interntet校验和方法"><a href="#5-2-2-Interntet校验和方法" class="headerlink" title="5.2.2-Interntet校验和方法"></a>5.2.2-Interntet校验和方法</h4><p>发送方：</p><ul><li>将数据的每两个字节当作一个16位的整数，可分成若干整数；</li><li>将所有16 位的整数求和（带进位位回卷求和）；</li><li>对得到的和逐位取反，作为检查和，放在报文段首部，一起发送。</li></ul><p>接收方：</p><ul><li>对接收到的信息 (包括检查和)按与发送方相同的方法求校验和。<ul><li>全“0”：收到的数据无差错；</li><li>其中有“1”：收到的数据出现差错</li></ul></li></ul><p>特点：</p><ul><li>分组开销小：检查和位数比较少；</li><li>差错检测能力弱：</li><li>适用于运输层（差错检测用软件实现，检查和方法简单、快速）。</li><li>链路层的差错检测由适配器中专用的硬件实现，采用更强的CRC方法。</li></ul><h4 id="5-2-3-循环冗余检测"><a href="#5-2-3-循环冗余检测" class="headerlink" title="5.2.3- 循环冗余检测"></a>5.2.3- 循环冗余检测</h4><p>计算机网络中广泛采用</p><ul><li>循环冗余检测CRC (cyclic redundancy check)编码：<ul><li>即多项式编码，把要发送的比特串看作为系数是0或1的一个多项式，</li><li>对比特串的操作看作为多项式运算。</li></ul></li><li>基本思想：<ul><li>设发送节点要把数据D（ d 比特）发送 给接收节点。</li><li>发送方和接收方先共同选定一个生成多项式 G（r+1比特），最高有效位 (最左边)是1。</li></ul></li></ul><p>发送方：</p><ul><li>计算出一个r位附加比特R，添加到D的后面产生DR（d+r 比特）</li><li>DR能被生成多项式G模2运算整除，一起发送</li></ul><p>接收方：</p><ul><li>用生成多项式G去除接收到的DR（d+r比特）<ul><li>余数非0：传输发生差错；</li><li>余数为0：传输正确，去掉尾部r位，得所需数据D。</li></ul></li></ul><p>模2运算：</p><p><img src="E:\typora-user-images\image-20220613160717438-1697679581287493.png" alt="image-20220613160717438"></p><p>计算R：<br><img src="E:\typora-user-images\image-20220613160840109-1697679581287494.png" alt="image-20220613160840109"></p><p>例：</p><p><img src="E:\typora-user-images\image-20220613161003703-1697679581287495.png" alt="image-20220613161003703"></p><p><img src="E:\typora-user-images\image-20220613161012503-1697679581288496.png" alt="image-20220613161012503"></p><p>特点：</p><p><img src="E:\typora-user-images\image-20220613161103087-1697679581288497.png" alt="image-20220613161103087"></p><p>差错检测方法比较：</p><ul><li>奇偶校验能力最弱，CRC校验能力最强。</li><li>奇偶校验通常用于简单的串口通信</li><li>Internet校验和通常用于网络层及其之上的层次，要求简单快速的<br>软件实现方式</li><li>CRC通常应用于链路层，一般由适配器硬件实现</li></ul><h3 id="5-3-多路访问链路和协议"><a href="#5-3-多路访问链路和协议" class="headerlink" title="5.3-多路访问链路和协议"></a>5.3-多路访问链路和协议</h3><p>广播：任何一个节点传输一个帧时，信号在信道上广播，其他节点都可以收到一个拷贝。</p><p>多路访问问题：如何协调多个发送和接受节点对共享广播信道的访问。相关技术即是多辆是访问协议（也称多址访问协议）</p><h4 id="5-3-1-多路访问协议"><a href="#5-3-1-多路访问协议" class="headerlink" title="5.3.1-多路访问协议"></a>5.3.1-多路访问协议</h4><p>目的：协调多个节点在共享信道上的传输</p><ul><li>避免多个节点同时使用信道，发生冲突（碰撞），产生互相干扰</li></ul><p>冲突：两个以上的节点同时传输帧，使接受方收不到正确的帧（所有的冲突的帧都受损丢失）</p><ul><li>造成广播信道时间的浪费</li><li>多路访问协议可用于许多不同的网络环境，如有线和无线局域网、卫星网等</li></ul><p>共享信道既要负责进行数据传输，又要负责分布式算法的控制信息的传输（没有带外信道传输控制信息）</p><p>三类多路访问协议：</p><ul><li>信道划分协议 <ul><li>把信道划分为小“片”（）时隙</li><li>给节点分配专用的小“片”</li></ul></li><li>随机访问协议<ul><li>不划分信道，允许冲突</li><li>能从冲突中“恢复”</li></ul></li><li>轮流协议<ul><li>通过轮流访问信道避免冲突，要发送的节点越多轮流时间越长</li></ul></li></ul><p><strong>信道划分协议</strong></p><p>包括：TDMA、FDMA、CDMA三种</p><ul><li>时分多路访问TDMA：将时间划分为时间帧，每个时间帧再划分为N个时隙（长度保证发送一个分组），分别分配给N个节点。每个节点只在固定分配的时隙中传输。<br><img src="E:\typora-user-images\image-20220613162412684-1697679581288498.png" alt="image-20220613162412684"><ul><li>特点：<ul><li>避免冲突、公平</li><li>节点速率优先</li><li>效率不高</li></ul></li></ul></li><li>频分多路访问FDMA：将总信道带宽 R b&#x2F;s划分为 N 个较小信道（频段，带宽为R&#x2F;N），分别分配给N 个节点。<br><img src="E:\typora-user-images\image-20220613162601336-1697679581288499.png" alt="image-20220613162601336"></li><li>码分多路访问CDMA：<br>每个节点分配一个唯一的编码<br>每个节点用它唯一的编码来对它发送的数据进行编码<br>允许多个节点“共存”，信号可叠加，既可以同时传输数据而无冲突（如果编码是“正交化的”）</li></ul><p><strong>随机访问协议</strong></p><p>基本思想：</p><ul><li>发送节点以信道全部速率（R b&#x2F;s）发送；</li><li>发生冲突时，冲突的每个节点分别等待一个随机时间，再重发，直到帧(分组)发送成功</li><li>节点间没有协调者</li></ul><p><strong>ALOHA协议</strong></p><p><img src="E:\typora-user-images\image-20220613163017931-1697679581288500.png" alt="image-20220613163017931"></p><p>1、时隙ALOHA：</p><p>所有的帧长L比特；<br>时间被划分为若干等长的时隙（长度为一帧的传输时间L&#x2F;R s）；<br>节点值在时隙的的开始点传输帧；<br>所有节点同步传输，知道时隙什么时候开始；<br>如果一个时隙有多个节点同时传送，所有节点都检测到冲突；<br>当节点有新的帧要发送，需等到下一个时隙开始，才传世整个帧。</p><p>无冲突：节点成功传输帧<br>有冲突：节点检测到冲突后，以概率p在后续的每一个时隙重传该帧，知道成功</p><p>当只有一个活到节点（有帧要发送）时，一全速R连续传输<br>分散的：每个节点检测并独立决定何时重传：<br>发送控制简单<br>有多个活动节点时效率低</p><p>三种可能时隙：</p><ul><li>冲突时隙C：出现帧冲突，被“浪费”。</li><li>空闲时隙E：所有活动节点停止传输，被“浪费”。</li><li>成功时隙S：只有一个节点在传输的时隙。</li></ul><p>效率：<br><img src="E:\typora-user-images\image-20220613164047867-1697679581288501.png" alt="image-20220613164047867"></p><p><img src="E:\typora-user-images\image-20220613164101013-1697679581288502.png" alt="image-20220613164101013"></p><p>优缺点：</p><p><img src="E:\typora-user-images\image-20220613164120452-1697679581288504.png" alt="image-20220613164120452"></p><p>2、纯ALOHA</p><p>非时隙Aloha: 简单，不需同步， ALOHA的最初形式。<br>帧一到达，立即传输<br>如果与其他帧产生冲突，在该冲突帧传完之后：</p><ul><li>以概率p立即重传该帧；</li><li>或等待一个帧的传输时间，再以概率p 传输该帧，或者以概率1-p 等待另一个帧的时间。</li></ul><p><img src="E:\typora-user-images\image-20220613164234921-1697679581288503.png" alt="image-20220613164234921"></p><p><img src="E:\typora-user-images\image-20220613164314463-1697679581288505.png" alt="image-20220613164314463"></p><p>效率：</p><p><img src="E:\typora-user-images\image-20220613164348334-1697679581288507.png" alt="image-20220613164348334"></p><p><strong>CSMA载波侦听多路访问</strong></p><p>载波侦听：某个节点在发送之前，先监听信道</p><ul><li>信道忙：有其他节点正往信道发送帧，该节点随机等待（回退）一段时间，然后再侦听信道。</li><li>信道空：该节点开始传输整个数据帧。</li></ul><p>特点：</p><ul><li>发前监听，可减少冲突。</li><li>由于传播时延的存在，仍有可能出现冲突，并造成信道浪费。</li></ul><p>例：</p><p><img src="E:\typora-user-images\image-20220613164604202-1697679581288506.png" alt="image-20220613164604202"></p><p><img src="E:\typora-user-images\image-20220613164620899-1697679581288508.png" alt="image-20220613164620899"></p><p><img src="E:\typora-user-images\image-20220613164647727-1697679581288509.png" alt="image-20220613164647727"></p><p><strong>带冲突检测的CSMA(CSMA&#x2F;CD)</strong></p><p>增加“载波侦听”和“冲突检测”两个规则。</p><p>基本原理： 传送前侦听</p><ul><li>信道忙：延迟传送</li><li>信道闲：传送整个帧</li></ul><p>发送同时进行冲突检测：一旦检测到冲突就立即停止传输， 尽快重发。</p><p>目的：缩短无效传送时间，提高信道的利用率</p><p>例：</p><p><img src="E:\typora-user-images\image-20220613164901428-1697679581288510.png" alt="image-20220613164901428"></p><p><strong>轮流协议</strong></p><p><img src="E:\typora-user-images\image-20220613164939889-1697679581288511.png" alt="image-20220613164939889"></p><p>1、轮询协议</p><p>轮询：</p><ul><li>主节点“邀请”从节点依次传送：</li><li>问题:<ul><li>轮询的开销</li><li>延时</li><li>单点故障(主节点）</li></ul></li></ul><p>令牌传递（token passing）：</p><ul><li>控制令牌顺序从一个节点传递到下一个节点。</li><li>问题:<ul><li>单点失效(token)</li></ul></li></ul><p><strong>多路访问协议的总结</strong></p><p><img src="E:\typora-user-images\image-20220613165150291-1697679581288512.png" alt="image-20220613165150291"></p><h3 id="5-4-交换局域网"><a href="#5-4-交换局域网" class="headerlink" title="5.4-交换局域网"></a>5.4-交换局域网</h3><p>局域网LAN（Local Area Network）</p><p>主要特点：网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>链路层技术的发展，使得局域网、城域网、广域网的概念变得越来越<br>模糊和不重要</p><p>多址访问协议广泛应用于局域网</p><p>基于随机访问的CSMA&#x2F;CD广泛应用于局域网</p><p>基于令牌传递技术的令牌环和FDDI在局域网技术中变得次要或被淘<br>汰</p><p>局域网按拓扑结构进行分类：星形网、环形网、总线网、树形网和网<br>状网</p><p>局域网体系结构：</p><p><img src="E:\typora-user-images\image-20220613165353251-1697679581288513.png" alt="image-20220613165353251"></p><h4 id="5-4-1-链路寻址和ARP"><a href="#5-4-1-链路寻址和ARP" class="headerlink" title="5.4.1-链路寻址和ARP"></a>5.4.1-链路寻址和ARP</h4><p>每个接口有网络层地址和链路层地址。</p><ul><li><p>网络层地址： 节点在互连网络中分配的一个唯一地址（IP地址）。用于把分组送到目的IP网络。长度为32比特（IPv4）。包括两部分：</p><ul><li><p>网络号：指明主机所在物理网络的编号。</p></li><li><p>主机号：主机在物理网络中的编号。</p></li></ul></li><li><p>链路层地址：MAC地址。<br>用于把数据帧从一个节点传送到另一个节点(同一网络中)。</p><ul><li>MAC地址：<ul><li>节点“网卡”本身所带的地址（唯一）。</li><li>MAC地址长度通常为6字节(48比特)，共248个。</li><li>6字节地址用16进制表示，每个字节表示为一对16进制数</li><li>网卡的MAC地址是永久的（生产时固化在其ROM里）</li></ul></li></ul></li></ul><p>MAC地址分配：<br>由专门机构（IEEE的注册管理委员会RAC）管理物理地址空间。负责分配六个字节中的前三个字节（高24位，地址块）。</p><ul><li>MAC 地址是平面结构： &#x3D;&gt; 可移动<br>带有同一网卡的节点，在任何网络中都有同样的MAC地址。（类似身份证）</li><li>IP地址具有层次结构： &#x3D;&gt;依赖节点所依附的IP网络<br>当节点移动到不同网络时，节点的IP地址发生改变。</li></ul><p>MAC地址识别：</p><p><img src="E:\typora-user-images\image-20220613173411479-1697679581288514.png" alt="image-20220613173411479"></p><p>节点的3种不同地址表示：</p><p><img src="E:\typora-user-images\image-20220613175522312-1697679581288515.png" alt="image-20220613175522312"></p><p>地址之间的转换：</p><p><img src="E:\typora-user-images\image-20220613190402091-1697679581288516.png" alt="image-20220613190402091"></p><p><strong>ARP地址解析协议</strong></p><p>ARP表：局域网上的每个节点(主机、路由器)都有这个表</p><ul><li>为某些局域网节点进行IP&#x2F;MAC地址<br>映射：&lt; IP address; MAC address; TTL&gt;</li><li>TTL (存活时间): 地址映射将被删除的时间（通常为20分钟）</li></ul><p>1.两个主机位于同一个局域网：</p><ul><li>A 希望发送数据报给 B<ul><li>B的MAC地址不在A的ARP映射表中</li></ul></li><li>A广播包含B的IP地址的ARP查询分组<ul><li>目的MAC地址&#x3D; FF-FF-FF-FF-FF-FF</li><li>在局域网上的所有机器都能收到ARP查询</li><li>每个适配器把该帧中的ARP查询分组向上传递给ARP模块，并由ARP模块检查是否与查询IP匹配。</li></ul></li><li>B收到ARP分组，回给A一个带有B的MAC地址的分组</li><li>ARP响应分组单播发送给A的MAC地址</li><li>A缓存IP-to-MAC地址对在 ARP表中，直到信息过期 (timeout)<ul><li>软件规定: 如果ARP表的信息在一定时间内没有刷新，则信息将过期。</li></ul></li></ul><p>ARP是即插即用的:无需网络管理员干预，节点就能创建ARP表<br>ARP协议是跨越链路层和网络层两边的协议</p><p>2.发送数据报到子网以外：</p><p><img src="E:\typora-user-images\image-20220613191342474-1697679581288517.png" alt="image-20220613191342474"></p><p><img src="E:\typora-user-images\image-20220613191613345-1697679581288518.png" alt="image-20220613191613345"></p><p><img src="E:\typora-user-images\image-20220613191622049-1697679581288519.png" alt="image-20220613191622049"></p><p><img src="E:\typora-user-images\image-20220613191915438-1697679581288520.png" alt="image-20220613191915438"></p><h4 id="5-4-2-以太网"><a href="#5-4-2-以太网" class="headerlink" title="5.4.2-以太网"></a>5.4.2-以太网</h4><p>以太网的物理拓扑结构：</p><ul><li>总线(bus): 一直流行到90年代中期<ul><li>所有节点都属于相同的冲突域</li></ul></li><li>星形(star):目前流行<ul><li>中心是交换机</li><li>每个端口运行一个独立的以太网协议(节点相互之间不发生碰撞)</li></ul></li></ul><p>以太网链路层控制技术：</p><p><img src="E:\typora-user-images\image-20220613192557387-1697679581288521.png" alt="image-20220613192557387"></p><p><strong>以太网的帧结构：</strong></p><p><img src="E:\typora-user-images\image-20220613192637976-1697679581288522.png" alt="image-20220613192637976"></p><ul><li><p>前同步码：</p><p><img src="E:\typora-user-images\image-20220613192822231-1697679581288523.png" alt="image-20220613192822231"></p></li><li><p>源、目的MAC地址（各6字节）</p><p><img src="E:\typora-user-images\image-20220613192832431-1697679581288524.png" alt="image-20220613192832431"></p></li><li><p>类型字段(2 字节)</p><p><img src="E:\教材\大二下\计算机网络\image-20220613192914669.png" alt="image-20220613192914669"></p></li><li><p>数据字段(46～1500 字节)</p><p><img src="E:\typora-user-images\image-20220613192945073-1697679581288525.png" alt="image-20220613192945073"></p></li><li><p>循环冗余检测CRC(4字节)</p><p><img src="E:\typora-user-images\image-20220613193036806-1697679581288526.png" alt="image-20220613193036806"></p></li></ul><p><strong>不可靠的无连接服务</strong></p><p>以太网向网络层提供的服务：</p><ul><li>无连接服务：通信时，发送方适配器不需要先和接收方适配器“握手”。</li><li>不可靠的服务：接收到的帧可能包含比特差错。<ul><li>收到正确帧，不发确认帧；</li><li>收到出错帧，丢弃该帧，不发否定帧。</li><li>发送适配器不会重发出错帧。</li><li>丢弃数据的恢复是通过终端传输层的可靠数据传输机制来实现的</li></ul></li><li>以太网的MAC协议：使用无时隙的CSMA&#x2F;CD协议（二进制指数回退）<ul><li>限制任意两个节点之间的距离。</li><li>采用指数回退等待，减少冲突。</li><li>适配器每传输一个帧，都要运行CSMA&#x2F;CD算法。</li><li>适配器发送新帧时，不考虑最近发生的任何冲突：<ul><li>当发生冲突的适配器处于指数回退状态时，冲突外的适配器有可能成功的传输一个新帧。</li></ul></li></ul></li></ul><h4 id="5-4-3-链路层交换机"><a href="#5-4-3-链路层交换机" class="headerlink" title="5.4.3-链路层交换机"></a>5.4.3-链路层交换机</h4><p>链路层交换机：互连局域网网段的网络设备<br>集线器：中继器（物理层）<br>交换机：多端口网桥（链路层）</p><p><strong>集线器-Hub：</strong></p><p><img src="E:\typora-user-images\image-20220613194152217-1697679581288527.png" alt="image-20220613194152217"></p><p><img src="E:\typora-user-images\image-20220613194204696-1697679581289531.png" alt="image-20220613194204696"></p><p><img src="E:\typora-user-images\image-20220613194402940-1697679581288528.png" alt="image-20220613194402940"></p><p><img src="E:\typora-user-images\image-20220613194421640-1697679581288529.png" alt="image-20220613194421640"></p><p><strong>链路层交换机：</strong></p><ul><li><p>链路层设备</p><ul><li>不同LAN网段的主机可以互相通信，每个LAN网段是一个独立的冲突域。</li><li>存储转发数据帧，可以互联不同的LAN技术。</li><li>检查达到的数据帧的MAC地址，有选择的转发数据帧到一个或多个输出链路，当数据帧被转发到一个共享网段时，使用CSMA&#x2F;CD来访问共享链路。</li><li>对LAN的大小没有限制，理论上，可扩展到全球。</li><li>透明</li></ul></li><li><p>主机不关心是否存在交换机</p></li><li><p>即插即用和自学习</p><ul><li>交换机不需要手工配置</li></ul><p><img src="E:\typora-user-images\image-20220613194654443-1697679581289530.png" alt="image-20220613194654443"></p></li></ul><p>支持多节点同时传输：</p><ul><li><p>每个主机由单独的链路直接连到交换机端口</p></li><li><p>交换机可以缓存数据帧</p></li><li><p>以太网协议在每个输入链路使用，</p><ul><li>无碰撞，全双工</li><li>每条链路自身是一个碰撞域</li></ul></li><li><p>交换机： A-to-A’和B-to-B’可以同时传输，而不会发生碰撞</p><p><img src="E:\typora-user-images\image-20220613194754725-1697679581289532.png" alt="image-20220613194754725"></p></li></ul><p>转发表：</p><p><img src="E:\typora-user-images\image-20220613194825165-1697679581289533.png" alt="image-20220613194825165"></p><p>转发和过滤：</p><p>过滤(filtering)：交换机判断一个帧是应该转发到某个接口还是丢弃。<br>转发(forward)：交换机决定一个帧应该被指向哪个接口，并引导到该接口。（过滤和转发通过交换机表(switch table)完成。）</p><p>交换机表：</p><ul><li>包含LAN上部分节点的表项。</li><li>内容：节点的MAC地址、通向该节点的交换机接口、节点表项产生的时间。<br><img src="E:\typora-user-images\image-20220613195021556-1697679581289534.png" alt="image-20220613195021556"></li></ul><p>自学习：</p><p><img src="E:\typora-user-images\image-20220613195055320-1697679581289535.png" alt="image-20220613195055320"></p><p>交换机是即插即用设备 (plug-and-play device)。只需将LAN网段连接到交换机的接口，其他不需网络管理员和用户干预。</p><p>交换机：数据帧的转发和过滤</p><p><img src="E:\typora-user-images\image-20220613195325297-1697679581289536.png" alt="image-20220613195325297"></p><p>例：</p><p><img src="E:\typora-user-images\image-20220613195442763-1697679581289537.png" alt="image-20220613195442763"></p><p><img src="E:\typora-user-images\image-20220613195452365-1697679581289538.png" alt="image-20220613195452365"></p><p><img src="E:\typora-user-images\image-20220613195505630-1697679581289539.png" alt="image-20220613195505630"></p><p><img src="E:\typora-user-images\image-20220613195532390-1697679581289540.png" alt="image-20220613195532390"></p><p><img src="E:\typora-user-images\image-20220613195856704-1697679581289541.png" alt="image-20220613195856704"></p><p>交换机互连：</p><p><img src="E:\typora-user-images\image-20220613200133563-1697679581289542.png" alt="image-20220613200133563"></p><p>例：<img src="E:\typora-user-images\image-20220613200225016-1697679581289543.png" alt="image-20220613200225016"></p><p><strong>交换机和路由器</strong><br>共同点：</p><ul><li>两者都是存储转发设备:<ul><li>路由器: 网络层设备(检查网络层头部)</li><li>交换机：链路层设备(检查链路层头部)</li></ul></li><li>两者都有转发表<ul><li>路由器：使用路由算法计算转发表，基于IP地址转发</li><li>交换机：通过洪泛、自学习来学习转发表，基于MAC地址转发</li></ul></li></ul><p>交换机的优缺点：</p><ul><li>即插即用：不需网络管理员干预；</li><li>较高的分组过滤和转发率：</li><li>拓扑结构为一棵生成树。</li><li>可能产生“广播风暴”：<ul><li>某台主机失控，并传输无穷的以太网广播帧流，交换机将转发所有这些帧，导致整个以太网的崩溃。</li></ul></li></ul><p>路由器的优缺点：</p><ul><li>网络寻址是层次的；</li><li>若网络中存在冗余路径，分组不会在路由器中循环。</li><li>无生成树限制，使用路由器构建因特网可以采用大量丰富的拓扑结构。</li><li>可以使用源和目的之间的最佳路径。</li><li>为第二层的广播风暴提供防火墙保护。</li><li>非即插即用：路由器及主机都需配置IP地址。</li><li>每个分组的处理时间比交换机长</li></ul><h4 id="5-4-4-虚拟局域网VLANs"><a href="#5-4-4-虚拟局域网VLANs" class="headerlink" title="5.4.4-虚拟局域网VLANs"></a>5.4.4-虚拟局域网VLANs</h4><p><img src="E:\typora-user-images\image-20220613200724341-1697679581289544.png" alt="image-20220613200724341"></p><p><img src="E:\typora-user-images\image-20220613200712575-1697679581289545.png" alt="image-20220613200712575"></p><p><img src="E:\typora-user-images\image-20220613200735412-1697679581289546.png" alt="image-20220613200735412"></p><p><img src="E:\typora-user-images\image-20220613200751981-1697679581289548.png" alt="image-20220613200751981"></p><p><strong>跨越多个交换机的VLAN</strong></p><p><img src="E:\typora-user-images\image-20220613200834350-1697679581289547.png" alt="image-20220613200834350"></p><p>三层交换是相对于传统的交换概念而提出的</p><p>传统的交换技术是在OSI网络参考模型中的第二层（即数据链路层）<br>进行操作的，通常称做“二层交换机”。</p><p>三层交换技术能够在网络模型中的第三层实现数据包的高速转发。简单地说，三层交换技术就是二层交换技术+三层转发技术，三层交换机就是“二层交换机+基于硬件的路由器”</p><p><img src="E:\typora-user-images\image-20220613200918791-1697679581289549.png" alt="image-20220613200918791"></p><p><img src="E:\typora-user-images\image-20220613200938162-1697679581289550.png" alt="image-20220613200938162"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-Basis</title>
    <link href="/2023/10/16/Java-Basis/"/>
    <url>/2023/10/16/Java-Basis/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><p>数据类型分为基础类型和引用类型，声明方式：类型 名称 &#x3D; 值</p><h3 id="1-1-基础类型"><a href="#1-1-基础类型" class="headerlink" title="1.1.基础类型"></a>1.1.基础类型</h3><ul><li>内置数据类型：<ul><li><code>byte</code>：8位，有符号的以二进制补码表示的整数</li><li><code>short</code>：16 位、有符号的以二进制补码表示的整数</li><li><code>int</code>：32位、有符号的以二进制补码表示的整数</li><li><code>long</code>：64 位、有符号的以二进制补码表示的整数，声明的值后面需加大写的<code>L</code></li><li><code>float</code>：单精度、32位、符合IEEE 754标准的浮点数，声明的值后面需加小写的<code>f</code></li><li><code>double</code>：双精度、64 位、符合 IEEE 754 标准的浮点数，声明的值后面需加小写的<code>d</code></li><li><code>boolean</code></li><li><code>char</code>：单一的 16 位 Unicode 字符</li></ul></li></ul><h3 id="1-2-引用类型"><a href="#1-2-引用类型" class="headerlink" title="1.2.引用类型"></a>1.2.引用类型</h3><ul><li><p>Number类：为内置数据类型的包装类，用于声明对象。当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。</p><ul><li>Boolean</li><li>Byte</li><li>Short</li><li>Integer</li><li>Long</li><li>Character</li><li>Float</li><li>Double</li></ul></li><li><p>Math类</p></li><li><p>Character类：基本类型char的包装类</p></li><li><p>String类：不可变类，属于对象</p><ul><li>String 直接创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上</li><li>.length()：获取字符串对象的长度</li></ul></li><li><p>StringBuilder：可变类，该类的对象能够被多次的修改，并且不产生新的未使用对象，线程不安全</p><ul><li>声明方式：<code>StringBuilder sb new StringBuilder(length);</code>，通过append、insert、delete进行增删改查操作</li></ul></li><li><p>StringBuffer：可变类，该类的对象能够被多次的修改，并且不产生新的未使用对象，线程安全</p><ul><li>声明方式：和StringBuilder类声明方式一样</li></ul></li><li><p>Date类：</p><ul><li>声明方式：<code>Date date = new Date() / new Date(long millisec)</code><ul><li>第二种方式的参数是从 1970 年 1 月 1 日起的毫秒数</li></ul></li></ul></li></ul><h3 id="1-3-类型转换"><a href="#1-3-类型转换" class="headerlink" title="1.3.类型转换"></a>1.3.类型转换</h3><ul><li>自动类型转换：转换从低到高，<code>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</code> <ul><li>转换方式：<code>char c1=&#39;a&#39;; int i1 = c1;</code></li></ul></li><li>强制类型转换<ul><li>转换方式：<code>(type) value</code>：<code>int i1 = 123; byte b = (byte)i1</code></li><li>转换条件：转换的数据类型必须是兼容的。</li></ul></li></ul><h3 id="1-4-变量类型"><a href="#1-4-变量类型" class="headerlink" title="1.4.变量类型"></a>1.4.变量类型</h3><ul><li><p><strong>常量：</strong>用 final 关键字修饰的变量，一旦被赋值就不能再修改。</p></li><li><p><strong>局部变量（Local Variables）：</strong>定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或语句块中。局部变量必须在使用前声明，并且不能被访问修饰符修饰。</p></li><li><p><strong>成员变量（Instance Variables）：</strong>定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问。成员变量可以被访问修饰符修饰。</p></li><li><p><strong>静态变量（Class Variables）：</strong>定义在类中、方法之外的变量，并且使用 <code>static</code> 关键字修饰，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问，静态变量的值在程序运行期间只有一个副本。静态变量可以被访问修饰符修饰。</p></li><li><p><strong>参数变量（Parameters）：</strong>方法定义时声明的变量，作为调用该方法时传递给方法的值。参数变量的作用域只限于方法内部。</p><ul><li><strong>值传递：</strong>在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的基本数据类型都采用值传递方式传递参数变量的值。</li><li><strong>引用传递：</strong>在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的对象类型采用引用传递方式传递参数变量的值</li></ul></li></ul><h3 id="1-5-类型判断"><a href="#1-5-类型判断" class="headerlink" title="1.5.类型判断"></a>1.5.类型判断</h3><ul><li><p>instanceof：用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）</p><ul><li><p>使用格式：( Object reference variable ) instanceof  (class&#x2F;interface type) </p></li><li><p>&#96;&#96;&#96;java<br>String name &#x3D; “James”;<br>boolean result &#x3D; name instanceof String;&#x2F;&#x2F; true</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br><br><br>## <span class="hljs-number">2.</span>对象和类<br><br>**对象**：对象是类的一个实例（**对象不是找个女朋友**），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。<br><br>**类**：类是一个模板，它描述一类对象的行为和状态。<br><br>**声明对象**：<br><br>- 声明方式：`<span class="hljs-keyword">Object</span> <span class="hljs-keyword">object</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>()`，<span class="hljs-keyword">Object</span>和<span class="hljs-keyword">Class</span>同名<br><br>- 构造方法：与类同名，一个类可以有多个构造方法，默认构造方法的访问修饰符和类的访问修饰符相同<br><br>  ```java<br>  <span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Puppy&#123;<br>     <span class="hljs-type">int</span> puppyAge;<br>     <span class="hljs-built_in">public</span> Puppy(String <span class="hljs-type">name</span>)&#123;<br>        // 这个构造器仅有一个参数：<span class="hljs-type">name</span><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;小狗的名字是 : &quot; + <span class="hljs-type">name</span> ); <br>     &#125;<br>  &#125;<br>  <br>  Puppy myPuppy = <span class="hljs-built_in">new</span> Puppy( &quot;tommy&quot; );<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><p>声明方式：</p><ul><li><p>一维数组</p><ul><li><p><code>dataType[] arrayVariable / dataType arrayVariable[]</code></p></li><li><p><code>arrayVariable = new dataType[arraySize]</code></p></li><li><p><code>dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;</code></p></li></ul></li><li><p>多维数组</p><ul><li><code>type[][] typeName = new type[typeLength1][typeLength2];</code></li></ul></li></ul><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h2><p>声明方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>方法重载：Java支持方法重载，两个方法拥有相同的名字，但是有不同的参数列表，Java编译器根据方法签名判断哪个方法应该被调用。</p></li><li><p>可变参数：<code>typeName... parameterName</code>，方法的最后一个参数，为一个数组。任何普通的参数必须在它之前声明</p></li><li><p><code>finalize()</code> 方法：在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-comment">// 在这里终结代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5.修饰符"></a>5.修饰符</h2><p>修饰符分为访问修饰符和非访问修饰符</p><ul><li><p>非访问修饰符</p><ul><li>static：用来修饰类方法和类变量。<ul><li>静态成员变量(Static Variables)：被 static修饰的成员变量称为静态成员变量或类变量。它们不属于类的任何一个实例，而是属于类本身。因此，即使创建了类的多个实例，静态成员变量也只有一份。只要静态成员变量所在的类被加载，这个静态成员变量就会被分配内存空间</li><li>静态方法(Static Methods)：被 static修饰的方法称为静态方法或类方法。它们可以在不创建类的实例的情况下被调用。静态方法只能访问静态数据成员，并可以更改静态数据成员的值</li><li>静态代码块(Static Blocks)：被 static修饰的代码块称为静态代码块或静态初始化器。它在加载类时会被执行，.因此可以在其中进行一些类成员变量的初始化工作</li><li>静态内部类(Static Inner Classes)：被 static修饰的内部类称为静态内部类。它是类相关的内部类，可以不依赖于外部类实例而被实例化。静态内部类不能访问其外部类的实例成员（包括普通的成员变量和方法）只能访问外部类的类成员(包括静态成员变量和静态方法)</li></ul></li><li>final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract：用来创建抽象类和抽象方法。</li><li>synchronized：声明的方法同一时间只能被一个线程访问</li><li>transient：被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量</li><li>volatile：修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。</li></ul></li><li><p>访问修饰符</p><table><thead><tr><th>修饰符</th><th>当前类</th><th>同一包内</th><th>子孙类(同一包)</th><th>子孙类(不同包)</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>Y&#x2F;N</td><td>N</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><ul><li><p>public：被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问</p></li><li><p>protected： 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类（内部类除外）</strong>。接口及接口的成员变量和成员方法不能声明为 protected</p><ul><li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li></ul></li><li><p>default：</p></li><li><p>private：被声明为private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p></li></ul></li></ul><h2 id="3-判断语句"><a href="#3-判断语句" class="headerlink" title="3.判断语句"></a>3.判断语句</h2><ul><li><p>if</p></li><li><p>if…else</p></li><li><p>swith case</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(expression)&#123;<br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-comment">//你可以有任意数量的case语句</span><br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">//可选</span><br>       <span class="hljs-comment">//语句</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-循环语句"><a href="#4-循环语句" class="headerlink" title="4.循环语句"></a>4.循环语句</h2><ul><li><p>while</p></li><li><p>do…while</p></li><li><p>for</p></li><li><p>for(声明语句 : 表达式)</p><ul><li><p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p><p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p></li></ul></li></ul><h2 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5.输入输出"></a>5.输入输出</h2><h2 id="6-错误处理"><a href="#6-错误处理" class="headerlink" title="6.错误处理"></a>6.错误处理</h2><h2 id="7-继承"><a href="#7-继承" class="headerlink" title="7.继承"></a>7.继承</h2>]]></content>
    
    
    <categories>
      
      <category>programing-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-Work-Log</title>
    <link href="/2023/03/20/My-Work-Log/"/>
    <url>/2023/03/20/My-Work-Log/</url>
    
    <content type="html"><![CDATA[<h1 id="My-Work-Log"><a href="#My-Work-Log" class="headerlink" title="My-Work-Log"></a>My-Work-Log</h1><p><strong>My work log in the reverse way</strong></p><p>&#x2F;** 2023&#x2F;8&#x2F;23*&#x2F;</p><ol><li>using web worker in the ts need to change the setting in tsconfig.json<ul><li>add the ‘WebWorker’ to the lib:  <code>&quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;,&quot;WebWorker&quot;],</code></li></ul></li></ol><p>&#x2F;** 2023&#x2F;8&#x2F;11*&#x2F;</p><ol><li><p>props in the styled components need to use &amp; at the property to avoid react console conflict</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBarControl</span> &#123;<br>  <span class="hljs-attr">$isPlaying</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">BarControl</span> = styled.<span class="hljs-property">div</span>&lt;<span class="hljs-title class_">IBarControl</span>&gt;<span class="hljs-string">`</span><br><span class="hljs-string">background-position: 0 <span class="hljs-subst">$&#123;(props) =&gt; (props.$isPlaying ? <span class="hljs-string">&#x27;-165px&#x27;</span> : <span class="hljs-string">&#x27;-204px&#x27;</span>)&#125;</span>;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li></ol><p>&#x2F;** 2023&#x2F;8&#x2F;1*&#x2F;</p><ol><li>&#96;&#96;&#96;<br>&#x2F;**<ul><li>use store.subscribe to update appCounter instead of useEffect</li><li>This is because changing the Redux state will trigger a re-render of the App component, and since the counter state is used as a dependency in the useEffect, the effect will be executed again.<br>   *&#x2F;<br>  &#x2F;&#x2F; useEffect(() &#x3D;&gt; {<br>  &#x2F;&#x2F;   setAppCounter({ counter: counter });<br>  &#x2F;&#x2F; }, [counter]);<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs smali"><br>   <br><br>/** 2023/7/21*/<br><br>1.<span class="hljs-built_in"> if </span>`slice()` only has one argument, it will slice the<span class="hljs-built_in"> array </span>from one argument to end<br>2. use ``&amp;&#123;number&#125;`` change number to string<br><br>/** 2023/7/14*/<br><br>1. `concat()` ：will<span class="hljs-built_in"> return </span>a<span class="hljs-built_in"> new </span>array but doesn&#x27;t change the origin<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span><br>2. `maxVal=undefined` `maxVal = maxVal &gt; node.val ? maxVal<span class="hljs-keyword"> :</span> node.val;`<br><br>   - init a val that will always<span class="hljs-built_in"> return </span>the biggest val whatever the first val is negative number<br><br>3. `Awaited`:递归获取Promise的返回值类型<br><br>4. `&#123; [K in keyof T]: T[K] &#125;`<span class="hljs-built_in"> and </span>`&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;`<br><br>   ```tex<br>   在 TypeScript 中，使用&#123; [K in keyof T]: T[K] &#125;语法可以遍历一个对象的属性，并返回一个具有相同属性的新对象。这样的语法会生成一个对象，其中键是原始对象的属性，而值是对应属性的类型。<br>   <br>   而当你使用&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;时，它并不是在遍历对象的属性。它的目的是将一个类型中的每个属性的值类型转换为其解析后的类型，前提是该属性的值是一个 Promise。这里的Awaited&lt;T[K]&gt;是一个条件类型，用于提取 Promise 类型的解析类型，如果属性的值不是 Promise，则保持原始类型不变。<br>   <br>   因此，当你将&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;用于PromiseAll函数的返回类型注解时，它表示一个包含每个属性值解析后类型的元组（或数组），而不是一个对象。<br>   <br>   举个例子，如果对象类型T是&#123; a: Promise&lt;number&gt;, b: Promise&lt;string&gt; &#125;，那么&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;将生成类型[number, string]，表示一个包含属性值解析后类型的数组。这是因为该类型是基于输入对象的属性的索引而生成的。<br>   <br>   因此，&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;生成的是一个数组，而不是一个对象。这是因为在PromiseAll函数中，我们处理的是类似数组的输入，而不是对象的属性。<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>&#x2F;** 2023&#x2F;7&#x2F;12*&#x2F;</p><ol><li><code>Record&lt;key,Type&gt;</code>:create a object that use Key as key ,Type as key’s type</li><li>Omit&lt;T,U&gt;:remove the set:U of T</li></ol><p>&#x2F;** 2023&#x2F;7&#x2F;7*&#x2F;</p><ol><li>the key of Object can use for in to iterate</li></ol><p>&#x2F;** 2023&#x2F;7&#x2F;6*&#x2F;</p><ol><li><p>one byte&#x3D;one bit(1字节&#x3D;8位)</p></li><li><p>实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：<br>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器</p><ul><li><p>for-of 循环</p></li><li><p>数组解构</p></li><li><p>扩展操作符：<code>...</code></p></li><li><p>Array.from()</p></li><li><p>创建集合</p></li><li><p>创建映射</p></li><li><p>Promise.all()接收由期约组成的可迭代对象</p></li><li><p>Promise.race()接收由期 约组成的可迭代对象</p></li><li><p>yield*操作符，在生成器中使用</p></li></ul></li></ol><p>&#x2F;** 2023&#x2F;7&#x2F;5*&#x2F;</p><ol><li><p><code>null void undefind</code>‘s level on TypeScript：the level of <code>void</code> and <code>undefined</code> like <code>null</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result35</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">&#x27;linbudu&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result37</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">boolean</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result38</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Boolean</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result39</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result40</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result41</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><dl><dt>&#96;&#96;&#96;ts<br>&#x2F;&#x2F; use Destructuring assignment to destrcture array and get the first item of array<br>type Includes&lt;T extends readonly any[], U&gt; &#x3D; T extends [<br>  infer First,<br>  …infer Rest<br>]<br>  ? Equal&lt;First, U&gt; extends true<br>? true</dt><dd>Includes&lt;Rest, U&gt;<br>  : false;</dd></dl><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>   <br><br><span class="hljs-comment">/** 2023/7/3*/</span><br><br><span class="hljs-number">1.</span> the shallow copy <span class="hljs-keyword">and</span> deep copy  <span class="hljs-keyword">in</span> `JavaScript`<br>   - `<span class="hljs-literal">[<span class="hljs-operator">...</span><span class="hljs-identifier">array</span>]</span>` is a shallow copy way<br>   - the way <span class="hljs-keyword">of</span> deep copy:<br>     - `<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>stringify(obj))`<br>     - General recursion <span class="hljs-keyword">function</span> implements deep copy<br><br><span class="hljs-comment">/** 2023/6/28*/</span><br><br><span class="hljs-number">1.</span> the `watch` <span class="hljs-keyword">function</span> will run <span class="hljs-keyword">if</span> the target&#x27;s value had changed wherever the value is null <span class="hljs-keyword">and</span> empty<br><br>   ```js<br>   <span class="hljs-comment">// the request function will run after the route.query had been modified</span><br>   watch(<br>    <span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> route.query.id,<br>    <span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>       <span class="hljs-keyword">if</span> (route.query.id?.length !== <span class="hljs-number">0</span>) &#123;<br>         get<span class="hljs-constructor">CourseDetail()</span>;<br>         get<span class="hljs-constructor">PersonRecords()</span>;<br>         get<span class="hljs-constructor">LessonRecords()</span>;<br>       &#125;<br>     &#125;,<br>   );<br></code></pre></td></tr></table></figure></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;27*&#x2F;</p><ol><li>how to get the global data from Pinia if the page was refreshed<ul><li><code>computed</code>: use <code>computed</code> to get the data from Pinia after the page was refreshed by entering crtl+R</li></ul></li></ol><ul><li><ul><li>persist: use <code>pinia-plugin-persistedstate</code> extend to store the data in the <code>localStorage</code> or <code>sessionStorage</code></li></ul></li></ul><p>&#x2F;** 2023&#x2F;6&#x2F;19*&#x2F;</p><ol><li><code>Math.floor()</code>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil"><code>Math.ceil()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/round"><code>Math.round()</code></a></li><li><code>Array.prototype.unshift()</code>、<code>Array.prototype.shift()</code></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;14*&#x2F;</p><ol><li>canvas also can set the css property,like <code>border</code></li><li>after mounted to update the loacalStorage</li><li>弧度&#x3D;(Math.PI&#x2F;180)*角度。</li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;12*&#x2F;</p><ol><li><p>in  the ts, because,the duck type, so the adapter( extends TargetObject) will be think as TargetObecjt</p><ul><li>the solution is add undefined to the target argument</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientNode</span>(<span class="hljs-params">target?: TargetObect, adapter?: Adapter</span>)&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TargetObect</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> adapter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>(adaptee);<br><span class="hljs-title class_">ClientNode</span>(<span class="hljs-literal">undefined</span>, adapter)<br></code></pre></td></tr></table></figure></li><li><p>chrome v8 垃圾回收：对于简单类型，内存是保存在栈（stack）空间中，复杂数据类型，内存是保存在堆（heap）空间中。</p><ul><li><p>如何区分活动对象和非活动对象</p><ul><li>有一个概念叫对象的可达性，表示从初始的根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从这个根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记，然后递归这个搜索的过程，直到所有子节点都被遍历结束，那么没有被标记的对象节点，说明该对象没有被任何地方引用，可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收</li></ul></li><li><p>堆分为两类：<code>新生代（只支持1~8m）</code>和<code>老生代</code></p><ul><li><p><code>新生代</code>：使用副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。</p><ul><li><p>Scavenge算法：Scavange算法将新生代堆分为两部分，分别叫<code>from-space</code>和<code>to-space</code>，工作方式也很简单，就是将<code>from-space</code>中存活的活动对象复制到<code>to-space</code>中，并将这些对象的内存有序的排列起来，然后将<code>from-space</code>中的非活动对象的内存进行释放，完成之后，将<code>from space</code> 和<code>to space</code>进行互换，这样可以使得新生代中的这两块区域可以重复利用</p><p><img src="C:\Users\15351\AppData\Roaming\Typora\typora-user-images\image-20230613100120083.png" alt="image-20230613100120083"></p></li><li><p>新生代还进一步细分为两个区域，<code>nursery</code>子代和<code>intermediate</code>子代，一个对象第一次分配内存时会被分配到新生代中的<code>nursery</code>子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 <code>intermediate</code> 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中</p></li></ul></li><li><p><code>老生代</code>：使用主垃圾回收器 - Mark-Sweep &amp; Mark-Compact：主要负责老生代的垃圾回收。</p><ul><li>Mark-Sweep：Mark-Sweep算法存在两个阶段标记阶段和清理阶段，在标记阶段对老生代进行第一次扫描，标记活动对象；在清理阶段对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象，但其会存在一个缺陷：会产生内存碎片</li><li>Mark-Compact：Mark-Compact是在 Mark-Sweep的基础上演进而来的，相比Mark-Sweep，Mark-Compact添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。</li></ul></li></ul></li><li><p>全停顿（Stop-The-World）：即由于垃圾回收期和Javascript应用逻辑竞争内存资源导致的不一致性问题，而垃圾回收期将JavaScript应用暂停</p><ul><li><p>原因：在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。</p></li><li><p>优化：</p><ul><li><p>增量标记：即将原本的标记全堆对象拆分为一个一个任务，让其穿插在Javascript应用逻辑之间执行（允许堆标记时5~10ms的停顿），增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。</p><p><img src="C:\Users\15351\AppData\Roaming\Typora\typora-user-images\image-20230613141344570.png" alt="image-20230613141344570"></p></li><li><p>懒性清理（用于真正的清理释放内存）：即当增量标记完成后，假如当前的可用内存足以快速的执行代码，是没必要立即清理内存的，可以将清理的过程延迟一下，让JavaScript逻辑代码先执行，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕</p></li><li><p>并发：并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行<br><img src="C:\Users\15351\AppData\Roaming\Typora\typora-user-images\image-20230613141917525.png" alt="image-20230613141917525"></p></li><li><p>并行：并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）<br><img src="C:\Users\15351\AppData\Roaming\Typora\typora-user-images\image-20230613141926339.png" alt="image-20230613141926339"></p></li></ul></li></ul></li></ul></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;9*&#x2F;</p><ol><li><p>in the js, the map,filter function of iterable is more recommended that what I think, because the map,filter can pass a callback functiono to run it.</p><ul><li><p>so to run the more async http request in the chrome, recommend use callback async funciton to get the data</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promises = subjectsData.<span class="hljs-property">value</span>.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (subject) =&gt; &#123;<br>        <span class="hljs-keyword">await</span> subjectStore.<span class="hljs-title function_">getSingleSubjects</span>(subject.<span class="hljs-property">id</span>);<br>        data.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(&#123; ...subjectStore.<span class="hljs-property">$state</span> &#125;);<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;<br>      &#125;);<br>      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>浏览器同域名请求的最大并发数限制: 普遍的浏览器最大并发数限制是在6次</p></li><li><p><code>promise.all</code> and <code>promise.race</code></p><ul><li><code>promise. all</code> need to wait for one promise, if one promise is rejected that all promises will be rejected</li><li><code>promise.race</code> doesn’t care about other promise’s state, who is fast will return it doesn’t care about its sequence, and the other promise will be ignore and doesn’t return</li></ul></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;8*&#x2F;</p><ol><li><p>when you put the data in the localStorage or sessionStorage , need to JSON.stringfy(the data) and get the data also need to JSON.parse(Storage.data)</p><ul><li>&#96;&#96;&#96;<br>localStorage.setItem(‘trainItem’, JSON.stringify(data.value));<br>data.value &#x3D; JSON.parse(localStorage[‘trainItem’]) <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><br>     <br><br><span class="hljs-comment">/** 2023/6/7*/</span><br><br><span class="hljs-number">1</span>. route‘s query<br><br>   - ```js<br>     <span class="hljs-comment">// just directly push the property in the query</span><br>     router.<span class="hljs-title function_ invoke__">push</span>(&#123;<br>           <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;city&#x27;</span>,<br>           <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/city&#x27;</span>,<br>           <span class="hljs-attr">query</span>: &#123; name &#125;,<br>         &#125;);<br></code></pre></td></tr></table></figure></li></ul><p>2.use transition component to add animation to the html component</p></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;6*&#x2F;</p><ol><li><p>use computed propterty to change the UI’s value</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">:disabled=<span class="hljs-string">&quot;isButtonDisabled&quot;</span><br><span class="hljs-keyword">const</span> isButtonDisabled = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> !showButton.<span class="hljs-property">value</span>);<br></code></pre></td></tr></table></figure></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;3*&#x2F;</p><ol><li>when await a data ,don’t pack in a object: <code>&#123;http.get(</code>&#x2F;table&#x2F;${tableMap.skill}&#x2F;rows<code>)&#125;</code><ul><li>the right thing is just return it: <code>export const getSkillItems = () =&gt; http.get(</code>&#x2F;table&#x2F;${tableMap.skill}&#x2F;rows<code>);</code></li></ul></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;2*&#x2F;</p><ol><li>In CSS and JavaScript, an ID selector should start with a letter, not a number. <code>&#39;a2022&#39;</code></li><li>open other website in new page<ul><li>window.open(‘<a href="https://www.baidu.com/">https://www.baidu.com/</a>‘, ‘_blank’)</li></ul></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;1*&#x2F;</p><ol><li>to pass some params in vue route</li></ol><ul><li><p>need to set :params</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// routes</span><br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jump&#x27;</span>,<br><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/jump:url</span><br><span class="hljs-string"></span><br><span class="hljs-string">//jump</span><br><span class="hljs-string">router.push(&#123;</span><br><span class="hljs-string">    name: &#x27;</span>jump<span class="hljs-string">&#x27;,</span><br><span class="hljs-string">    path: &#x27;</span>/jump<span class="hljs-string">&#x27;,</span><br><span class="hljs-string">    params: &#123;</span><br><span class="hljs-string">      url,</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">  &#125;);</span><br></code></pre></td></tr></table></figure></li></ul><p>&#x2F;** 2023&#x2F;5&#x2F;29*&#x2F;</p><ol><li>smaller than font-size:12px<ul><li>use <code>transform:scale(0.4)</code> to let the text be more samller than 12px</li></ul></li></ol><p>&#x2F;** 2023&#x2F;5&#x2F;26*&#x2F;</p><ol><li><p>how to change the component of Naive UI</p><ol><li><p>use themeOverrides and bing it on the component <code>&lt;n-table :theme-overrides=&quot;themeOverrides&quot;&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> themeOverrides = &#123;<br>  <span class="hljs-attr">tdColor</span>: <span class="hljs-string">&#x27;rgba(255,255,255,0)&#x27;</span>,<br>  <span class="hljs-attr">thColor</span>: <span class="hljs-string">&#x27;rgba(255,255,255,0)&#x27;</span>,<br>  <span class="hljs-attr">borderColor</span>: <span class="hljs-string">&#x27;#8EBBC3&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>Node 是如何应对高并发场景的？答：异步非阻塞。</p><p>JavaScript 的生态根基简单来讲就是语言+API 。<br>JavaScript 是一门脚本语言，一门语言要想有实际用途就得有能力调用各个系统，那么就需要各个系统面向 JavaScript 提供 API ，比如你计算了 1+2 ，能得出结果 3 ，但你要想看到这个结果就得让操作系统帮你显示出来，于是操作系统（中间省略很多环节）给 JS 提供了个 console API ，你可以使用 console.log 来（中间省略很多环节）调用操作系统把 3 显示出来。</p><p>所以 Node 不等于 JS ，JS 语言的执行能力只是 Node 的一项子功能而已。</p><p>原生 JavaScript 语言是单线程执行的，但 Node 不是单线程的，Node 为 JS 语言提供了一些 API ，其中大部分都是 IO 相关的 API ，比如网络访问、文件系统访问等。</p><p>Node 有一个假设，就是很多应用场景下 IO 操作的工作量要远远大于计算操作。比如大多 Web 应用服务都是响应网络请求（ IO 操作），经过简单的逻辑计算，然后进行数据库请求（ IO 操作），那么假设只要 CPU 不闲着，IO 负载很可能会比 CPU 负载先用满。</p><p>Node 如何做到让 CPU 不闲着？答：计算单线程执行，IO 多线程执行（异步），但计算可以不等着 IO 完成（异步非阻塞）。</p><p>不调用任何 API ，纯进行 JS 计算，比如算斐波那契数列，1+2&#x3D;3,2+3&#x3D;5……这个只能单线程执行，算 2+3&#x3D;5 的时候必须等着 1+2 出结果，只不过此时 CPU 并没有闲着而已。<br>如果在计算出每一个数字的时候，把数字写到硬盘上，这个写硬盘的操作就是 IO 操作；<br>假设没有异步非阻塞机制，应该是这样的：计算 1+2 ，得出 3 ，执行将 3 写入硬盘，等待写入完成，写入完成后计算 2+3……CPU 在等待的时候是闲着的，时间基本浪费在等待将 3 写入硬盘。<br>现在 Node 给你了一个能力，就是你可以在向硬盘写入 3 的时候选择不等着它完成，直接继续算 2+3 ，这就相当于有 1 个线程在不停算斐波那契数列，额外还有多个线程帮你把每个结果存硬盘。</p><p>回到题主的场景描述，Node 接收到一个请求之后，如果进行简单逻辑计算后就直接操作数据库（ IO 操作）或应答（ IO 操作）的话，可以选择不等着 IO 操作完成，继续处理下一个请求，等某个 IO 操作完成了就会回来调用后续的 JS 程序。</p><p>但如果执行的是异常复杂的计算，比如视频转码，如果是在处理请求的线程里做的话，一定会抢占预期用于处理请求的 CPU 时间，导致请求“卡住”。不过你猜怎么着，Node 其实是提供了多线程 API （ Worker threads ）和多进程 API （ Child process ），你完全可以像其他语言那样使用多线程和多进程来进行优化。除此之外 Node 还提供了面向 C&#x2F;C++的 N-API 以及面向很多语言的 WebAssembly ，在需要极端计算性能的场景下不至于完全放弃 JS 技术栈。</p></li></ol><p>&#x2F;** 2023&#x2F;5&#x2F;6*&#x2F;</p><p><code>shorthand syntax: 语法糖</code></p><p>&#x2F;** 2023&#x2F;5&#x2F;5*&#x2F;</p><p><code>No longer needs to be refreshed to use</code> <code>terms:条件</code></p><p>&#x2F;** 2023&#x2F;5&#x2F;4*&#x2F;</p><p><code>handle| deal with:处理</code></p><p>&#x2F;** 2023&#x2F;4&#x2F;27*&#x2F;</p><p><code>recursive:递归</code></p><ol><li>because js is a script language,it doesn’t has the input function like scanf in c language<ul><li>but in node.js,it can use <code>readline</code> and <code>stdin: input, stdout: output</code> to  realize the similar function</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;26*&#x2F;</p><ol><li>the rem means root-em exists on html label</li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;24*&#x2F;</p><ol><li>use ({name}) to get the props.name directly</li><li>to get the local file in the project,need to use fetch to get because the porject is CSR project and the fs module can’t use in the browser because it will think it is to read the user’s file</li><li>setXxx是异步的函数，推荐使用回调函数<code>setXxx(c=&gt;c+value)</code>的方式更新state</li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;20*&#x2F;</p><ol><li>the implements is to implement interface in ts,not type,type is to extends</li><li>the type is different with class</li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;19*&#x2F;</p><ol><li>to test the page’s effect of different size in a equiment<ul><li>in chrome , use the browser zoom to test</li><li>in safari or firefox, can use the responsive mode</li><li>use online tools,like BrowserStack and Sauce Labs</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;17*&#x2F;</p><ol><li>use lodash and node function in typescript environment</li></ol><ul><li>need to install <code>&quot;@types/lodash-es&quot; &quot;@types/node&quot;</code></li></ul><ol start="2"><li>the @ alias in ts<ul><li>not only neet to set in the bundle tool(like vite),but also need to  set in the tsconfig.json</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;16*&#x2F;</p><ol><li>the promise and the async function<ul><li>because the promise is a  asynchronous operation is need to fulfilled into a async function</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;14*&#x2F;</p><ol><li>the scrollbar of browser<ul><li>directly set ::-webkit-scrollbar and its property</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;11*&#x2F;</p><ol><li>setTimeout and setInterval<ul><li>setTimeout will run only once in the certain time</li><li>setInterval will run every certain time</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;11*&#x2F;</p><ol><li>the deconstruction assignment in object need key to key correctly</li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;6*&#x2F;</p><ol><li>v-deep(&lt;vue3) :deep(vue3)<ul><li>so to handle the selectd  child component in the component library ,can use the v-deep or :deep in style</li></ul></li><li>change img src in the array when bundle the project</li></ol><ul><li>use import the img in the array<br><code>import cloudImg from &quot;@/assets/images/screen/cloud.png&quot;;</code></li></ul><ol start="3"><li>the braket’s effect(role) is valid(diverse)</li></ol><ul><li>await the data you can use the braket() to include it and get the key directly</li></ul><p>&#x2F;** 2023&#x2F;4&#x2F;6*&#x2F;</p><ol><li>opacity and rgba<ul><li>opacity:0.3 equal to rgba(255,255,255,0.3)</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;3*&#x2F;</p><ol><li>how to set line solid bot<ul><li>set symbolSize and symbol:”circle”</li></ul></li><li>I recommend to use set dataset to a array,<ul><li>because in the array type,you can change the layout to the column or row;</li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;30*&#x2F;</p><ol><li><p>how to let different bar overlap together in echarts</p><ul><li>maybe zLevel or stack </li><li>stack is better! maybe!</li></ul></li><li><p>can use label.formatter(callback()) to change label.style</p><ul><li>in the formatter callback() function, can get the option’s data and can get the index of the data by params.dataIndex.</li></ul></li><li><p>how to let the text an the center of bar</p><ul><li>set: position: “inside”,</li></ul></li><li><p>how to let the  show all label in the xAxis</p><ul><li>axisLabel: {   interval: 0,}</li></ul></li><li><p>in the bar chart if you want to put a line</p><ul><li>you can set</li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;29*&#x2F;</p><ol><li>Promise {<pending>} instead of a value?<ul><li>because promise need to resolve, so must call <code>.then</code>to capture the resuslts.</li></ul></li><li>to much items on the xAxis of echarts,and it doesn’t show all,so th solution</li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;28*&#x2F;</p><ol><li><p>echarts and button conflict</p><ul><li>use z-index to set different display weight（the conflict was caused because I set the chart-box a high display weight  than the button’s and  forgot to adjust it ）</li></ul></li><li><p>vue3 composition API props and emits</p><ul><li>must to use defineProps and defineEmits to declare props and emits</li></ul></li><li><p>what is low code platform of backend in the China Mobile?？</p></li><li><p>Response Layout：what should I use in rem、flex、vw、grid</p><ul><li><p>rem:  be determined by font-size and @media</p></li><li><p>flex: can use <strong>calc</strong> to determine the width, and use <strong>aspect-radio</strong> to change the height.&#96;&#96;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><br><span class="hljs-selector-class">.grid-item</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">10px</span>);<br>  aspect-ratio: <span class="hljs-number">821</span>/<span class="hljs-number">351</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;27*&#x2F;</p><ol><li>why rem can’t run <ul><li>because i need to change the font-size at the root element</li></ul></li><li>menu hover<ul><li>use v-on  and bind the mouse event: mouseover and mouseout</li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;24*&#x2F;</p><ol><li>ECharts.API<ul><li>title: can set the title’s style position,</li><li>legend: 不同系列的标记，颜色和名字，也可以控制style position</li></ul></li><li>echarts error<ul><li>resize error: because vue’s dom is proxy,so it has conflict<ul><li><a href="https://blog.csdn.net/B_rabbit_d/article/details/119275715">Reference1</a></li><li><a href="https://github.com/apache/echarts/issues/13943">Reference2</a></li></ul></li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;23*&#x2F;</p><ol><li><p><a href="https://github.com/showlab/Tune-A-Video/blob/main/tuneavideo/pipelines/pipeline_tuneavideo.py">Tune-A-Video</a>: a funny py model that transform the  text into video.</p></li><li><p>v-for and v-if three solution??</p><ul><li>template</li><li>v-for filter</li><li>computed</li></ul></li><li><p>in the work of separation of fornt and back-end,how to make a good page struture is a bit of annoyance, so i decide to read a  book<a href="https://refactoringguru.cn/design-patterns/catalog">设计模式</a>，but it doesn’t seem relevant.so I need to learn more about it;</p></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;20*&#x2F;</p><ol><li>if you want to set the bg-image as big as browser,you can set<code>height:100vh</code></li><li>flex is powerful,don’t waste it </li><li>Html页面绘制先确定整体定位（用vw，vh，rem），在确定细分部分的大小（px，rem）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Daily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Daily</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-Daily-Log</title>
    <link href="/2023/03/14/My-Daily-Log/"/>
    <url>/2023/03/14/My-Daily-Log/</url>
    
    <content type="html"><![CDATA[<h1 id="My-Daily-Log"><a href="#My-Daily-Log" class="headerlink" title="My-Daily-Log"></a>My-Daily-Log</h1><p><strong>my daily log in the reverse way</strong></p><p>&#x2F;** 2023&#x2F;5&#x2F;7*&#x2F;</p><p>the trend ：to be more justify</p><ul><li>need more things at the center of normal distribution</li><li>how to let one man to closer to the truth, to let more people evaluate himself</li></ul><p>&#x2F;** 2023&#x2F;3&#x2F;19*&#x2F;</p><p>today, i talk to my mum about the bad thing that my dad almost fell down when he climbed a moutain, i am really worry about his health,i need to tell he need to do exercise gradually.There is an old saying in Chind:”Try you best,and that is the life”.sometimes it is hard to deal with life and family.and everything need time to do.I was regret to waste my time in the university.maybe to do hard previously can change my situation now.but the water is running,I need to focus on persent and do my best.</p><p>&#x2F;** 2023&#x2F;3&#x2F;15*&#x2F;</p><p>Guangxi Pinglu Canal (construction has already started, but it depends on national policies, industrial transfer in Guangdong, and the world situation)<br>The Ring of Guangxi and the Bicycle Industry</p><p>&#x2F;*<em>2023&#x2F;3&#x2F;14</em>&#x2F;</p><p>when the win key is’t work,check if the win key is on,use fn+win key to solve it in the asus computer</p><p>&#x2F;*<em>这是注释</em>&#x2F;</p><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>Daily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Daily</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Basis</title>
    <link href="/2023/03/10/Python-Basis/"/>
    <url>/2023/03/10/Python-Basis/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p>python的语法采用缩进方式，<code>input()</code>函数获取用户输入</p><h2 id="1-1-数据类型和变量"><a href="#1-1-数据类型和变量" class="headerlink" title="1.1.数据类型和变量"></a>1.1.数据类型和变量</h2><p>在python中变量是弱类型的，数据类型包括：整数、浮点数、字符串、布尔值、空值等……</p><ul><li><p>字符串(与JavaScript一样，使用<code>&quot;&quot;</code>或<code>&#39;&#39;</code>定义)</p><ul><li><p>转义字符：<code>\</code> ， 可以时字符串内部既包含<code>&#39;</code>或<code>&quot;</code></p><ul><li>字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code></li></ul></li><li><p><code>\n</code>表示换行</p></li><li><p><code>\t</code>表示制表符（tab）</p></li><li><p>不转义：<code>r&#39;&#39;</code></p></li><li><p>多行内容：<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>:&#96;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line2</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line3&#x27;&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>空值：None（JavaScript：Null）</p></li></ul><h2 id="1-2-字符串和编码"><a href="#1-2-字符串和编码" class="headerlink" title="1.2.字符串和编码"></a>1.2.字符串和编码</h2><p>ASCii&lt;UTF-8&lt;Unicode：字节的区别，</p><p>ASCII编码是1个字节，而Unicode编码通常是2个字节。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节</p><ul><li><code>ord()</code>函数获取字符的整数表示</li><li><code>chr()</code>函数把编码转换为对应的字符：</li><li>对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：<code>x = b&#39;ABC&#39;</code></li><li>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code><br>‘字符串’.encode(‘编码类型’)</li><li><code>decode()</code>：bytes<code>变为</code>str，例：<code>b&#39;ABC&#39;.decode(&#39;ascii&#39;)</code></li><li><code>len()</code>：获取字符串的长度或字节数</li></ul><table><thead><tr><th align="left">字符</th><th align="left">ASCII</th><th align="left">Unicode</th><th align="left">UTF-8</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">01000001</td><td align="left">00000000 01000001</td><td align="left">01000001</td></tr><tr><td align="left">中</td><td align="left">x</td><td align="left">01001110 00101101</td><td align="left">11100100 10111000 10101101</td></tr></tbody></table><p><img src="https://www.liaoxuefeng.com/files/attachments/923923787018816/0" alt="rw-file-utf-8"></p><p><img src="https://www.liaoxuefeng.com/files/attachments/923923759189600/0" alt="web-utf-8"></p><h2 id="1-3-格式化"><a href="#1-3-格式化" class="headerlink" title="1.3.格式化"></a>1.3.格式化</h2><p>和c语言一致，采用<code>%</code>实现，格式<code>&#39;Hello, %s&#39; % &#39;相应变量&#39;</code></p><table><thead><tr><th align="left">占位符</th><th align="left">替换内容</th></tr></thead><tbody><tr><td align="left">%d</td><td align="left">整数</td></tr><tr><td align="left">%f</td><td align="left">浮点数</td></tr><tr><td align="left">%s</td><td align="left">字符串，同时可以其他类型转换<br />为字符串</td></tr><tr><td align="left">%x</td><td align="left">十六进制整数</td></tr></tbody></table><p><code>format()</code>：用传入的参数依次替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>……，以此来格式化字符串<code>&#39;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#39;.format(&#39;小明&#39;, 17.125)</code></p><p><code>f-string</code>：使用以<code>f</code>开头的字符串，如果字符串包含{}，就会以对应的便令替换</p><h2 id="1-4-list和tuple"><a href="#1-4-list和tuple" class="headerlink" title="1.4.list和tuple"></a>1.4.list和tuple</h2><p><code>list</code>类似数组，使用<code>[]</code>定义，使用<code>len()</code>获取其长度，可以正数获取相应位置的元素，也可以倒数获取元素</p><ul><li><p><code>append()</code>：追加元素到末尾（JavaScript：push）</p></li><li><p><code>insert()</code>:在指定位置插入元素</p></li><li><p><code>pop()</code>：删除最后一个元素，也可以删除指定位置的元素</p></li><li><p>切片操作符<code>:</code>，和JS slice()方法类似，同样适用于tuple和字符串</p><ul><li>使用方式：<code>l[first location: last location]</code><br>首位置默认为0，可以不填，尾位置不被切片<br>也可以倒数切片，倒数第一个元素默认为-1，切片规则与正数一致</li></ul></li><li><p>列表生成式：用来创建list的生成式</p><ul><li>l&#x3D;list() :<code>l=list(range(1,11))</code></li><li>l&#x3D;[]<ul><li>单循环：<code>[x*x for x in range(1,11)]</code></li><li>双循环: <code>[m+n for m in &#39;abc&#39; for n in &#39;xyz&#39;]</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">//<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> 和 列表生成式<br>// <span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">in</span> front of  <span class="hljs-built_in">list</span> comprehensions,the <span class="hljs-keyword">if</span> judge the <span class="hljs-keyword">return</span> x<br>[x <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>//<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> behind of <span class="hljs-built_in">list</span> comprehensions,the <span class="hljs-keyword">if</span> judge the <span class="hljs-built_in">list</span> comprehensions<br>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure></li></ul><p><code>tuple</code>：元组，tuple一旦初始化就不能修改（即指向不变），采用()定义</p><p>但定义只有一个元素的tuple时，采用(data,)的方式一区别数学中的括号</p><h2 id="1-5-if条件判断"><a href="#1-5-if条件判断" class="headerlink" title="1.5.if条件判断"></a>1.5.if条件判断</h2><p><code>if</code>条件判断无需加括号，<code>elif</code>表示else if，是else if的缩写，<code>else:</code>要加冒号，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">3</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;your age is&#x27;</span>, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;adult&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;your age is&#x27;</span>, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;teenager&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>int()</code>函数，可以把<code>input()</code>返回的stri数据类型转换为整数</p><h2 id="1-6-循环和迭代"><a href="#1-6-循环和迭代" class="headerlink" title="1.6.循环和迭代"></a>1.6.循环和迭代</h2><p>Python有两种循环：</p><ol><li>for  in 循环  <ul><li>与Javascript中的for in 循环类似</li></ul></li><li>while 循环</li></ol><p><strong>迭代：</strong></p><p>python迭代通过for in来完成 </p><p>dict: for x in d || for x in d.values || for k,v in d.items</p><p>判断是否为可迭代对象Iterable</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">isinstance</span>( , Iterable)<br></code></pre></td></tr></table></figure><p>list:实现下标循环使用<code> enumerate()</code><br><code>for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):</code></p><p><u>迭代器</u>：可以被next()函数调用并不断返回下一个值的对象称为：Iterator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><span class="hljs-built_in">isinstance</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)), Iterator)<br></code></pre></td></tr></table></figure><h2 id="1-7-dict和set"><a href="#1-7-dict和set" class="headerlink" title="1.7.dict和set"></a>1.7.dict和set</h2><p>dict：字典，与Javascript对象或Map类似，使用键-值（key-value）存储</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">//<span class="hljs-built_in">dict</span><br>d = &#123;<span class="hljs-string">&#x27;Michael&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>: <span class="hljs-number">85</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>in 判断key是否存在</li><li>get()：key不存在，返回None</li><li>pop(key)：删除指定key</li></ul><p>set：一组key的集合，但不存储value，且key不能重复</p><p>创建set，需要提供一个list作为输入集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>//两个<span class="hljs-built_in">set</span>可以做数学意义上的交集、并集等操作：<br>s1 = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>s2 = <span class="hljs-built_in">set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>s1 &amp; s2<br></code></pre></td></tr></table></figure><ul><li>add(key)</li><li>remove(key)</li></ul><h2 id="1-8-函数"><a href="#1-8-函数" class="headerlink" title="1.8.函数"></a>1.8.函数</h2><p>声明方式：def 函数名(参数) ：</p><p>占位符： pass，用于空函数</p><p>python函数可以返回多个值，无需以花括号的形式<code>return x,y</code></p><p>python函数参数：</p><ol><li><p>位置参数：即(x)</p></li><li><p>默认参数：(x&#x3D;2)</p><ul><li>默认参数需指向不变对象</li></ul></li><li><p>可变参数：(*nubmers)</p><ul><li>lis和tuple传入可变参数，需要在其前面加*（类似js解构赋值）</li></ul></li><li><p>关键字参数：**，允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p><ul><li>同时也可以把dict传入关键字参数，函数内获得对dict的一份深拷贝<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">extra = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span>&#125;<br>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, **extra)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>命名关键字参数 （*， ），必须传入参数名，也可以设置默认值（此时调用函数时，可不传入已有默认值的参数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *args, city, job</span>):<br></code></pre></td></tr></table></figure></li></ol><p><strong>递归函数：</strong></p><p>栈帧</p><p>尾递归：尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式</p><h2 id="1-9-generator"><a href="#1-9-generator" class="headerlink" title="1.9.generator"></a>1.9.generator</h2><p><code>generator</code>:允许声明一个像<code>iterator</code>一样行为的函数</p><p>创建方法：</p><ol><li><p>（）：<code>g = (x * x for x in range(10))</code></p></li><li><p>yield</p></li></ol><p>调用方法：</p><ol><li>next()</li><li>for循环</li></ol><p>要获取generator函数返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">g = fib(<span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>     <span class="hljs-keyword">try</span>:<br>         x = <span class="hljs-built_in">next</span>(g)<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;g:&#x27;</span>, x)<br>     <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Generator return value:&#x27;</span>, e.value)<br>         <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="1-10-高阶函数？？"><a href="#1-10-高阶函数？？" class="headerlink" title="1.10.高阶函数？？"></a>1.10.高阶函数？？</h2><ul><li><p><code>map(fn(),Iterable) return Iterator</code></p></li><li><p><code>reduce(fn(),Iterable)</code>：函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算</p><ul><li><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></li></ul></li><li><p><code>filter(fn(),Iterable)</code>：接收一个函数和一个序列，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p></li><li><p><code>sorted(iterable, key=None, reverse=False)</code>：排序函数</p></li><li><p>匿名函数：关键字<code>lambda</code>表示匿名函数</p></li></ul><p><strong>装饰器：</strong></p><p><strong>偏函数：</strong></p><p><code>Partial function</code>：把一个函数的某些参数给固定住（也就是设置默认值 | 函数的某个参数是可以提前获知的），返回一个新的函数，调用这个新函数会更简单。</p><h2 id="1-11-面向对象"><a href="#1-11-面向对象" class="headerlink" title="1.11 面向对象??"></a>1.11 面向对象??</h2><p>重要概念：类(Class)和实例(Instance)</p><ul><li><p><code>_.value</code>:在变量前加<code>_</code>即为私有变量(<code>private</code>)</p></li><li><p>继承方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Eating meat...&#x27;</span>)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>isinstance(x, A_tuple)</code>:判断变量是否是某个类型</li><li><code>type()</code>:判断对象类型</li><li><code>type(fn)==types.FunctionType</code>:判断对象是否是函数</li><li><code>dir()</code>:获取一个对象的所有属性和方法<ul><li>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，</li></ul></li><li><code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code></li></ul></li></ul><p><strong>绑定属性或方法：</strong></p><ul><li><p><code>MethodType</code>:通过<code>MethodType</code>给实例绑定方法（给一个实例绑定的方法，对另一个实例是不起作用的）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self,age</span>):<br>  self.age=age<br>  <br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MethodType<br>s.set_age=MethodType(set_age,s)<br></code></pre></td></tr></table></figure></li><li><p>可以给类原型<code>class</code>绑定方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_score</span>(<span class="hljs-params">self, score</span>):<br>  self.score = score<br><br>Student.set_score = set_score<br></code></pre></td></tr></table></figure></li><li><p><code>使用__slots__</code>：限制添加的属性(仅对当前类实例起作用，对继承的子类是不起作用的)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student1</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>)<br><br>s1=Student1()<br>s1.name=<span class="hljs-string">&#x27;bob&#x27;</span><br>s1.age=<span class="hljs-string">&#x27;18&#x27;</span><br>s1.score=<span class="hljs-string">&#x27;30&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>@property</code>:负责把一个方法变成属性调用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student2</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">  @property </span><span class="hljs-comment"># just like the getter</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self._score<br>  <br><span class="hljs-meta">  @score.setter</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self,value</span>):<br>    self._score=value<br>    <br>s2 = Student2()<br>s2.score = <span class="hljs-number">60</span><br><span class="hljs-built_in">print</span>(s2._score) <span class="hljs-comment"># equal to print(s2.score)</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>MixIn??</strong></p><p><strong>魔术方法</strong></p><ul><li><p><code>__repr__() | __str()__</code></p><ul><li><p><code>__str__()</code>返回用户看到的字符串</p></li><li><p><code>__repr__()</code>返回程序开发者看到的字符串</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student3</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>    self.name = name<br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Student object (name=%s)&#x27;</span> % self.name<br>  <br>  <span class="hljs-comment"># __repr__ = __str__</span><br><br>s3 = Student3(<span class="hljs-string">&#x27;tom&#x27;</span>)<br><span class="hljs-built_in">print</span>(Student3(<span class="hljs-string">&#x27;bob&#x27;</span>))<br><span class="hljs-built_in">print</span>(s3)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>__iter__()</code>: 返回一个迭代对象，</p><ul><li><p>Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fib</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    self.a, self.b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>  <span class="hljs-comment"># 初始化两个计数器a，b</span><br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self  <span class="hljs-comment"># 实例本身就是迭代对象，故返回自己</span><br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>    self.a, self.b = self.b, self.a + self.b  <span class="hljs-comment"># 计算下一个值</span><br>    <span class="hljs-keyword">if</span> self.a &gt; <span class="hljs-number">100000</span>:  <span class="hljs-comment"># 退出循环的条件</span><br>      <span class="hljs-keyword">raise</span> StopIteration()<br>    <span class="hljs-keyword">return</span> self.a  <span class="hljs-comment"># 返回下一个值</span><br>  <br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> Fib():<br>  <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure></li><li><p><code>__getitem__(self, item)</code>:用于实现对象的索引行为</p></li><li><p><code>__setitem__()</code>:把对象视作list或dict来对集合赋值</p></li><li><p><code>__delitem__()</code>:用于删除某个元素。</p></li><li><p><code>__getattr__(self,&#39;attr&#39;)</code>:动态返回一个属性</p></li><li><p><code>__call__()</code>:调用自身的属性或方法</p></li></ul></li></ul><p><strong>枚举类</strong></p><p>枚举类：<code>Enum</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br>Month = Enum(<span class="hljs-string">&#x27;Month&#x27;</span>, (<span class="hljs-string">&#x27;Jan&#x27;</span>, <span class="hljs-string">&#x27;Feb&#x27;</span>, <span class="hljs-string">&#x27;Mar&#x27;</span>, <span class="hljs-string">&#x27;Apr&#x27;</span>, <span class="hljs-string">&#x27;May&#x27;</span>, <span class="hljs-string">&#x27;Jun&#x27;</span>, <span class="hljs-string">&#x27;Jul&#x27;</span>, <span class="hljs-string">&#x27;Aug&#x27;</span>, <span class="hljs-string">&#x27;Sep&#x27;</span>, <span class="hljs-string">&#x27;Oct&#x27;</span>, <span class="hljs-string">&#x27;Nov&#x27;</span>, <span class="hljs-string">&#x27;Dec&#x27;</span>))<br><span class="hljs-comment"># the structure like this</span><br><span class="hljs-comment">#&#x27;Jan&#x27;: &lt;Month.Jan: 1&gt;,the &#x27;Jan&#x27; is: name,the Month.Jan is: member the 1 is: member.value</span><br></code></pre></td></tr></table></figure><ul><li><code>@unique</code>:检查有没有重复值，类似<code>JavaScript</code>的<code>Symbol</code></li></ul><p><strong><code>type()</code></strong></p><p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型</p><p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p><ol><li>class的名称；</li><li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li><li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li></ol><p>**<code>metaclass</code>**？？</p><p><code>metaclass</code>:元类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListMetaClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>    attrs[<span class="hljs-string">&#x27;add&#x27;</span>] = <span class="hljs-keyword">lambda</span> self, value: self.append(value)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attrs)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>(<span class="hljs-built_in">list</span>, metaclass=ListMetaClass):<br>  <span class="hljs-keyword">pass</span><br><br>L = MyList()<br>L.add(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(L)<br></code></pre></td></tr></table></figure><p><strong>静态语言 vs 动态语言</strong></p><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><p>动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><h2 id="1-12-错误、调试和测试"><a href="#1-12-错误、调试和测试" class="headerlink" title="1.12 错误、调试和测试"></a>1.12 错误、调试和测试</h2><h3 id="1-12-1-错误处理"><a href="#1-12-1-错误处理" class="headerlink" title="1.12.1 错误处理"></a>1.12.1 <strong>错误处理</strong></h3><p><code>try...except...finally...</code></p><ul><li>可以用多个<code>expect</code>来捕获不同类型的错误</li><li>如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句</li><li>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">try:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try...&#x27;</span>)<br>    r = 10 / 0<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;result:&#x27;</span>, r)<br>except ZeroDivisionError as e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;except:&#x27;</span>, e)<br>finally:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finally...&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>记录错误</strong></p><p>记录错误：<code>logging</code>模块（使用<code>logging</code>模块，程序打印完错误信息后会继续执行，并正常退出）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># err_logging.py</span><br><br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">try</span>:<br>        bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        logging.exception(e)<br><br>main()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>抛出错误</strong></p><p>使用<code>raise</code>语句抛出错误</p><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。如果要抛出错误，可以根据需要，自定义一个错误的class（或者使用python内置的错误类型：比如<code>ValueError</code>，<code>TypeError</code>），选择好继承关系，然后抛出错误</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooError</span>(<span class="hljs-title class_ inherited__">ValueError</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> FooError(<span class="hljs-string">&#x27;invalid value: %s&#x27;</span> % s)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / n<br><br>foo(<span class="hljs-string">&#x27;0&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="1-12-2-调试"><a href="#1-12-2-调试" class="headerlink" title="1.12.2 调试"></a>1.12.2 调试</h3><ul><li><p><code>assert</code>：断音</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">assert</span> n != <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;n is zero!&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / n<br><br>foo(<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment">#AssertionError: n is zero!</span><br></code></pre></td></tr></table></figure></li><li><p><code>logging</code>:不会抛出错误，而且可以输出文件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(level=logging.INFO)<br><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br>logging.info(<span class="hljs-string">&#x27;n = %d&#x27;</span> % n)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure></li><li><p><code>pdb</code>：</p><ul><li>启动<code>pdb</code>命令：<code> python -m pdb err.py</code></li><li>定位到代码：输入代码块</li><li>查看代码：<code>list</code></li><li>单步执行代码：<code>n</code></li><li>查看变量：<code>p 变量名</code></li><li>结束调试：<code>q</code></li></ul></li><li><p><code>pdb.set_trace()</code>:在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p><ul><li>查看变量：<code>p</code></li><li>继续运行：<code>c</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># err.py</span><br><span class="hljs-keyword">import</span> pdb<br><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br>pdb.set_trace() <span class="hljs-comment"># 运行到这里会自动暂停</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-13-文件IO"><a href="#1-13-文件IO" class="headerlink" title="1.13 文件IO"></a>1.13 文件IO</h2><h3 id="1-13-1-文件读写"><a href="#1-13-1-文件读写" class="headerlink" title="1.13.1 文件读写"></a>1.13.1 文件读写</h3><p>python文件读写类似c语言</p><ul><li><p>打开文件：<code>open(&#39;xxPath&#39;,&#39;xxMode&#39;)</code></p></li><li><p>读文件：</p><ul><li><code>read()</code>：一次性读取</li><li><code>read(size)</code></li><li><code>readline()</code>:可以每次读取一行内容</li><li><code>readlines()</code>:一次读取所有内容并按行返回<code>list</code></li></ul></li><li><p>写文件：</p></li><li><p>关闭文件：<code>close()</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-built_in">print</span>(f)<br><span class="hljs-built_in">print</span>(f.read())<br>f.close()<br></code></pre></td></tr></table></figure></li><li><p><code>with ... as f:</code>:在<code>with</code>语句里会自动调用<code>close()</code>方法</p></li><li><p>读取二进制文件：<code>open(&#39;xxPath&#39;,&#39;rb&#39;)</code></p></li><li><p>读取非UTF-8编码的文件：<code>open(&#39;xxPath&#39;,&#39;xxMode&#39;,encoding=&#39;xx编码&#39;)</code></p><ul><li><code>errors=&#39;ignore&#39;</code></li></ul></li></ul><h3 id="1-13-2-内存读写"><a href="#1-13-2-内存读写" class="headerlink" title="1.13.2 内存读写"></a>1.13.2 内存读写</h3><p><strong>读写<code>str</code></strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br><br>f = StringIO()<br>f.write(<span class="hljs-string">&#x27;world!&#x27;</span>)<br><span class="hljs-built_in">print</span>(f.getvalue()) <span class="hljs-comment">#getvalue()方法用于获得写入后的str。</span><br></code></pre></td></tr></table></figure><p><strong>操作二进制数据</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><br>f = BytesIO()<br>f.write(<span class="hljs-string">&#x27;中文&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-built_in">print</span>(f.getvalue())<br></code></pre></td></tr></table></figure><h3 id="1-13-3-操作文件和目录"><a href="#1-13-3-操作文件和目录" class="headerlink" title="1.13.3 操作文件和目录"></a>1.13.3 操作文件和目录</h3><ul><li>操作系统类型：<code>os.name </code></li><li>环境变量：<code>os.environ</code></li><li>获取某个环境变量的值: <code>os.environ.get(&#39;key&#39;)</code></li><li>查看当前目录的绝对路径：<code>os.path.abspath(&#39;.&#39;)</code></li><li>合并路径：<code>os.path.join()</code></li><li>创建目录：<code>os.mkdir()</code></li><li>删除目录: <code>os.rmdir()</code></li><li>拆分路径为两部分，后一部分总是最后级别的目录或文件名：<code>os.path.split()</code></li><li>获取文件扩展名：<code>os.path.splitext()</code></li></ul><h3 id="1-13-4-序列化"><a href="#1-13-4-序列化" class="headerlink" title="1.13.4 序列化"></a>1.13.4 序列化</h3><p>序列化：把变量从内存中变成可存储或传输的过程</p><p>Python提供了<code>pickle</code>模块来实现序列化。</p><ul><li>把任意对象序列化成一个<code>bytes</code>：<code>pickle.dumps()</code></li><li>把对象序列化后写入一个file-like Object：<code>pickle.dump()</code></li><li>反序列化出对象：<code>pickle.loads()</code></li><li>从一个<code>file-like Object</code>中直接反序列化出对象：<code>pickle.load()</code></li></ul><p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换</p><ul><li><p><code>json.dumps()</code></p></li><li><p><code>json.dump()</code></p></li><li><p><code>json.loads()</code></p></li><li><p><code>json.load()</code></p></li><li><p>进阶：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, score</span>):<br>    self.name = name<br>    self.age = age<br>    self.score = score<br><br>s = Student(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">88</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">student2dict</span>(<span class="hljs-params">std</span>):<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-string">&#x27;name&#x27;</span>: std.name,<br>    <span class="hljs-string">&#x27;age&#x27;</span>: std.age,<br>    <span class="hljs-string">&#x27;score&#x27;</span>: std.score<br>  &#125;<br><br><span class="hljs-built_in">print</span>(json.dumps(s, default=student2dict))<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-14-进程和线程"><a href="#1-14-进程和线程" class="headerlink" title="1.14 进程和线程"></a>1.14 进程和线程</h2><h3 id="1-14-1-多进程"><a href="#1-14-1-多进程" class="headerlink" title="1.14.1 多进程"></a>1.14.1 多进程</h3><ul><li><p><code>linux</code>:</p><ul><li><p>创建子进程：<code>os.fork()</code></p></li><li><p>获取进程id：<code>os.getpid()</code></p><p>获取父进程id：<code>os.getppid()</code></p></li></ul></li><li><p><code>windows</code>:由于Windows没有<code>fork</code>调用,所以使用<code>multiprocessing</code>模块(跨平台版本的多进程模块。)</p><ul><li><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动。</p></li><li><p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 子进程要执行的代码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_proc</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent process %s.&#x27;</span> % os.getpid())<br>    p = Process(target=run_proc, args=(<span class="hljs-string">&#x27;test&#x27;</span>,))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process will start.&#x27;</span>)<br>    p.start()<br>    p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process end.&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>线程池：<code>Pool</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">import</span> os, time, random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">long_time_task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Run task %s (%s)...&#x27;</span> % (name, os.getpid()))<br>    start = time.time()<br>    time.sleep(random.random() * <span class="hljs-number">3</span>)<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Task %s runs %0.2f seconds.&#x27;</span> % (name, (end - start)))<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent process %s.&#x27;</span> % os.getpid())<br>    p = Pool(<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        p.apply_async(long_time_task, args=(i,))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waiting for all subprocesses done...&#x27;</span>)<br>    p.close()<br>    p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;All subprocesses done.&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>进程通信：<code>Queue()</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue<br><span class="hljs-keyword">import</span> os, time, random<br><br><span class="hljs-comment"># 写数据进程执行的代码:</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Process to write: %s&#x27;</span> % os.getpid())<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Put %s to queue...&#x27;</span> % value)<br>        q.put(value)<br>        time.sleep(random.random())<br><br><span class="hljs-comment"># 读数据进程执行的代码:</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Process to read: %s&#x27;</span> % os.getpid())<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        value = q.get(<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Get %s from queue.&#x27;</span> % value)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 父进程创建Queue，并传给各个子进程：</span><br>    q = Queue()<br>    pw = Process(target=write, args=(q,))<br>    pr = Process(target=read, args=(q,))<br>    <span class="hljs-comment"># 启动子进程pw，写入:</span><br>    pw.start()<br>    <span class="hljs-comment"># 启动子进程pr，读取:</span><br>    pr.start()<br>    <span class="hljs-comment"># 等待pw结束:</span><br>    pw.join()<br>    <span class="hljs-comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span><br>    pr.terminate()<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-14-2-多线程"><a href="#1-14-2-多线程" class="headerlink" title="1.14.2 多线程"></a>1.14.2 多线程</h3><p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。</p><ul><li><p>创建线程：<code>threading.Thread(target=xxFunc,name=&#39;xx&#39;)</code></p></li><li><p>获取当前线程信息：<code>threading.current_thread()</code></p></li><li><p>线程锁</p><ul><li><p>创建线程锁：<code>lock = threading.Lock()</code></p></li><li><p>获取锁：<code>lock.require()</code></p></li><li><p>释放锁: <code>lock.release</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py">balance = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_thread</span>(<span class="hljs-params">n</span>):<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>    <span class="hljs-comment"># 先要获取锁:</span><br>    lock.acquire()<br>    <span class="hljs-keyword">try</span>:<br>      <span class="hljs-comment"># 放心地改吧:</span><br>      change_it(n)<br>    <span class="hljs-keyword">finally</span>:<br>      <span class="hljs-comment"># 改完了一定要释放锁:</span><br>      lock.release()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_it</span>(<span class="hljs-params">n</span>):<br>  <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>  <span class="hljs-keyword">global</span> balance<br>  balance = balance + n<br>  balance = balance - n<br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br><span class="hljs-built_in">print</span>(balance)<br></code></pre></td></tr></table></figure></li><li><p><code>ThreadLocal:</code>一个全局变量，每个线程却可以利用它来保存属于自己的私有数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py">local_school=threading.local()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_student</span>():<br>  std=local_school.student<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello %s (in %s)&#x27;</span>%(std,threading.current_thread().name))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_thread</span>(<span class="hljs-params">name</span>):<br>  local_school.student=name<br>  process_student()<br>  <br>t1=threading.Thread(target=process_thread,args=(<span class="hljs-string">&#x27;bob&#x27;</span>,),name=<span class="hljs-string">&#x27;bob_thread&#x27;</span>)<br>t1.start()<br>t1.join()<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="1-15-异步IO"><a href="#1-15-异步IO" class="headerlink" title="1.15 异步IO"></a>1.15 异步IO</h2><ul><li><p><code>asyncio</code>:<code>asyncio</code>的编程模型就是一个消息循环。我们从<code>asyncio</code>模块中直接获取一个<code>EventLoop</code>的引用，然后把需要执行的协程扔到<code>EventLoop</code>中执行，就实现了异步IO。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world (%s)&#x27;</span> % threading.currentThread())<br>  <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello again (%s)&#x27;</span> % threading.currentThread())<br><br>loop = asyncio.get_event_loop()<br>tasks = [hello(), hello()]<br>loop.run_until_complete(asyncio.wait(tasks))<br>loop.close()<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-xx-正则表达式"><a href="#1-xx-正则表达式" class="headerlink" title="1.xx 正则表达式"></a>1.xx 正则表达式</h2><p>正则表达式是使用反斜杠<code>\</code>作为匹配工具的字符串</p><ul><li><p><code>.</code>：可以匹配任意字符</p></li><li><p><code>*</code>：表示任意个字符（包括0个）</p></li><li><p><code>+</code>：表示至少一个字符</p></li><li><p><code>?</code>：表示0个或1个字符</p></li><li><p><code>&#123;n&#125;</code>：表示n个字符</p></li><li><p><code>&#123;n,m&#125;</code>：表示n-m个字符：</p></li><li><p><code>\d</code>:表示匹配数字</p></li><li><p><code>\w</code>: 表示匹配字母</p></li><li><p><code>\s</code>：可以匹配一个空格（也包括Tab等空白符</p></li><li><p><code>\_</code>：<code>\</code>+特殊字符，表示匹配该特殊字符</p></li><li><p><code>^</code>：表示行的开头，<code>^\d</code>表示必须以数字开头。</p></li><li><p><code>$</code>：表示行的结束，<code>\d$</code>表示必须以数字结束。</p></li><li><p><code>A|B</code>：可以匹配A或B</p></li><li><p><code>[]</code>: 可以表示匹配范围，</p><ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li></ul></li><li><p><code>()</code>: 可用于分组提取子串</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">m=re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>,<span class="hljs-string">&#x27;010-12345&#x27;</span>)<br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure></li></ul><p>在Python中使用<code>re</code>模块，来使用正则表达式</p><ul><li><p><code>re.match()</code></p></li><li><p><code>re.splict()</code>: 可用与切分字符串</p><ul><li><code>re.split(r&#39;[\s\,]+&#39;, &#39;a,b, c  d&#39;)</code></li></ul></li><li><p>贪婪匹配：正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符</p><ul><li>如<code>\d+</code>采用贪婪匹配，加<code>?</code>可以让<code>\d+</code>采用非贪婪匹配：<code>\d+?</code></li></ul></li><li><p><code>rm.compiler()</code>: 编译后生成Regular Expression对象</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">re_telephone = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>)<br>re_telephone.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;010-12345&#x27;</span>).groups()<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>programing-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Hexo Blog Building Process</title>
    <link href="/2023/03/10/my-first-build-remark/"/>
    <url>/2023/03/10/my-first-build-remark/</url>
    
    <content type="html"><![CDATA[<img src="/2023/03/10/my-first-build-remark/739175c1cf079121eb57a66ddbf7048e.jpg" class="" title="This is an example image"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p>Hexo:<a href="https://xie.infoq.cn/article/ac51ce1f6e9434779c35cbb6c">参考网址</a> <a href="https://hexo.io/zh-cn/">Hexo网址</a> <a href="https://mrseawave.github.io/blogs/articles/2021/01/05/writing-hexo/">Hexo生成新的文章</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: [Deployment](</p>]]></content>
    
    
    <categories>
      
      <category>First-Build</category>
      
    </categories>
    
    
    <tags>
      
      <tag>First-Build</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
