<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java-Basis</title>
    <link href="/2023/10/16/Java-Basis/"/>
    <url>/2023/10/16/Java-Basis/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><p>数据类型分为基础类型和引用类型，声明方式：类型 名称 &#x3D; 值</p><h3 id="1-1-基础类型"><a href="#1-1-基础类型" class="headerlink" title="1.1.基础类型"></a>1.1.基础类型</h3><ul><li>内置数据类型：<ul><li><code>byte</code>：8位，有符号的以二进制补码表示的整数</li><li><code>short</code>：16 位、有符号的以二进制补码表示的整数</li><li><code>int</code>：32位、有符号的以二进制补码表示的整数</li><li><code>long</code>：64 位、有符号的以二进制补码表示的整数，声明的值后面需加大写的<code>L</code></li><li><code>float</code>：单精度、32位、符合IEEE 754标准的浮点数，声明的值后面需加小写的<code>f</code></li><li><code>double</code>：双精度、64 位、符合 IEEE 754 标准的浮点数，声明的值后面需加小写的<code>d</code></li><li><code>boolean</code></li><li><code>char</code>：单一的 16 位 Unicode 字符</li></ul></li></ul><h3 id="1-2-引用类型"><a href="#1-2-引用类型" class="headerlink" title="1.2.引用类型"></a>1.2.引用类型</h3><ul><li>Number类：为内置数据类型的包装类，用于声明对象。当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。<ul><li>Boolean</li><li>Byte</li><li>Short</li><li>Integer</li><li>Long</li><li>Character</li><li>Float</li><li>Double</li></ul></li><li>Math类</li><li>Character类：基本类型char的包装类</li><li>String类：不可变类，属于对象<ul><li>String 直接创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上</li><li>.length()：获取字符串对象的长度</li></ul></li><li>StringBuilder：可变类，该类的对象能够被多次的修改，并且不产生新的未使用对象，线程不安全<ul><li>声明方式：<code>StringBuilder sb new StringBuilder(length);</code>，通过append、insert、delete进行增删改查操作</li></ul></li><li>StringBuffer：可变类，该类的对象能够被多次的修改，并且不产生新的未使用对象，线程安全</li><li></li></ul><h3 id="1-3-类型转换"><a href="#1-3-类型转换" class="headerlink" title="1.3.类型转换"></a>1.3.类型转换</h3><ul><li>自动类型转换：转换从低到高，<code>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</code> <ul><li>转换方式：<code>char c1=&#39;a&#39;; int i1 = c1;</code></li></ul></li><li>强制类型转换<ul><li>转换方式：<code>(type) value</code>：<code>int i1 = 123; byte b = (byte)i1</code></li><li>转换条件：转换的数据类型必须是兼容的。</li></ul></li></ul><h3 id="1-4-变量类型"><a href="#1-4-变量类型" class="headerlink" title="1.4.变量类型"></a>1.4.变量类型</h3><ul><li><p><strong>常量：</strong>用 final 关键字修饰的变量，一旦被赋值就不能再修改。</p></li><li><p><strong>局部变量（Local Variables）：</strong>定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或语句块中。局部变量必须在使用前声明，并且不能被访问修饰符修饰。</p></li><li><p><strong>成员变量（Instance Variables）：</strong>定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问。成员变量可以被访问修饰符修饰。</p></li><li><p><strong>静态变量（Class Variables）：</strong>定义在类中、方法之外的变量，并且使用 <code>static</code> 关键字修饰，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问，静态变量的值在程序运行期间只有一个副本。静态变量可以被访问修饰符修饰。</p></li><li><p><strong>参数变量（Parameters）：</strong>方法定义时声明的变量，作为调用该方法时传递给方法的值。参数变量的作用域只限于方法内部。</p><ul><li><strong>值传递：</strong>在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的基本数据类型都采用值传递方式传递参数变量的值。</li><li><strong>引用传递：</strong>在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的对象类型采用引用传递方式传递参数变量的值</li></ul></li></ul><h3 id="1-5-类型判断"><a href="#1-5-类型判断" class="headerlink" title="1.5.类型判断"></a>1.5.类型判断</h3><ul><li><p>instanceof：用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）</p><ul><li><p>使用格式：( Object reference variable ) instanceof  (class&#x2F;interface type) </p></li><li><p>&#96;&#96;&#96;java<br>String name &#x3D; “James”;<br>boolean result &#x3D; name instanceof String;&#x2F;&#x2F; true</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br><br><br>## <span class="hljs-number">2.</span>对象和类<br><br>**对象**：对象是类的一个实例（**对象不是找个女朋友**），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。<br><br>**类**：类是一个模板，它描述一类对象的行为和状态。<br><br>**声明对象**：<br><br>- 声明方式：`<span class="hljs-keyword">Object</span> <span class="hljs-keyword">object</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>()`，<span class="hljs-keyword">Object</span>和<span class="hljs-keyword">Class</span>同名<br><br>- 构造方法：与类同名，一个类可以有多个构造方法<br><br>  ```java<br>  <span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Puppy&#123;<br>     <span class="hljs-type">int</span> puppyAge;<br>     <span class="hljs-built_in">public</span> Puppy(String <span class="hljs-type">name</span>)&#123;<br>        // 这个构造器仅有一个参数：<span class="hljs-type">name</span><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;小狗的名字是 : &quot; + <span class="hljs-type">name</span> ); <br>     &#125;<br>  &#125;<br>  <br>  Puppy myPuppy = <span class="hljs-built_in">new</span> Puppy( &quot;tommy&quot; );<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><p>声明方式：</p><ul><li><p>一维数组</p><ul><li><p><code>dataType[] arrayVariable / dataType arrayVariable[]</code></p></li><li><p><code>arrayVariable = new dataType[arraySize]</code></p></li><li><p><code>dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;</code></p></li></ul></li><li><p>二维数组</p><ul><li></li></ul></li></ul><h2 id="3-修饰符"><a href="#3-修饰符" class="headerlink" title="3.修饰符"></a>3.修饰符</h2><p>修饰符分为访问修饰符和非访问修饰符</p><ul><li><p>非访问修饰符</p><ul><li>static：用来修饰类方法和类变量。</li><li>final：用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li><li>abstract：用来创建抽象类和抽象方法。</li><li>synchronized：声明的方法同一时间只能被一个线程访问</li><li>transient：被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量</li><li>volatile：修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。</li></ul></li><li><p>访问修饰符</p><table><thead><tr><th>修饰符</th><th>当前类</th><th>同一包内</th><th>子孙类(同一包)</th><th>子孙类(不同包)</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>Y&#x2F;N</td><td>N</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><ul><li><p>public：被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问</p></li><li><p>protected： 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类（内部类除外）</strong>。接口及接口的成员变量和成员方法不能声明为 protected</p><ul><li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li></ul></li><li><p>default：</p></li><li><p>private：被声明为private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p></li></ul></li></ul><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h2><h2 id="3-判断语句"><a href="#3-判断语句" class="headerlink" title="3.判断语句"></a>3.判断语句</h2><ul><li><p>if</p></li><li><p>if…else</p></li><li><p>swith case</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(expression)&#123;<br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-comment">//你可以有任意数量的case语句</span><br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">//可选</span><br>       <span class="hljs-comment">//语句</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-循环语句"><a href="#4-循环语句" class="headerlink" title="4.循环语句"></a>4.循环语句</h2><ul><li><p>while</p></li><li><p>do…while</p></li><li><p>for</p></li><li><p>for(声明语句 : 表达式)</p><ul><li><p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p><p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p></li></ul></li></ul><h2 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5.输入输出"></a>5.输入输出</h2><h2 id="6-错误处理"><a href="#6-错误处理" class="headerlink" title="6.错误处理"></a>6.错误处理</h2><h2 id="7-继承"><a href="#7-继承" class="headerlink" title="7.继承"></a>7.继承</h2>]]></content>
    
    
    <categories>
      
      <category>programing-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-Work-Log</title>
    <link href="/2023/03/20/My-Work-Log/"/>
    <url>/2023/03/20/My-Work-Log/</url>
    
    <content type="html"><![CDATA[<h1 id="My-Work-Log"><a href="#My-Work-Log" class="headerlink" title="My-Work-Log"></a>My-Work-Log</h1><p><strong>My work log in the reverse way</strong></p><p>&#x2F;** 2023&#x2F;8&#x2F;23*&#x2F;</p><ol><li>using web worker in the ts need to change the setting in tsconfig.json<ul><li>add the ‘WebWorker’ to the lib:  <code>&quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;,&quot;WebWorker&quot;],</code></li></ul></li></ol><p>&#x2F;** 2023&#x2F;8&#x2F;11*&#x2F;</p><ol><li><p>props in the styled components need to use &amp; at the property to avoid react console conflict</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBarControl</span> &#123;<br>  <span class="hljs-attr">$isPlaying</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">BarControl</span> = styled.<span class="hljs-property">div</span>&lt;<span class="hljs-title class_">IBarControl</span>&gt;<span class="hljs-string">`</span><br><span class="hljs-string">background-position: 0 <span class="hljs-subst">$&#123;(props) =&gt; (props.$isPlaying ? <span class="hljs-string">&#x27;-165px&#x27;</span> : <span class="hljs-string">&#x27;-204px&#x27;</span>)&#125;</span>;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li></ol><p>&#x2F;** 2023&#x2F;8&#x2F;1*&#x2F;</p><ol><li>&#96;&#96;&#96;<br>&#x2F;**<ul><li>use store.subscribe to update appCounter instead of useEffect</li><li>This is because changing the Redux state will trigger a re-render of the App component, and since the counter state is used as a dependency in the useEffect, the effect will be executed again.<br>   *&#x2F;<br>  &#x2F;&#x2F; useEffect(() &#x3D;&gt; {<br>  &#x2F;&#x2F;   setAppCounter({ counter: counter });<br>  &#x2F;&#x2F; }, [counter]);<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs smali"><br>   <br><br>/** 2023/7/21*/<br><br>1.<span class="hljs-built_in"> if </span>`slice()` only has one argument, it will slice the<span class="hljs-built_in"> array </span>from one argument to end<br>2. use ``&amp;&#123;number&#125;`` change number to string<br><br>/** 2023/7/14*/<br><br>1. `concat()` ：will<span class="hljs-built_in"> return </span>a<span class="hljs-built_in"> new </span>array but doesn&#x27;t change the origin<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span><br>2. `maxVal=undefined` `maxVal = maxVal &gt; node.val ? maxVal<span class="hljs-keyword"> :</span> node.val;`<br><br>   - init a val that will always<span class="hljs-built_in"> return </span>the biggest val whatever the first val is negative number<br><br>3. `Awaited`:递归获取Promise的返回值类型<br><br>4. `&#123; [K in keyof T]: T[K] &#125;`<span class="hljs-built_in"> and </span>`&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;`<br><br>   ```tex<br>   在 TypeScript 中，使用&#123; [K in keyof T]: T[K] &#125;语法可以遍历一个对象的属性，并返回一个具有相同属性的新对象。这样的语法会生成一个对象，其中键是原始对象的属性，而值是对应属性的类型。<br>   <br>   而当你使用&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;时，它并不是在遍历对象的属性。它的目的是将一个类型中的每个属性的值类型转换为其解析后的类型，前提是该属性的值是一个 Promise。这里的Awaited&lt;T[K]&gt;是一个条件类型，用于提取 Promise 类型的解析类型，如果属性的值不是 Promise，则保持原始类型不变。<br>   <br>   因此，当你将&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;用于PromiseAll函数的返回类型注解时，它表示一个包含每个属性值解析后类型的元组（或数组），而不是一个对象。<br>   <br>   举个例子，如果对象类型T是&#123; a: Promise&lt;number&gt;, b: Promise&lt;string&gt; &#125;，那么&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;将生成类型[number, string]，表示一个包含属性值解析后类型的数组。这是因为该类型是基于输入对象的属性的索引而生成的。<br>   <br>   因此，&#123; [K in keyof T]: Awaited&lt;T[K]&gt; &#125;生成的是一个数组，而不是一个对象。这是因为在PromiseAll函数中，我们处理的是类似数组的输入，而不是对象的属性。<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>&#x2F;** 2023&#x2F;7&#x2F;12*&#x2F;</p><ol><li><code>Record&lt;key,Type&gt;</code>:create a object that use Key as key ,Type as key’s type</li><li>Omit&lt;T,U&gt;:remove the set:U of T</li></ol><p>&#x2F;** 2023&#x2F;7&#x2F;7*&#x2F;</p><ol><li>the key of Object can use for in to iterate</li></ol><p>&#x2F;** 2023&#x2F;7&#x2F;6*&#x2F;</p><ol><li><p>one byte&#x3D;one bit(1字节&#x3D;8位)</p></li><li><p>实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：<br>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器</p><ul><li><p>for-of 循环</p></li><li><p>数组解构</p></li><li><p>扩展操作符：<code>...</code></p></li><li><p>Array.from()</p></li><li><p>创建集合</p></li><li><p>创建映射</p></li><li><p>Promise.all()接收由期约组成的可迭代对象</p></li><li><p>Promise.race()接收由期 约组成的可迭代对象</p></li><li><p>yield*操作符，在生成器中使用</p></li></ul></li></ol><p>&#x2F;** 2023&#x2F;7&#x2F;5*&#x2F;</p><ol><li><p><code>null void undefind</code>‘s level on TypeScript：the level of <code>void</code> and <code>undefined</code> like <code>null</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result35</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">&#x27;linbudu&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result37</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">boolean</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result38</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Boolean</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result39</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result40</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result41</span> = <span class="hljs-literal">null</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>; <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><dl><dt>&#96;&#96;&#96;ts<br>&#x2F;&#x2F; use Destructuring assignment to destrcture array and get the first item of array<br>type Includes&lt;T extends readonly any[], U&gt; &#x3D; T extends [<br>  infer First,<br>  …infer Rest<br>]<br>  ? Equal&lt;First, U&gt; extends true<br>? true</dt><dd>Includes&lt;Rest, U&gt;<br>  : false;</dd></dl><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>   <br><br><span class="hljs-comment">/** 2023/7/3*/</span><br><br><span class="hljs-number">1.</span> the shallow copy <span class="hljs-keyword">and</span> deep copy  <span class="hljs-keyword">in</span> `JavaScript`<br>   - `<span class="hljs-literal">[<span class="hljs-operator">...</span><span class="hljs-identifier">array</span>]</span>` is a shallow copy way<br>   - the way <span class="hljs-keyword">of</span> deep copy:<br>     - `<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>stringify(obj))`<br>     - General recursion <span class="hljs-keyword">function</span> implements deep copy<br><br><span class="hljs-comment">/** 2023/6/28*/</span><br><br><span class="hljs-number">1.</span> the `watch` <span class="hljs-keyword">function</span> will run <span class="hljs-keyword">if</span> the target&#x27;s value had changed wherever the value is null <span class="hljs-keyword">and</span> empty<br><br>   ```js<br>   <span class="hljs-comment">// the request function will run after the route.query had been modified</span><br>   watch(<br>    <span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> route.query.id,<br>    <span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>       <span class="hljs-keyword">if</span> (route.query.id?.length !== <span class="hljs-number">0</span>) &#123;<br>         get<span class="hljs-constructor">CourseDetail()</span>;<br>         get<span class="hljs-constructor">PersonRecords()</span>;<br>         get<span class="hljs-constructor">LessonRecords()</span>;<br>       &#125;<br>     &#125;,<br>   );<br></code></pre></td></tr></table></figure></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;27*&#x2F;</p><ol><li>how to get the global data from Pinia if the page was refreshed<ul><li><code>computed</code>: use <code>computed</code> to get the data from Pinia after the page was refreshed by entering crtl+R</li></ul></li></ol><ul><li><ul><li>persist: use <code>pinia-plugin-persistedstate</code> extend to store the data in the <code>localStorage</code> or <code>sessionStorage</code></li></ul></li></ul><p>&#x2F;** 2023&#x2F;6&#x2F;19*&#x2F;</p><ol><li><code>Math.floor()</code>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil"><code>Math.ceil()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/round"><code>Math.round()</code></a></li><li><code>Array.prototype.unshift()</code>、<code>Array.prototype.shift()</code></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;14*&#x2F;</p><ol><li>canvas also can set the css property,like <code>border</code></li><li>after mounted to update the loacalStorage</li><li>弧度&#x3D;(Math.PI&#x2F;180)*角度。</li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;12*&#x2F;</p><ol><li><p>in  the ts, because,the duck type, so the adapter( extends TargetObject) will be think as TargetObecjt</p><ul><li>the solution is add undefined to the target argument</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientNode</span>(<span class="hljs-params">target?: TargetObect, adapter?: Adapter</span>)&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TargetObect</span> &#123;&#125;<br><br><span class="hljs-keyword">const</span> adapter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>(adaptee);<br><span class="hljs-title class_">ClientNode</span>(<span class="hljs-literal">undefined</span>, adapter)<br></code></pre></td></tr></table></figure></li><li><p>chrome v8 垃圾回收：对于简单类型，内存是保存在栈（stack）空间中，复杂数据类型，内存是保存在堆（heap）空间中。</p><ul><li><p>如何区分活动对象和非活动对象</p><ul><li>有一个概念叫对象的可达性，表示从初始的根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从这个根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记，然后递归这个搜索的过程，直到所有子节点都被遍历结束，那么没有被标记的对象节点，说明该对象没有被任何地方引用，可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收</li></ul></li><li><p>堆分为两类：<code>新生代（只支持1~8m）</code>和<code>老生代</code></p><ul><li><p><code>新生代</code>：使用副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。</p><ul><li><p>Scavenge算法：Scavange算法将新生代堆分为两部分，分别叫<code>from-space</code>和<code>to-space</code>，工作方式也很简单，就是将<code>from-space</code>中存活的活动对象复制到<code>to-space</code>中，并将这些对象的内存有序的排列起来，然后将<code>from-space</code>中的非活动对象的内存进行释放，完成之后，将<code>from space</code> 和<code>to space</code>进行互换，这样可以使得新生代中的这两块区域可以重复利用</p><p><img src="C:\Users\15351\AppData\Roaming\Typora\typora-user-images\image-20230613100120083.png" alt="image-20230613100120083"></p></li><li><p>新生代还进一步细分为两个区域，<code>nursery</code>子代和<code>intermediate</code>子代，一个对象第一次分配内存时会被分配到新生代中的<code>nursery</code>子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 <code>intermediate</code> 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中</p></li></ul></li><li><p><code>老生代</code>：使用主垃圾回收器 - Mark-Sweep &amp; Mark-Compact：主要负责老生代的垃圾回收。</p><ul><li>Mark-Sweep：Mark-Sweep算法存在两个阶段标记阶段和清理阶段，在标记阶段对老生代进行第一次扫描，标记活动对象；在清理阶段对老生代进行第二次扫描，清除未被标记的对象，即清理非活动对象，但其会存在一个缺陷：会产生内存碎片</li><li>Mark-Compact：Mark-Compact是在 Mark-Sweep的基础上演进而来的，相比Mark-Sweep，Mark-Compact添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存。</li></ul></li></ul></li><li><p>全停顿（Stop-The-World）：即由于垃圾回收期和Javascript应用逻辑竞争内存资源导致的不一致性问题，而垃圾回收期将JavaScript应用暂停</p><ul><li><p>原因：在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。</p></li><li><p>优化：</p><ul><li><p>增量标记：即将原本的标记全堆对象拆分为一个一个任务，让其穿插在Javascript应用逻辑之间执行（允许堆标记时5~10ms的停顿），增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。</p><p><img src="C:\Users\15351\AppData\Roaming\Typora\typora-user-images\image-20230613141344570.png" alt="image-20230613141344570"></p></li><li><p>懒性清理（用于真正的清理释放内存）：即当增量标记完成后，假如当前的可用内存足以快速的执行代码，是没必要立即清理内存的，可以将清理的过程延迟一下，让JavaScript逻辑代码先执行，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕</p></li><li><p>并发：并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行<br><img src="C:\Users\15351\AppData\Roaming\Typora\typora-user-images\image-20230613141917525.png" alt="image-20230613141917525"></p></li><li><p>并行：并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）<br><img src="C:\Users\15351\AppData\Roaming\Typora\typora-user-images\image-20230613141926339.png" alt="image-20230613141926339"></p></li></ul></li></ul></li></ul></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;9*&#x2F;</p><ol><li><p>in the js, the map,filter function of iterable is more recommended that what I think, because the map,filter can pass a callback functiono to run it.</p><ul><li><p>so to run the more async http request in the chrome, recommend use callback async funciton to get the data</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promises = subjectsData.<span class="hljs-property">value</span>.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (subject) =&gt; &#123;<br>        <span class="hljs-keyword">await</span> subjectStore.<span class="hljs-title function_">getSingleSubjects</span>(subject.<span class="hljs-property">id</span>);<br>        data.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(&#123; ...subjectStore.<span class="hljs-property">$state</span> &#125;);<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;<br>      &#125;);<br>      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>浏览器同域名请求的最大并发数限制: 普遍的浏览器最大并发数限制是在6次</p></li><li><p><code>promise.all</code> and <code>promise.race</code></p><ul><li><code>promise. all</code> need to wait for one promise, if one promise is rejected that all promises will be rejected</li><li><code>promise.race</code> doesn’t care about other promise’s state, who is fast will return it doesn’t care about its sequence, and the other promise will be ignore and doesn’t return</li></ul></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;8*&#x2F;</p><ol><li><p>when you put the data in the localStorage or sessionStorage , need to JSON.stringfy(the data) and get the data also need to JSON.parse(Storage.data)</p><ul><li>&#96;&#96;&#96;<br>localStorage.setItem(‘trainItem’, JSON.stringify(data.value));<br>data.value &#x3D; JSON.parse(localStorage[‘trainItem’]) <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><br>     <br><br><span class="hljs-comment">/** 2023/6/7*/</span><br><br><span class="hljs-number">1</span>. route‘s query<br><br>   - ```js<br>     <span class="hljs-comment">// just directly push the property in the query</span><br>     router.<span class="hljs-title function_ invoke__">push</span>(&#123;<br>           <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;city&#x27;</span>,<br>           <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/city&#x27;</span>,<br>           <span class="hljs-attr">query</span>: &#123; name &#125;,<br>         &#125;);<br></code></pre></td></tr></table></figure></li></ul><p>2.use transition component to add animation to the html component</p></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;6*&#x2F;</p><ol><li><p>use computed propterty to change the UI’s value</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">:disabled=<span class="hljs-string">&quot;isButtonDisabled&quot;</span><br><span class="hljs-keyword">const</span> isButtonDisabled = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> !showButton.<span class="hljs-property">value</span>);<br></code></pre></td></tr></table></figure></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;3*&#x2F;</p><ol><li>when await a data ,don’t pack in a object: <code>&#123;http.get(</code>&#x2F;table&#x2F;${tableMap.skill}&#x2F;rows<code>)&#125;</code><ul><li>the right thing is just return it: <code>export const getSkillItems = () =&gt; http.get(</code>&#x2F;table&#x2F;${tableMap.skill}&#x2F;rows<code>);</code></li></ul></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;2*&#x2F;</p><ol><li>In CSS and JavaScript, an ID selector should start with a letter, not a number. <code>&#39;a2022&#39;</code></li><li>open other website in new page<ul><li>window.open(‘<a href="https://www.baidu.com/">https://www.baidu.com/</a>‘, ‘_blank’)</li></ul></li></ol><p>&#x2F;** 2023&#x2F;6&#x2F;1*&#x2F;</p><ol><li>to pass some params in vue route</li></ol><ul><li><p>need to set :params</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// routes</span><br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jump&#x27;</span>,<br><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/jump:url</span><br><span class="hljs-string"></span><br><span class="hljs-string">//jump</span><br><span class="hljs-string">router.push(&#123;</span><br><span class="hljs-string">    name: &#x27;</span>jump<span class="hljs-string">&#x27;,</span><br><span class="hljs-string">    path: &#x27;</span>/jump<span class="hljs-string">&#x27;,</span><br><span class="hljs-string">    params: &#123;</span><br><span class="hljs-string">      url,</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">  &#125;);</span><br></code></pre></td></tr></table></figure></li></ul><p>&#x2F;** 2023&#x2F;5&#x2F;29*&#x2F;</p><ol><li>smaller than font-size:12px<ul><li>use <code>transform:scale(0.4)</code> to let the text be more samller than 12px</li></ul></li></ol><p>&#x2F;** 2023&#x2F;5&#x2F;26*&#x2F;</p><ol><li><p>how to change the component of Naive UI</p><ol><li><p>use themeOverrides and bing it on the component <code>&lt;n-table :theme-overrides=&quot;themeOverrides&quot;&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> themeOverrides = &#123;<br>  <span class="hljs-attr">tdColor</span>: <span class="hljs-string">&#x27;rgba(255,255,255,0)&#x27;</span>,<br>  <span class="hljs-attr">thColor</span>: <span class="hljs-string">&#x27;rgba(255,255,255,0)&#x27;</span>,<br>  <span class="hljs-attr">borderColor</span>: <span class="hljs-string">&#x27;#8EBBC3&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>Node 是如何应对高并发场景的？答：异步非阻塞。</p><p>JavaScript 的生态根基简单来讲就是语言+API 。<br>JavaScript 是一门脚本语言，一门语言要想有实际用途就得有能力调用各个系统，那么就需要各个系统面向 JavaScript 提供 API ，比如你计算了 1+2 ，能得出结果 3 ，但你要想看到这个结果就得让操作系统帮你显示出来，于是操作系统（中间省略很多环节）给 JS 提供了个 console API ，你可以使用 console.log 来（中间省略很多环节）调用操作系统把 3 显示出来。</p><p>所以 Node 不等于 JS ，JS 语言的执行能力只是 Node 的一项子功能而已。</p><p>原生 JavaScript 语言是单线程执行的，但 Node 不是单线程的，Node 为 JS 语言提供了一些 API ，其中大部分都是 IO 相关的 API ，比如网络访问、文件系统访问等。</p><p>Node 有一个假设，就是很多应用场景下 IO 操作的工作量要远远大于计算操作。比如大多 Web 应用服务都是响应网络请求（ IO 操作），经过简单的逻辑计算，然后进行数据库请求（ IO 操作），那么假设只要 CPU 不闲着，IO 负载很可能会比 CPU 负载先用满。</p><p>Node 如何做到让 CPU 不闲着？答：计算单线程执行，IO 多线程执行（异步），但计算可以不等着 IO 完成（异步非阻塞）。</p><p>不调用任何 API ，纯进行 JS 计算，比如算斐波那契数列，1+2&#x3D;3,2+3&#x3D;5……这个只能单线程执行，算 2+3&#x3D;5 的时候必须等着 1+2 出结果，只不过此时 CPU 并没有闲着而已。<br>如果在计算出每一个数字的时候，把数字写到硬盘上，这个写硬盘的操作就是 IO 操作；<br>假设没有异步非阻塞机制，应该是这样的：计算 1+2 ，得出 3 ，执行将 3 写入硬盘，等待写入完成，写入完成后计算 2+3……CPU 在等待的时候是闲着的，时间基本浪费在等待将 3 写入硬盘。<br>现在 Node 给你了一个能力，就是你可以在向硬盘写入 3 的时候选择不等着它完成，直接继续算 2+3 ，这就相当于有 1 个线程在不停算斐波那契数列，额外还有多个线程帮你把每个结果存硬盘。</p><p>回到题主的场景描述，Node 接收到一个请求之后，如果进行简单逻辑计算后就直接操作数据库（ IO 操作）或应答（ IO 操作）的话，可以选择不等着 IO 操作完成，继续处理下一个请求，等某个 IO 操作完成了就会回来调用后续的 JS 程序。</p><p>但如果执行的是异常复杂的计算，比如视频转码，如果是在处理请求的线程里做的话，一定会抢占预期用于处理请求的 CPU 时间，导致请求“卡住”。不过你猜怎么着，Node 其实是提供了多线程 API （ Worker threads ）和多进程 API （ Child process ），你完全可以像其他语言那样使用多线程和多进程来进行优化。除此之外 Node 还提供了面向 C&#x2F;C++的 N-API 以及面向很多语言的 WebAssembly ，在需要极端计算性能的场景下不至于完全放弃 JS 技术栈。</p></li></ol><p>&#x2F;** 2023&#x2F;5&#x2F;6*&#x2F;</p><p><code>shorthand syntax: 语法糖</code></p><p>&#x2F;** 2023&#x2F;5&#x2F;5*&#x2F;</p><p><code>No longer needs to be refreshed to use</code> <code>terms:条件</code></p><p>&#x2F;** 2023&#x2F;5&#x2F;4*&#x2F;</p><p><code>handle| deal with:处理</code></p><p>&#x2F;** 2023&#x2F;4&#x2F;27*&#x2F;</p><p><code>recursive:递归</code></p><ol><li>because js is a script language,it doesn’t has the input function like scanf in c language<ul><li>but in node.js,it can use <code>readline</code> and <code>stdin: input, stdout: output</code> to  realize the similar function</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;26*&#x2F;</p><ol><li>the rem means root-em exists on html label</li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;24*&#x2F;</p><ol><li>use ({name}) to get the props.name directly</li><li>to get the local file in the project,need to use fetch to get because the porject is CSR project and the fs module can’t use in the browser because it will think it is to read the user’s file</li><li>setXxx是异步的函数，推荐使用回调函数<code>setXxx(c=&gt;c+value)</code>的方式更新state</li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;20*&#x2F;</p><ol><li>the implements is to implement interface in ts,not type,type is to extends</li><li>the type is different with class</li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;19*&#x2F;</p><ol><li>to test the page’s effect of different size in a equiment<ul><li>in chrome , use the browser zoom to test</li><li>in safari or firefox, can use the responsive mode</li><li>use online tools,like BrowserStack and Sauce Labs</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;17*&#x2F;</p><ol><li>use lodash and node function in typescript environment</li></ol><ul><li>need to install <code>&quot;@types/lodash-es&quot; &quot;@types/node&quot;</code></li></ul><ol start="2"><li>the @ alias in ts<ul><li>not only neet to set in the bundle tool(like vite),but also need to  set in the tsconfig.json</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;16*&#x2F;</p><ol><li>the promise and the async function<ul><li>because the promise is a  asynchronous operation is need to fulfilled into a async function</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;14*&#x2F;</p><ol><li>the scrollbar of browser<ul><li>directly set ::-webkit-scrollbar and its property</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;11*&#x2F;</p><ol><li>setTimeout and setInterval<ul><li>setTimeout will run only once in the certain time</li><li>setInterval will run every certain time</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;11*&#x2F;</p><ol><li>the deconstruction assignment in object need key to key correctly</li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;6*&#x2F;</p><ol><li>v-deep(&lt;vue3) :deep(vue3)<ul><li>so to handle the selectd  child component in the component library ,can use the v-deep or :deep in style</li></ul></li><li>change img src in the array when bundle the project</li></ol><ul><li>use import the img in the array<br><code>import cloudImg from &quot;@/assets/images/screen/cloud.png&quot;;</code></li></ul><ol start="3"><li>the braket’s effect(role) is valid(diverse)</li></ol><ul><li>await the data you can use the braket() to include it and get the key directly</li></ul><p>&#x2F;** 2023&#x2F;4&#x2F;6*&#x2F;</p><ol><li>opacity and rgba<ul><li>opacity:0.3 equal to rgba(255,255,255,0.3)</li></ul></li></ol><p>&#x2F;** 2023&#x2F;4&#x2F;3*&#x2F;</p><ol><li>how to set line solid bot<ul><li>set symbolSize and symbol:”circle”</li></ul></li><li>I recommend to use set dataset to a array,<ul><li>because in the array type,you can change the layout to the column or row;</li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;30*&#x2F;</p><ol><li><p>how to let different bar overlap together in echarts</p><ul><li>maybe zLevel or stack </li><li>stack is better! maybe!</li></ul></li><li><p>can use label.formatter(callback()) to change label.style</p><ul><li>in the formatter callback() function, can get the option’s data and can get the index of the data by params.dataIndex.</li></ul></li><li><p>how to let the text an the center of bar</p><ul><li>set: position: “inside”,</li></ul></li><li><p>how to let the  show all label in the xAxis</p><ul><li>axisLabel: {   interval: 0,}</li></ul></li><li><p>in the bar chart if you want to put a line</p><ul><li>you can set</li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;29*&#x2F;</p><ol><li>Promise {<pending>} instead of a value?<ul><li>because promise need to resolve, so must call <code>.then</code>to capture the resuslts.</li></ul></li><li>to much items on the xAxis of echarts,and it doesn’t show all,so th solution</li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;28*&#x2F;</p><ol><li><p>echarts and button conflict</p><ul><li>use z-index to set different display weight（the conflict was caused because I set the chart-box a high display weight  than the button’s and  forgot to adjust it ）</li></ul></li><li><p>vue3 composition API props and emits</p><ul><li>must to use defineProps and defineEmits to declare props and emits</li></ul></li><li><p>what is low code platform of backend in the China Mobile?？</p></li><li><p>Response Layout：what should I use in rem、flex、vw、grid</p><ul><li><p>rem:  be determined by font-size and @media</p></li><li><p>flex: can use <strong>calc</strong> to determine the width, and use <strong>aspect-radio</strong> to change the height.&#96;&#96;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><br><span class="hljs-selector-class">.grid-item</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">10px</span>);<br>  aspect-ratio: <span class="hljs-number">821</span>/<span class="hljs-number">351</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;27*&#x2F;</p><ol><li>why rem can’t run <ul><li>because i need to change the font-size at the root element</li></ul></li><li>menu hover<ul><li>use v-on  and bind the mouse event: mouseover and mouseout</li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;24*&#x2F;</p><ol><li>ECharts.API<ul><li>title: can set the title’s style position,</li><li>legend: 不同系列的标记，颜色和名字，也可以控制style position</li></ul></li><li>echarts error<ul><li>resize error: because vue’s dom is proxy,so it has conflict<ul><li><a href="https://blog.csdn.net/B_rabbit_d/article/details/119275715">Reference1</a></li><li><a href="https://github.com/apache/echarts/issues/13943">Reference2</a></li></ul></li></ul></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;23*&#x2F;</p><ol><li><p><a href="https://github.com/showlab/Tune-A-Video/blob/main/tuneavideo/pipelines/pipeline_tuneavideo.py">Tune-A-Video</a>: a funny py model that transform the  text into video.</p></li><li><p>v-for and v-if three solution??</p><ul><li>template</li><li>v-for filter</li><li>computed</li></ul></li><li><p>in the work of separation of fornt and back-end,how to make a good page struture is a bit of annoyance, so i decide to read a  book<a href="https://refactoringguru.cn/design-patterns/catalog">设计模式</a>，but it doesn’t seem relevant.so I need to learn more about it;</p></li></ol><p>&#x2F;** 2023&#x2F;3&#x2F;20*&#x2F;</p><ol><li>if you want to set the bg-image as big as browser,you can set<code>height:100vh</code></li><li>flex is powerful,don’t waste it </li><li>Html页面绘制先确定整体定位（用vw，vh，rem），在确定细分部分的大小（px，rem）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Daily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Daily</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-Daily-Log</title>
    <link href="/2023/03/14/My-Daily-Log/"/>
    <url>/2023/03/14/My-Daily-Log/</url>
    
    <content type="html"><![CDATA[<h1 id="My-Daily-Log"><a href="#My-Daily-Log" class="headerlink" title="My-Daily-Log"></a>My-Daily-Log</h1><p><strong>my daily log in the reverse way</strong></p><p>&#x2F;** 2023&#x2F;5&#x2F;7*&#x2F;</p><p>the trend ：to be more justify</p><ul><li>need more things at the center of normal distribution</li><li>how to let one man to closer to the truth, to let more people evaluate himself</li></ul><p>&#x2F;** 2023&#x2F;3&#x2F;19*&#x2F;</p><p>today, i talk to my mum about the bad thing that my dad almost fell down when he climbed a moutain, i am really worry about his health,i need to tell he need to do exercise gradually.There is an old saying in Chind:”Try you best,and that is the life”.sometimes it is hard to deal with life and family.and everything need time to do.I was regret to waste my time in the university.maybe to do hard previously can change my situation now.but the water is running,I need to focus on persent and do my best.</p><p>&#x2F;** 2023&#x2F;3&#x2F;15*&#x2F;</p><p>Guangxi Pinglu Canal (construction has already started, but it depends on national policies, industrial transfer in Guangdong, and the world situation)<br>The Ring of Guangxi and the Bicycle Industry</p><p>&#x2F;*<em>2023&#x2F;3&#x2F;14</em>&#x2F;</p><p>when the win key is’t work,check if the win key is on,use fn+win key to solve it in the asus computer</p><p>&#x2F;*<em>这是注释</em>&#x2F;</p><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>Daily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Daily</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Basis</title>
    <link href="/2023/03/10/Python-Basis/"/>
    <url>/2023/03/10/Python-Basis/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><p>python的语法采用缩进方式，<code>input()</code>函数获取用户输入</p><h2 id="1-1-数据类型和变量"><a href="#1-1-数据类型和变量" class="headerlink" title="1.1.数据类型和变量"></a>1.1.数据类型和变量</h2><p>在python中变量是弱类型的，数据类型包括：整数、浮点数、字符串、布尔值、空值等……</p><ul><li><p>字符串(与JavaScript一样，使用<code>&quot;&quot;</code>或<code>&#39;&#39;</code>定义)</p><ul><li><p>转义字符：<code>\</code> ， 可以时字符串内部既包含<code>&#39;</code>或<code>&quot;</code></p><ul><li>字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code></li></ul></li><li><p><code>\n</code>表示换行</p></li><li><p><code>\t</code>表示制表符（tab）</p></li><li><p>不转义：<code>r&#39;&#39;</code></p></li><li><p>多行内容：<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>:&#96;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line2</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line3&#x27;&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>空值：None（JavaScript：Null）</p></li></ul><h2 id="1-2-字符串和编码"><a href="#1-2-字符串和编码" class="headerlink" title="1.2.字符串和编码"></a>1.2.字符串和编码</h2><p>ASCii&lt;UTF-8&lt;Unicode：字节的区别，</p><p>ASCII编码是1个字节，而Unicode编码通常是2个字节。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节</p><ul><li><code>ord()</code>函数获取字符的整数表示</li><li><code>chr()</code>函数把编码转换为对应的字符：</li><li>对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：<code>x = b&#39;ABC&#39;</code></li><li>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code><br>‘字符串’.encode(‘编码类型’)</li><li><code>decode()</code>：bytes<code>变为</code>str，例：<code>b&#39;ABC&#39;.decode(&#39;ascii&#39;)</code></li><li><code>len()</code>：获取字符串的长度或字节数</li></ul><table><thead><tr><th align="left">字符</th><th align="left">ASCII</th><th align="left">Unicode</th><th align="left">UTF-8</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">01000001</td><td align="left">00000000 01000001</td><td align="left">01000001</td></tr><tr><td align="left">中</td><td align="left">x</td><td align="left">01001110 00101101</td><td align="left">11100100 10111000 10101101</td></tr></tbody></table><p><img src="https://www.liaoxuefeng.com/files/attachments/923923787018816/0" alt="rw-file-utf-8"></p><p><img src="https://www.liaoxuefeng.com/files/attachments/923923759189600/0" alt="web-utf-8"></p><h2 id="1-3-格式化"><a href="#1-3-格式化" class="headerlink" title="1.3.格式化"></a>1.3.格式化</h2><p>和c语言一致，采用<code>%</code>实现，格式<code>&#39;Hello, %s&#39; % &#39;相应变量&#39;</code></p><table><thead><tr><th align="left">占位符</th><th align="left">替换内容</th></tr></thead><tbody><tr><td align="left">%d</td><td align="left">整数</td></tr><tr><td align="left">%f</td><td align="left">浮点数</td></tr><tr><td align="left">%s</td><td align="left">字符串，同时可以其他类型转换<br />为字符串</td></tr><tr><td align="left">%x</td><td align="left">十六进制整数</td></tr></tbody></table><p><code>format()</code>：用传入的参数依次替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>……，以此来格式化字符串<code>&#39;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#39;.format(&#39;小明&#39;, 17.125)</code></p><p><code>f-string</code>：使用以<code>f</code>开头的字符串，如果字符串包含{}，就会以对应的便令替换</p><h2 id="1-4-list和tuple"><a href="#1-4-list和tuple" class="headerlink" title="1.4.list和tuple"></a>1.4.list和tuple</h2><p><code>list</code>类似数组，使用<code>[]</code>定义，使用<code>len()</code>获取其长度，可以正数获取相应位置的元素，也可以倒数获取元素</p><ul><li><p><code>append()</code>：追加元素到末尾（JavaScript：push）</p></li><li><p><code>insert()</code>:在指定位置插入元素</p></li><li><p><code>pop()</code>：删除最后一个元素，也可以删除指定位置的元素</p></li><li><p>切片操作符<code>:</code>，和JS slice()方法类似，同样适用于tuple和字符串</p><ul><li>使用方式：<code>l[first location: last location]</code><br>首位置默认为0，可以不填，尾位置不被切片<br>也可以倒数切片，倒数第一个元素默认为-1，切片规则与正数一致</li></ul></li><li><p>列表生成式：用来创建list的生成式</p><ul><li>l&#x3D;list() :<code>l=list(range(1,11))</code></li><li>l&#x3D;[]<ul><li>单循环：<code>[x*x for x in range(1,11)]</code></li><li>双循环: <code>[m+n for m in &#39;abc&#39; for n in &#39;xyz&#39;]</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">//<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> 和 列表生成式<br>// <span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">in</span> front of  <span class="hljs-built_in">list</span> comprehensions,the <span class="hljs-keyword">if</span> judge the <span class="hljs-keyword">return</span> x<br>[x <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>//<span class="hljs-keyword">if</span> <span class="hljs-keyword">else</span> behind of <span class="hljs-built_in">list</span> comprehensions,the <span class="hljs-keyword">if</span> judge the <span class="hljs-built_in">list</span> comprehensions<br>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure></li></ul><p><code>tuple</code>：元组，tuple一旦初始化就不能修改（即指向不变），采用()定义</p><p>但定义只有一个元素的tuple时，采用(data,)的方式一区别数学中的括号</p><h2 id="1-5-if条件判断"><a href="#1-5-if条件判断" class="headerlink" title="1.5.if条件判断"></a>1.5.if条件判断</h2><p><code>if</code>条件判断无需加括号，<code>elif</code>表示else if，是else if的缩写，<code>else:</code>要加冒号，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">3</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;your age is&#x27;</span>, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;adult&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;your age is&#x27;</span>, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;teenager&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>int()</code>函数，可以把<code>input()</code>返回的stri数据类型转换为整数</p><h2 id="1-6-循环和迭代"><a href="#1-6-循环和迭代" class="headerlink" title="1.6.循环和迭代"></a>1.6.循环和迭代</h2><p>Python有两种循环：</p><ol><li>for  in 循环  <ul><li>与Javascript中的for in 循环类似</li></ul></li><li>while 循环</li></ol><p><strong>迭代：</strong></p><p>python迭代通过for in来完成 </p><p>dict: for x in d || for x in d.values || for k,v in d.items</p><p>判断是否为可迭代对象Iterable</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-built_in">isinstance</span>( , Iterable)<br></code></pre></td></tr></table></figure><p>list:实现下标循环使用<code> enumerate()</code><br><code>for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):</code></p><p><u>迭代器</u>：可以被next()函数调用并不断返回下一个值的对象称为：Iterator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><span class="hljs-built_in">isinstance</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)), Iterator)<br></code></pre></td></tr></table></figure><h2 id="1-7-dict和set"><a href="#1-7-dict和set" class="headerlink" title="1.7.dict和set"></a>1.7.dict和set</h2><p>dict：字典，与Javascript对象或Map类似，使用键-值（key-value）存储</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">//<span class="hljs-built_in">dict</span><br>d = &#123;<span class="hljs-string">&#x27;Michael&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>: <span class="hljs-number">85</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>in 判断key是否存在</li><li>get()：key不存在，返回None</li><li>pop(key)：删除指定key</li></ul><p>set：一组key的集合，但不存储value，且key不能重复</p><p>创建set，需要提供一个list作为输入集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>//两个<span class="hljs-built_in">set</span>可以做数学意义上的交集、并集等操作：<br>s1 = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>s2 = <span class="hljs-built_in">set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>s1 &amp; s2<br></code></pre></td></tr></table></figure><ul><li>add(key)</li><li>remove(key)</li></ul><h2 id="1-8-函数"><a href="#1-8-函数" class="headerlink" title="1.8.函数"></a>1.8.函数</h2><p>声明方式：def 函数名(参数) ：</p><p>占位符： pass，用于空函数</p><p>python函数可以返回多个值，无需以花括号的形式<code>return x,y</code></p><p>python函数参数：</p><ol><li><p>位置参数：即(x)</p></li><li><p>默认参数：(x&#x3D;2)</p><ul><li>默认参数需指向不变对象</li></ul></li><li><p>可变参数：(*nubmers)</p><ul><li>lis和tuple传入可变参数，需要在其前面加*（类似js解构赋值）</li></ul></li><li><p>关键字参数：**，允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p><ul><li>同时也可以把dict传入关键字参数，函数内获得对dict的一份深拷贝<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">extra = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span>&#125;<br>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, **extra)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>命名关键字参数 （*， ），必须传入参数名，也可以设置默认值（此时调用函数时，可不传入已有默认值的参数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *args, city, job</span>):<br></code></pre></td></tr></table></figure></li></ol><p><strong>递归函数：</strong></p><p>栈帧</p><p>尾递归：尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式</p><h2 id="1-9-generator"><a href="#1-9-generator" class="headerlink" title="1.9.generator"></a>1.9.generator</h2><p><code>generator</code>:允许声明一个像<code>iterator</code>一样行为的函数</p><p>创建方法：</p><ol><li><p>（）：<code>g = (x * x for x in range(10))</code></p></li><li><p>yield</p></li></ol><p>调用方法：</p><ol><li>next()</li><li>for循环</li></ol><p>要获取generator函数返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">g = fib(<span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>     <span class="hljs-keyword">try</span>:<br>         x = <span class="hljs-built_in">next</span>(g)<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;g:&#x27;</span>, x)<br>     <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Generator return value:&#x27;</span>, e.value)<br>         <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="1-10-高阶函数？？"><a href="#1-10-高阶函数？？" class="headerlink" title="1.10.高阶函数？？"></a>1.10.高阶函数？？</h2><ul><li><p><code>map(fn(),Iterable) return Iterator</code></p></li><li><p><code>reduce(fn(),Iterable)</code>：函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算</p><ul><li><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code></li></ul></li><li><p><code>filter(fn(),Iterable)</code>：接收一个函数和一个序列，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p></li><li><p><code>sorted(iterable, key=None, reverse=False)</code>：排序函数</p></li><li><p>匿名函数：关键字<code>lambda</code>表示匿名函数</p></li></ul><p><strong>装饰器：</strong></p><p><strong>偏函数：</strong></p><p><code>Partial function</code>：把一个函数的某些参数给固定住（也就是设置默认值 | 函数的某个参数是可以提前获知的），返回一个新的函数，调用这个新函数会更简单。</p><h2 id="1-11-面向对象"><a href="#1-11-面向对象" class="headerlink" title="1.11 面向对象??"></a>1.11 面向对象??</h2><p>重要概念：类(Class)和实例(Instance)</p><ul><li><p><code>_.value</code>:在变量前加<code>_</code>即为私有变量(<code>private</code>)</p></li><li><p>继承方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Eating meat...&#x27;</span>)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>isinstance(x, A_tuple)</code>:判断变量是否是某个类型</li><li><code>type()</code>:判断对象类型</li><li><code>type(fn)==types.FunctionType</code>:判断对象是否是函数</li><li><code>dir()</code>:获取一个对象的所有属性和方法<ul><li>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，</li></ul></li><li><code>getattr()</code>、<code>setattr()</code>、<code>hasattr()</code></li></ul></li></ul><p><strong>绑定属性或方法：</strong></p><ul><li><p><code>MethodType</code>:通过<code>MethodType</code>给实例绑定方法（给一个实例绑定的方法，对另一个实例是不起作用的）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self,age</span>):<br>  self.age=age<br>  <br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MethodType<br>s.set_age=MethodType(set_age,s)<br></code></pre></td></tr></table></figure></li><li><p>可以给类原型<code>class</code>绑定方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_score</span>(<span class="hljs-params">self, score</span>):<br>  self.score = score<br><br>Student.set_score = set_score<br></code></pre></td></tr></table></figure></li><li><p><code>使用__slots__</code>：限制添加的属性(仅对当前类实例起作用，对继承的子类是不起作用的)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student1</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>)<br><br>s1=Student1()<br>s1.name=<span class="hljs-string">&#x27;bob&#x27;</span><br>s1.age=<span class="hljs-string">&#x27;18&#x27;</span><br>s1.score=<span class="hljs-string">&#x27;30&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>@property</code>:负责把一个方法变成属性调用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student2</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">  @property </span><span class="hljs-comment"># just like the getter</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self._score<br>  <br><span class="hljs-meta">  @score.setter</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self,value</span>):<br>    self._score=value<br>    <br>s2 = Student2()<br>s2.score = <span class="hljs-number">60</span><br><span class="hljs-built_in">print</span>(s2._score) <span class="hljs-comment"># equal to print(s2.score)</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>MixIn??</strong></p><p><strong>魔术方法</strong></p><ul><li><p><code>__repr__() | __str()__</code></p><ul><li><p><code>__str__()</code>返回用户看到的字符串</p></li><li><p><code>__repr__()</code>返回程序开发者看到的字符串</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student3</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>    self.name = name<br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Student object (name=%s)&#x27;</span> % self.name<br>  <br>  <span class="hljs-comment"># __repr__ = __str__</span><br><br>s3 = Student3(<span class="hljs-string">&#x27;tom&#x27;</span>)<br><span class="hljs-built_in">print</span>(Student3(<span class="hljs-string">&#x27;bob&#x27;</span>))<br><span class="hljs-built_in">print</span>(s3)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>__iter__()</code>: 返回一个迭代对象，</p><ul><li><p>Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fib</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    self.a, self.b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>  <span class="hljs-comment"># 初始化两个计数器a，b</span><br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self  <span class="hljs-comment"># 实例本身就是迭代对象，故返回自己</span><br>  <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>    self.a, self.b = self.b, self.a + self.b  <span class="hljs-comment"># 计算下一个值</span><br>    <span class="hljs-keyword">if</span> self.a &gt; <span class="hljs-number">100000</span>:  <span class="hljs-comment"># 退出循环的条件</span><br>      <span class="hljs-keyword">raise</span> StopIteration()<br>    <span class="hljs-keyword">return</span> self.a  <span class="hljs-comment"># 返回下一个值</span><br>  <br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> Fib():<br>  <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure></li><li><p><code>__getitem__(self, item)</code>:用于实现对象的索引行为</p></li><li><p><code>__setitem__()</code>:把对象视作list或dict来对集合赋值</p></li><li><p><code>__delitem__()</code>:用于删除某个元素。</p></li><li><p><code>__getattr__(self,&#39;attr&#39;)</code>:动态返回一个属性</p></li><li><p><code>__call__()</code>:调用自身的属性或方法</p></li></ul></li></ul><p><strong>枚举类</strong></p><p>枚举类：<code>Enum</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br>Month = Enum(<span class="hljs-string">&#x27;Month&#x27;</span>, (<span class="hljs-string">&#x27;Jan&#x27;</span>, <span class="hljs-string">&#x27;Feb&#x27;</span>, <span class="hljs-string">&#x27;Mar&#x27;</span>, <span class="hljs-string">&#x27;Apr&#x27;</span>, <span class="hljs-string">&#x27;May&#x27;</span>, <span class="hljs-string">&#x27;Jun&#x27;</span>, <span class="hljs-string">&#x27;Jul&#x27;</span>, <span class="hljs-string">&#x27;Aug&#x27;</span>, <span class="hljs-string">&#x27;Sep&#x27;</span>, <span class="hljs-string">&#x27;Oct&#x27;</span>, <span class="hljs-string">&#x27;Nov&#x27;</span>, <span class="hljs-string">&#x27;Dec&#x27;</span>))<br><span class="hljs-comment"># the structure like this</span><br><span class="hljs-comment">#&#x27;Jan&#x27;: &lt;Month.Jan: 1&gt;,the &#x27;Jan&#x27; is: name,the Month.Jan is: member the 1 is: member.value</span><br></code></pre></td></tr></table></figure><ul><li><code>@unique</code>:检查有没有重复值，类似<code>JavaScript</code>的<code>Symbol</code></li></ul><p><strong><code>type()</code></strong></p><p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型</p><p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p><ol><li>class的名称；</li><li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li><li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li></ol><p>**<code>metaclass</code>**？？</p><p><code>metaclass</code>:元类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListMetaClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>    attrs[<span class="hljs-string">&#x27;add&#x27;</span>] = <span class="hljs-keyword">lambda</span> self, value: self.append(value)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, name, bases, attrs)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>(<span class="hljs-built_in">list</span>, metaclass=ListMetaClass):<br>  <span class="hljs-keyword">pass</span><br><br>L = MyList()<br>L.add(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(L)<br></code></pre></td></tr></table></figure><p><strong>静态语言 vs 动态语言</strong></p><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><p>动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><h2 id="1-12-错误、调试和测试"><a href="#1-12-错误、调试和测试" class="headerlink" title="1.12 错误、调试和测试"></a>1.12 错误、调试和测试</h2><h3 id="1-12-1-错误处理"><a href="#1-12-1-错误处理" class="headerlink" title="1.12.1 错误处理"></a>1.12.1 <strong>错误处理</strong></h3><p><code>try...except...finally...</code></p><ul><li>可以用多个<code>expect</code>来捕获不同类型的错误</li><li>如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句</li><li>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">try:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try...&#x27;</span>)<br>    r = 10 / 0<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;result:&#x27;</span>, r)<br>except ZeroDivisionError as e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;except:&#x27;</span>, e)<br>finally:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finally...&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>记录错误</strong></p><p>记录错误：<code>logging</code>模块（使用<code>logging</code>模块，程序打印完错误信息后会继续执行，并正常退出）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># err_logging.py</span><br><br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">try</span>:<br>        bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        logging.exception(e)<br><br>main()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>抛出错误</strong></p><p>使用<code>raise</code>语句抛出错误</p><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。如果要抛出错误，可以根据需要，自定义一个错误的class（或者使用python内置的错误类型：比如<code>ValueError</code>，<code>TypeError</code>），选择好继承关系，然后抛出错误</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooError</span>(<span class="hljs-title class_ inherited__">ValueError</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> FooError(<span class="hljs-string">&#x27;invalid value: %s&#x27;</span> % s)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / n<br><br>foo(<span class="hljs-string">&#x27;0&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="1-12-2-调试"><a href="#1-12-2-调试" class="headerlink" title="1.12.2 调试"></a>1.12.2 调试</h3><ul><li><p><code>assert</code>：断音</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">assert</span> n != <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;n is zero!&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / n<br><br>foo(<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment">#AssertionError: n is zero!</span><br></code></pre></td></tr></table></figure></li><li><p><code>logging</code>:不会抛出错误，而且可以输出文件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(level=logging.INFO)<br><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br>logging.info(<span class="hljs-string">&#x27;n = %d&#x27;</span> % n)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure></li><li><p><code>pdb</code>：</p><ul><li>启动<code>pdb</code>命令：<code> python -m pdb err.py</code></li><li>定位到代码：输入代码块</li><li>查看代码：<code>list</code></li><li>单步执行代码：<code>n</code></li><li>查看变量：<code>p 变量名</code></li><li>结束调试：<code>q</code></li></ul></li><li><p><code>pdb.set_trace()</code>:在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p><ul><li>查看变量：<code>p</code></li><li>继续运行：<code>c</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># err.py</span><br><span class="hljs-keyword">import</span> pdb<br><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br>pdb.set_trace() <span class="hljs-comment"># 运行到这里会自动暂停</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-13-文件IO"><a href="#1-13-文件IO" class="headerlink" title="1.13 文件IO"></a>1.13 文件IO</h2><h3 id="1-13-1-文件读写"><a href="#1-13-1-文件读写" class="headerlink" title="1.13.1 文件读写"></a>1.13.1 文件读写</h3><p>python文件读写类似c语言</p><ul><li><p>打开文件：<code>open(&#39;xxPath&#39;,&#39;xxMode&#39;)</code></p></li><li><p>读文件：</p><ul><li><code>read()</code>：一次性读取</li><li><code>read(size)</code></li><li><code>readline()</code>:可以每次读取一行内容</li><li><code>readlines()</code>:一次读取所有内容并按行返回<code>list</code></li></ul></li><li><p>写文件：</p></li><li><p>关闭文件：<code>close()</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-built_in">print</span>(f)<br><span class="hljs-built_in">print</span>(f.read())<br>f.close()<br></code></pre></td></tr></table></figure></li><li><p><code>with ... as f:</code>:在<code>with</code>语句里会自动调用<code>close()</code>方法</p></li><li><p>读取二进制文件：<code>open(&#39;xxPath&#39;,&#39;rb&#39;)</code></p></li><li><p>读取非UTF-8编码的文件：<code>open(&#39;xxPath&#39;,&#39;xxMode&#39;,encoding=&#39;xx编码&#39;)</code></p><ul><li><code>errors=&#39;ignore&#39;</code></li></ul></li></ul><h3 id="1-13-2-内存读写"><a href="#1-13-2-内存读写" class="headerlink" title="1.13.2 内存读写"></a>1.13.2 内存读写</h3><p><strong>读写<code>str</code></strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br><br>f = StringIO()<br>f.write(<span class="hljs-string">&#x27;world!&#x27;</span>)<br><span class="hljs-built_in">print</span>(f.getvalue()) <span class="hljs-comment">#getvalue()方法用于获得写入后的str。</span><br></code></pre></td></tr></table></figure><p><strong>操作二进制数据</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><br>f = BytesIO()<br>f.write(<span class="hljs-string">&#x27;中文&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-built_in">print</span>(f.getvalue())<br></code></pre></td></tr></table></figure><h3 id="1-13-3-操作文件和目录"><a href="#1-13-3-操作文件和目录" class="headerlink" title="1.13.3 操作文件和目录"></a>1.13.3 操作文件和目录</h3><ul><li>操作系统类型：<code>os.name </code></li><li>环境变量：<code>os.environ</code></li><li>获取某个环境变量的值: <code>os.environ.get(&#39;key&#39;)</code></li><li>查看当前目录的绝对路径：<code>os.path.abspath(&#39;.&#39;)</code></li><li>合并路径：<code>os.path.join()</code></li><li>创建目录：<code>os.mkdir()</code></li><li>删除目录: <code>os.rmdir()</code></li><li>拆分路径为两部分，后一部分总是最后级别的目录或文件名：<code>os.path.split()</code></li><li>获取文件扩展名：<code>os.path.splitext()</code></li></ul><h3 id="1-13-4-序列化"><a href="#1-13-4-序列化" class="headerlink" title="1.13.4 序列化"></a>1.13.4 序列化</h3><p>序列化：把变量从内存中变成可存储或传输的过程</p><p>Python提供了<code>pickle</code>模块来实现序列化。</p><ul><li>把任意对象序列化成一个<code>bytes</code>：<code>pickle.dumps()</code></li><li>把对象序列化后写入一个file-like Object：<code>pickle.dump()</code></li><li>反序列化出对象：<code>pickle.loads()</code></li><li>从一个<code>file-like Object</code>中直接反序列化出对象：<code>pickle.load()</code></li></ul><p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换</p><ul><li><p><code>json.dumps()</code></p></li><li><p><code>json.dump()</code></p></li><li><p><code>json.loads()</code></p></li><li><p><code>json.load()</code></p></li><li><p>进阶：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, score</span>):<br>    self.name = name<br>    self.age = age<br>    self.score = score<br><br>s = Student(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">88</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">student2dict</span>(<span class="hljs-params">std</span>):<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-string">&#x27;name&#x27;</span>: std.name,<br>    <span class="hljs-string">&#x27;age&#x27;</span>: std.age,<br>    <span class="hljs-string">&#x27;score&#x27;</span>: std.score<br>  &#125;<br><br><span class="hljs-built_in">print</span>(json.dumps(s, default=student2dict))<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-14-进程和线程"><a href="#1-14-进程和线程" class="headerlink" title="1.14 进程和线程"></a>1.14 进程和线程</h2><h3 id="1-14-1-多进程"><a href="#1-14-1-多进程" class="headerlink" title="1.14.1 多进程"></a>1.14.1 多进程</h3><ul><li><p><code>linux</code>:</p><ul><li><p>创建子进程：<code>os.fork()</code></p></li><li><p>获取进程id：<code>os.getpid()</code></p><p>获取父进程id：<code>os.getppid()</code></p></li></ul></li><li><p><code>windows</code>:由于Windows没有<code>fork</code>调用,所以使用<code>multiprocessing</code>模块(跨平台版本的多进程模块。)</p><ul><li><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动。</p></li><li><p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 子进程要执行的代码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_proc</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent process %s.&#x27;</span> % os.getpid())<br>    p = Process(target=run_proc, args=(<span class="hljs-string">&#x27;test&#x27;</span>,))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process will start.&#x27;</span>)<br>    p.start()<br>    p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process end.&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>线程池：<code>Pool</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">import</span> os, time, random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">long_time_task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Run task %s (%s)...&#x27;</span> % (name, os.getpid()))<br>    start = time.time()<br>    time.sleep(random.random() * <span class="hljs-number">3</span>)<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Task %s runs %0.2f seconds.&#x27;</span> % (name, (end - start)))<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent process %s.&#x27;</span> % os.getpid())<br>    p = Pool(<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        p.apply_async(long_time_task, args=(i,))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waiting for all subprocesses done...&#x27;</span>)<br>    p.close()<br>    p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;All subprocesses done.&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>进程通信：<code>Queue()</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue<br><span class="hljs-keyword">import</span> os, time, random<br><br><span class="hljs-comment"># 写数据进程执行的代码:</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Process to write: %s&#x27;</span> % os.getpid())<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Put %s to queue...&#x27;</span> % value)<br>        q.put(value)<br>        time.sleep(random.random())<br><br><span class="hljs-comment"># 读数据进程执行的代码:</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Process to read: %s&#x27;</span> % os.getpid())<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        value = q.get(<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Get %s from queue.&#x27;</span> % value)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 父进程创建Queue，并传给各个子进程：</span><br>    q = Queue()<br>    pw = Process(target=write, args=(q,))<br>    pr = Process(target=read, args=(q,))<br>    <span class="hljs-comment"># 启动子进程pw，写入:</span><br>    pw.start()<br>    <span class="hljs-comment"># 启动子进程pr，读取:</span><br>    pr.start()<br>    <span class="hljs-comment"># 等待pw结束:</span><br>    pw.join()<br>    <span class="hljs-comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span><br>    pr.terminate()<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-14-2-多线程"><a href="#1-14-2-多线程" class="headerlink" title="1.14.2 多线程"></a>1.14.2 多线程</h3><p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。</p><ul><li><p>创建线程：<code>threading.Thread(target=xxFunc,name=&#39;xx&#39;)</code></p></li><li><p>获取当前线程信息：<code>threading.current_thread()</code></p></li><li><p>线程锁</p><ul><li><p>创建线程锁：<code>lock = threading.Lock()</code></p></li><li><p>获取锁：<code>lock.require()</code></p></li><li><p>释放锁: <code>lock.release</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py">balance = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_thread</span>(<span class="hljs-params">n</span>):<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>    <span class="hljs-comment"># 先要获取锁:</span><br>    lock.acquire()<br>    <span class="hljs-keyword">try</span>:<br>      <span class="hljs-comment"># 放心地改吧:</span><br>      change_it(n)<br>    <span class="hljs-keyword">finally</span>:<br>      <span class="hljs-comment"># 改完了一定要释放锁:</span><br>      lock.release()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_it</span>(<span class="hljs-params">n</span>):<br>  <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>  <span class="hljs-keyword">global</span> balance<br>  balance = balance + n<br>  balance = balance - n<br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br><span class="hljs-built_in">print</span>(balance)<br></code></pre></td></tr></table></figure></li><li><p><code>ThreadLocal:</code>一个全局变量，每个线程却可以利用它来保存属于自己的私有数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py">local_school=threading.local()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_student</span>():<br>  std=local_school.student<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello %s (in %s)&#x27;</span>%(std,threading.current_thread().name))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_thread</span>(<span class="hljs-params">name</span>):<br>  local_school.student=name<br>  process_student()<br>  <br>t1=threading.Thread(target=process_thread,args=(<span class="hljs-string">&#x27;bob&#x27;</span>,),name=<span class="hljs-string">&#x27;bob_thread&#x27;</span>)<br>t1.start()<br>t1.join()<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="1-15-异步IO"><a href="#1-15-异步IO" class="headerlink" title="1.15 异步IO"></a>1.15 异步IO</h2><ul><li><p><code>asyncio</code>:<code>asyncio</code>的编程模型就是一个消息循环。我们从<code>asyncio</code>模块中直接获取一个<code>EventLoop</code>的引用，然后把需要执行的协程扔到<code>EventLoop</code>中执行，就实现了异步IO。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world (%s)&#x27;</span> % threading.currentThread())<br>  <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello again (%s)&#x27;</span> % threading.currentThread())<br><br>loop = asyncio.get_event_loop()<br>tasks = [hello(), hello()]<br>loop.run_until_complete(asyncio.wait(tasks))<br>loop.close()<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-xx-正则表达式"><a href="#1-xx-正则表达式" class="headerlink" title="1.xx 正则表达式"></a>1.xx 正则表达式</h2><p>正则表达式是使用反斜杠<code>\</code>作为匹配工具的字符串</p><ul><li><p><code>.</code>：可以匹配任意字符</p></li><li><p><code>*</code>：表示任意个字符（包括0个）</p></li><li><p><code>+</code>：表示至少一个字符</p></li><li><p><code>?</code>：表示0个或1个字符</p></li><li><p><code>&#123;n&#125;</code>：表示n个字符</p></li><li><p><code>&#123;n,m&#125;</code>：表示n-m个字符：</p></li><li><p><code>\d</code>:表示匹配数字</p></li><li><p><code>\w</code>: 表示匹配字母</p></li><li><p><code>\s</code>：可以匹配一个空格（也包括Tab等空白符</p></li><li><p><code>\_</code>：<code>\</code>+特殊字符，表示匹配该特殊字符</p></li><li><p><code>^</code>：表示行的开头，<code>^\d</code>表示必须以数字开头。</p></li><li><p><code>$</code>：表示行的结束，<code>\d$</code>表示必须以数字结束。</p></li><li><p><code>A|B</code>：可以匹配A或B</p></li><li><p><code>[]</code>: 可以表示匹配范围，</p><ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li></ul></li><li><p><code>()</code>: 可用于分组提取子串</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">m=re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>,<span class="hljs-string">&#x27;010-12345&#x27;</span>)<br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(m.group(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure></li></ul><p>在Python中使用<code>re</code>模块，来使用正则表达式</p><ul><li><p><code>re.match()</code></p></li><li><p><code>re.splict()</code>: 可用与切分字符串</p><ul><li><code>re.split(r&#39;[\s\,]+&#39;, &#39;a,b, c  d&#39;)</code></li></ul></li><li><p>贪婪匹配：正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符</p><ul><li>如<code>\d+</code>采用贪婪匹配，加<code>?</code>可以让<code>\d+</code>采用非贪婪匹配：<code>\d+?</code></li></ul></li><li><p><code>rm.compiler()</code>: 编译后生成Regular Expression对象</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">re_telephone = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>)<br>re_telephone.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;010-12345&#x27;</span>).groups()<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python-Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Hexo Blog Building Process</title>
    <link href="/2023/03/10/my-first-build-remark/"/>
    <url>/2023/03/10/my-first-build-remark/</url>
    
    <content type="html"><![CDATA[<img src="/2023/03/10/my-first-build-remark/739175c1cf079121eb57a66ddbf7048e.jpg" class="" title="This is an example image"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p>Hexo:<a href="https://xie.infoq.cn/article/ac51ce1f6e9434779c35cbb6c">参考网址</a> <a href="https://hexo.io/zh-cn/">Hexo网址</a> <a href="https://mrseawave.github.io/blogs/articles/2021/01/05/writing-hexo/">Hexo生成新的文章</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: [Deployment](</p>]]></content>
    
    
    <categories>
      
      <category>First-Build</category>
      
    </categories>
    
    
    <tags>
      
      <tag>First-Build</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
